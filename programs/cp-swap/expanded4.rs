#![feature(prelude_import)]
#[macro_use]
extern crate std;
#[prelude_import]
use std::prelude::rust_2021::*;
pub mod curve {
    //! Curve invariant implementations
    pub mod calculator {
        //! Swap calculations
        use crate::curve::{constant_product::ConstantProductCurve, fees::Fees};
        use anchor_lang::prelude::*;
        use {crate::error::ErrorCode, std::fmt::Debug};
        /// Helper function for mapping to ErrorCode::CalculationFailure
        pub fn map_zero_to_none(x: u128) -> Option<u128> {
            if x == 0 { None } else { Some(x) }
        }
        /// The direction of a trade, since curves can be specialized to treat each
        /// token differently (by adding offsets or weights)
        pub enum TradeDirection {
            /// Input token 0, output token 1
            ZeroForOne,
            /// Input token 1, output token 0
            OneForZero,
        }
        #[automatically_derived]
        impl ::core::clone::Clone for TradeDirection {
            #[inline]
            fn clone(&self) -> TradeDirection {
                *self
            }
        }
        #[automatically_derived]
        impl ::core::marker::Copy for TradeDirection {}
        #[automatically_derived]
        impl ::core::fmt::Debug for TradeDirection {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::write_str(
                    f,
                    match self {
                        TradeDirection::ZeroForOne => "ZeroForOne",
                        TradeDirection::OneForZero => "OneForZero",
                    },
                )
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for TradeDirection {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for TradeDirection {
            #[inline]
            fn eq(&self, other: &TradeDirection) -> bool {
                let __self_discr = ::core::intrinsics::discriminant_value(self);
                let __arg1_discr = ::core::intrinsics::discriminant_value(other);
                __self_discr == __arg1_discr
            }
        }
        /// The direction to round.  Used for pool token to trading token conversions to
        /// avoid losing value on any deposit or withdrawal.
        #[repr(C)]
        pub enum RoundDirection {
            /// Floor the value, ie. 1.9 => 1, 1.1 => 1, 1.5 => 1
            Floor,
            /// Ceiling the value, ie. 1.9 => 2, 1.1 => 2, 1.5 => 2
            Ceiling,
        }
        #[automatically_derived]
        impl ::core::clone::Clone for RoundDirection {
            #[inline]
            fn clone(&self) -> RoundDirection {
                *self
            }
        }
        #[automatically_derived]
        impl ::core::marker::Copy for RoundDirection {}
        #[automatically_derived]
        impl ::core::fmt::Debug for RoundDirection {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::write_str(
                    f,
                    match self {
                        RoundDirection::Floor => "Floor",
                        RoundDirection::Ceiling => "Ceiling",
                    },
                )
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for RoundDirection {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for RoundDirection {
            #[inline]
            fn eq(&self, other: &RoundDirection) -> bool {
                let __self_discr = ::core::intrinsics::discriminant_value(self);
                let __arg1_discr = ::core::intrinsics::discriminant_value(other);
                __self_discr == __arg1_discr
            }
        }
        impl TradeDirection {
            /// Given a trade direction, gives the opposite direction of the trade, so
            /// A to B becomes B to A, and vice versa
            pub fn opposite(&self) -> TradeDirection {
                match self {
                    TradeDirection::ZeroForOne => TradeDirection::OneForZero,
                    TradeDirection::OneForZero => TradeDirection::ZeroForOne,
                }
            }
        }
        /// Encodes results of depositing both sides at once
        pub struct TradingTokenResult {
            /// Amount of token A
            pub token_0_amount: u128,
            /// Amount of token B
            pub token_1_amount: u128,
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for TradingTokenResult {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field2_finish(
                    f,
                    "TradingTokenResult",
                    "token_0_amount",
                    &self.token_0_amount,
                    "token_1_amount",
                    &&self.token_1_amount,
                )
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for TradingTokenResult {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for TradingTokenResult {
            #[inline]
            fn eq(&self, other: &TradingTokenResult) -> bool {
                self.token_0_amount == other.token_0_amount
                    && self.token_1_amount == other.token_1_amount
            }
        }
        /// Encodes all results of swapping from a source token to a destination token
        pub struct SwapResult {
            /// New amount of source token
            pub new_swap_source_amount: u128,
            /// New amount of destination token
            pub new_swap_destination_amount: u128,
            /// Amount of source token swapped (includes fees)
            pub source_amount_swapped: u128,
            /// Amount of destination token swapped
            pub destination_amount_swapped: u128,
            /// Amount of source tokens going to pool holders
            pub trade_fee: u128,
            /// Amount of source tokens going to protocol
            pub protocol_fee: u128,
            /// Amount of source tokens going to protocol team
            pub fund_fee: u128,
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for SwapResult {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                let names: &'static _ = &[
                    "new_swap_source_amount",
                    "new_swap_destination_amount",
                    "source_amount_swapped",
                    "destination_amount_swapped",
                    "trade_fee",
                    "protocol_fee",
                    "fund_fee",
                ];
                let values: &[&dyn ::core::fmt::Debug] = &[
                    &self.new_swap_source_amount,
                    &self.new_swap_destination_amount,
                    &self.source_amount_swapped,
                    &self.destination_amount_swapped,
                    &self.trade_fee,
                    &self.protocol_fee,
                    &&self.fund_fee,
                ];
                ::core::fmt::Formatter::debug_struct_fields_finish(
                    f,
                    "SwapResult",
                    names,
                    values,
                )
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for SwapResult {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for SwapResult {
            #[inline]
            fn eq(&self, other: &SwapResult) -> bool {
                self.new_swap_source_amount == other.new_swap_source_amount
                    && self.new_swap_destination_amount
                        == other.new_swap_destination_amount
                    && self.source_amount_swapped == other.source_amount_swapped
                    && self.destination_amount_swapped
                        == other.destination_amount_swapped
                    && self.trade_fee == other.trade_fee
                    && self.protocol_fee == other.protocol_fee
                    && self.fund_fee == other.fund_fee
            }
        }
        /// Concrete struct to wrap around the trait object which performs calculation.
        pub struct CurveCalculator {}
        #[automatically_derived]
        impl ::core::clone::Clone for CurveCalculator {
            #[inline]
            fn clone(&self) -> CurveCalculator {
                CurveCalculator {}
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for CurveCalculator {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::write_str(f, "CurveCalculator")
            }
        }
        #[automatically_derived]
        impl ::core::default::Default for CurveCalculator {
            #[inline]
            fn default() -> CurveCalculator {
                CurveCalculator {}
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for CurveCalculator {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for CurveCalculator {
            #[inline]
            fn eq(&self, other: &CurveCalculator) -> bool {
                true
            }
        }
        impl CurveCalculator {
            pub fn validate_supply(
                token_0_amount: u64,
                token_1_amount: u64,
            ) -> Result<()> {
                if token_0_amount == 0 {
                    return Err(ErrorCode::EmptySupply.into());
                }
                if token_1_amount == 0 {
                    return Err(ErrorCode::EmptySupply.into());
                }
                Ok(())
            }
            /// Subtract fees and calculate how much destination token will be provided
            /// given an amount of source token.
            pub fn swap_base_input(
                source_amount: u128,
                swap_source_amount: u128,
                swap_destination_amount: u128,
                trade_fee_rate: u64,
                protocol_fee_rate: u64,
                fund_fee_rate: u64,
            ) -> Option<SwapResult> {
                let trade_fee = Fees::trading_fee(source_amount, trade_fee_rate)?;
                let protocol_fee = Fees::protocol_fee(trade_fee, protocol_fee_rate)?;
                let fund_fee = Fees::fund_fee(trade_fee, fund_fee_rate)?;
                let source_amount_less_fees = source_amount.checked_sub(trade_fee)?;
                let destination_amount_swapped = ConstantProductCurve::swap_base_input_without_fees(
                    source_amount_less_fees,
                    swap_source_amount,
                    swap_destination_amount,
                );
                Some(SwapResult {
                    new_swap_source_amount: swap_source_amount
                        .checked_add(source_amount)?,
                    new_swap_destination_amount: swap_destination_amount
                        .checked_sub(destination_amount_swapped)?,
                    source_amount_swapped: source_amount,
                    destination_amount_swapped,
                    trade_fee,
                    protocol_fee,
                    fund_fee,
                })
            }
            pub fn swap_base_output(
                destinsation_amount: u128,
                swap_source_amount: u128,
                swap_destination_amount: u128,
                trade_fee_rate: u64,
                protocol_fee_rate: u64,
                fund_fee_rate: u64,
            ) -> Option<SwapResult> {
                let source_amount_swapped = ConstantProductCurve::swap_base_output_without_fees(
                    destinsation_amount,
                    swap_source_amount,
                    swap_destination_amount,
                );
                let source_amount = Fees::calculate_pre_fee_amount(
                        source_amount_swapped,
                        trade_fee_rate,
                    )
                    .unwrap();
                let trade_fee = Fees::trading_fee(source_amount, trade_fee_rate)?;
                let protocol_fee = Fees::protocol_fee(trade_fee, protocol_fee_rate)?;
                let fund_fee = Fees::fund_fee(trade_fee, fund_fee_rate)?;
                Some(SwapResult {
                    new_swap_source_amount: swap_source_amount
                        .checked_add(source_amount)?,
                    new_swap_destination_amount: swap_destination_amount
                        .checked_sub(destinsation_amount)?,
                    source_amount_swapped: source_amount,
                    destination_amount_swapped: destinsation_amount,
                    trade_fee,
                    protocol_fee,
                    fund_fee,
                })
            }
            /// Get the amount of trading tokens for the given amount of pool tokens,
            /// provided the total trading tokens and supply of pool tokens.
            pub fn lp_tokens_to_trading_tokens(
                lp_token_amount: u128,
                lp_token_supply: u128,
                swap_token_0_amount: u128,
                swap_token_1_amount: u128,
                round_direction: RoundDirection,
            ) -> Option<TradingTokenResult> {
                ConstantProductCurve::lp_tokens_to_trading_tokens(
                    lp_token_amount,
                    lp_token_supply,
                    swap_token_0_amount,
                    swap_token_1_amount,
                    round_direction,
                )
            }
        }
    }
    pub mod constant_product {
        //! The Uniswap invariantConstantProductCurve::
        use crate::{
            curve::calculator::{RoundDirection, TradingTokenResult},
            utils::CheckedCeilDiv,
        };
        /// ConstantProductCurve struct implementing CurveCalculator
        pub struct ConstantProductCurve;
        #[automatically_derived]
        impl ::core::clone::Clone for ConstantProductCurve {
            #[inline]
            fn clone(&self) -> ConstantProductCurve {
                ConstantProductCurve
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for ConstantProductCurve {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::write_str(f, "ConstantProductCurve")
            }
        }
        #[automatically_derived]
        impl ::core::default::Default for ConstantProductCurve {
            #[inline]
            fn default() -> ConstantProductCurve {
                ConstantProductCurve {}
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for ConstantProductCurve {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for ConstantProductCurve {
            #[inline]
            fn eq(&self, other: &ConstantProductCurve) -> bool {
                true
            }
        }
        impl ConstantProductCurve {
            /// Constant product swap ensures x * y = constant
            /// The constant product swap calculation, factored out of its class for reuse.
            ///
            /// This is guaranteed to work for all values such that:
            ///  - 1 <= swap_source_amount * swap_destination_amount <= u128::MAX
            ///  - 1 <= source_amount <= u64::MAX
            pub fn swap_base_input_without_fees(
                source_amount: u128,
                swap_source_amount: u128,
                swap_destination_amount: u128,
            ) -> u128 {
                let numerator = source_amount
                    .checked_mul(swap_destination_amount)
                    .unwrap();
                let denominator = swap_source_amount.checked_add(source_amount).unwrap();
                let destinsation_amount_swapped = numerator
                    .checked_div(denominator)
                    .unwrap();
                destinsation_amount_swapped
            }
            pub fn swap_base_output_without_fees(
                destinsation_amount: u128,
                swap_source_amount: u128,
                swap_destination_amount: u128,
            ) -> u128 {
                let numerator = swap_source_amount
                    .checked_mul(destinsation_amount)
                    .unwrap();
                let denominator = swap_destination_amount
                    .checked_sub(destinsation_amount)
                    .unwrap();
                let (source_amount_swapped, _) = numerator
                    .checked_ceil_div(denominator)
                    .unwrap();
                source_amount_swapped
            }
            /// Get the amount of trading tokens for the given amount of pool tokens,
            /// provided the total trading tokens and supply of pool tokens.
            ///
            /// The constant product implementation is a simple ratio calculation for how
            /// many trading tokens correspond to a certain number of pool tokens
            pub fn lp_tokens_to_trading_tokens(
                lp_token_amount: u128,
                lp_token_supply: u128,
                swap_token_0_amount: u128,
                swap_token_1_amount: u128,
                round_direction: RoundDirection,
            ) -> Option<TradingTokenResult> {
                let mut token_0_amount = lp_token_amount
                    .checked_mul(swap_token_0_amount)?
                    .checked_div(lp_token_supply)?;
                let mut token_1_amount = lp_token_amount
                    .checked_mul(swap_token_1_amount)?
                    .checked_div(lp_token_supply)?;
                let (token_0_amount, token_1_amount) = match round_direction {
                    RoundDirection::Floor => (token_0_amount, token_1_amount),
                    RoundDirection::Ceiling => {
                        let token_0_remainder = lp_token_amount
                            .checked_mul(swap_token_0_amount)?
                            .checked_rem(lp_token_supply)?;
                        if token_0_remainder > 0 && token_0_amount > 0 {
                            token_0_amount += 1;
                        }
                        let token_1_remainder = lp_token_amount
                            .checked_mul(swap_token_1_amount)?
                            .checked_rem(lp_token_supply)?;
                        if token_1_remainder > 0 && token_1_amount > 0 {
                            token_1_amount += 1;
                        }
                        (token_0_amount, token_1_amount)
                    }
                };
                Some(TradingTokenResult {
                    token_0_amount,
                    token_1_amount,
                })
            }
        }
    }
    pub mod fees {
        //! All fee information, to be used for validation currently
        pub const FEE_RATE_DENOMINATOR_VALUE: u64 = 1_000_000;
        pub struct Fees {}
        fn ceil_div(
            token_amount: u128,
            fee_numerator: u128,
            fee_denominator: u128,
        ) -> Option<u128> {
            token_amount
                .checked_mul(u128::from(fee_numerator))
                .unwrap()
                .checked_add(fee_denominator)?
                .checked_sub(1)?
                .checked_div(fee_denominator)
        }
        /// Helper function for calculating swap fee
        pub fn floor_div(
            token_amount: u128,
            fee_numerator: u128,
            fee_denominator: u128,
        ) -> Option<u128> {
            Some(token_amount.checked_mul(fee_numerator)?.checked_div(fee_denominator)?)
        }
        impl Fees {
            /// Calculate the trading fee in trading tokens
            pub fn trading_fee(amount: u128, trade_fee_rate: u64) -> Option<u128> {
                ceil_div(
                    amount,
                    u128::from(trade_fee_rate),
                    u128::from(FEE_RATE_DENOMINATOR_VALUE),
                )
            }
            /// Calculate the owner protocol fee in trading tokens
            pub fn protocol_fee(amount: u128, protocol_fee_rate: u64) -> Option<u128> {
                floor_div(
                    amount,
                    u128::from(protocol_fee_rate),
                    u128::from(FEE_RATE_DENOMINATOR_VALUE),
                )
            }
            /// Calculate the owner fund fee in trading tokens
            pub fn fund_fee(amount: u128, fund_fee_rate: u64) -> Option<u128> {
                floor_div(
                    amount,
                    u128::from(fund_fee_rate),
                    u128::from(FEE_RATE_DENOMINATOR_VALUE),
                )
            }
            pub fn calculate_pre_fee_amount(
                post_fee_amount: u128,
                trade_fee_rate: u64,
            ) -> Option<u128> {
                if trade_fee_rate == 0 {
                    Some(post_fee_amount)
                } else {
                    let numerator = post_fee_amount
                        .checked_mul(u128::from(FEE_RATE_DENOMINATOR_VALUE))?;
                    let denominator = u128::from(FEE_RATE_DENOMINATOR_VALUE)
                        .checked_sub(u128::from(trade_fee_rate))?;
                    numerator
                        .checked_add(denominator)?
                        .checked_sub(1)?
                        .checked_div(denominator)
                }
            }
        }
    }
    pub use calculator::*;
    pub use constant_product::*;
    pub use fees::*;
}
pub mod error {
    /// Errors that may be returned by the TokenSwap program.
    use anchor_lang::prelude::*;
    #[repr(u32)]
    pub enum ErrorCode {
        NotApproved,
        /// The owner of the input isn't set to the program address generated by the
        /// program.
        InvalidOwner,
        /// The input token account is empty.
        EmptySupply,
        /// The input token is invalid for swap.
        InvalidInput,
        /// Address of the provided pool token mint is incorrect
        IncorrectLpMint,
        /// Exceeds desired slippage limit
        ExceededSlippage,
        /// Given pool token amount results in zero trading tokens
        ZeroTradingTokens,
        NotSupportMint,
        InvalidVault,
        InitLpAmountTooLess,
        TransferFeeCalculateNotMatch,
        /// ZK Compression.
        InvalidAccountCount,
        InvalidRentRecipient,
        InvalidLpMintAddress,
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for ErrorCode {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::write_str(
                f,
                match self {
                    ErrorCode::NotApproved => "NotApproved",
                    ErrorCode::InvalidOwner => "InvalidOwner",
                    ErrorCode::EmptySupply => "EmptySupply",
                    ErrorCode::InvalidInput => "InvalidInput",
                    ErrorCode::IncorrectLpMint => "IncorrectLpMint",
                    ErrorCode::ExceededSlippage => "ExceededSlippage",
                    ErrorCode::ZeroTradingTokens => "ZeroTradingTokens",
                    ErrorCode::NotSupportMint => "NotSupportMint",
                    ErrorCode::InvalidVault => "InvalidVault",
                    ErrorCode::InitLpAmountTooLess => "InitLpAmountTooLess",
                    ErrorCode::TransferFeeCalculateNotMatch => {
                        "TransferFeeCalculateNotMatch"
                    }
                    ErrorCode::InvalidAccountCount => "InvalidAccountCount",
                    ErrorCode::InvalidRentRecipient => "InvalidRentRecipient",
                    ErrorCode::InvalidLpMintAddress => "InvalidLpMintAddress",
                },
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for ErrorCode {
        #[inline]
        fn clone(&self) -> ErrorCode {
            *self
        }
    }
    #[automatically_derived]
    impl ::core::marker::Copy for ErrorCode {}
    impl ErrorCode {
        /// Gets the name of this [#enum_name].
        pub fn name(&self) -> String {
            match self {
                ErrorCode::NotApproved => "NotApproved".to_string(),
                ErrorCode::InvalidOwner => "InvalidOwner".to_string(),
                ErrorCode::EmptySupply => "EmptySupply".to_string(),
                ErrorCode::InvalidInput => "InvalidInput".to_string(),
                ErrorCode::IncorrectLpMint => "IncorrectLpMint".to_string(),
                ErrorCode::ExceededSlippage => "ExceededSlippage".to_string(),
                ErrorCode::ZeroTradingTokens => "ZeroTradingTokens".to_string(),
                ErrorCode::NotSupportMint => "NotSupportMint".to_string(),
                ErrorCode::InvalidVault => "InvalidVault".to_string(),
                ErrorCode::InitLpAmountTooLess => "InitLpAmountTooLess".to_string(),
                ErrorCode::TransferFeeCalculateNotMatch => {
                    "TransferFeeCalculateNotMatch".to_string()
                }
                ErrorCode::InvalidAccountCount => "InvalidAccountCount".to_string(),
                ErrorCode::InvalidRentRecipient => "InvalidRentRecipient".to_string(),
                ErrorCode::InvalidLpMintAddress => "InvalidLpMintAddress".to_string(),
            }
        }
    }
    impl From<ErrorCode> for u32 {
        fn from(e: ErrorCode) -> u32 {
            e as u32 + anchor_lang::error::ERROR_CODE_OFFSET
        }
    }
    impl From<ErrorCode> for anchor_lang::error::Error {
        fn from(error_code: ErrorCode) -> anchor_lang::error::Error {
            anchor_lang::error::Error::from(anchor_lang::error::AnchorError {
                error_name: error_code.name(),
                error_code_number: error_code.into(),
                error_msg: error_code.to_string(),
                error_origin: None,
                compared_values: None,
            })
        }
    }
    impl std::fmt::Display for ErrorCode {
        fn fmt(
            &self,
            fmt: &mut std::fmt::Formatter<'_>,
        ) -> std::result::Result<(), std::fmt::Error> {
            match self {
                ErrorCode::NotApproved => fmt.write_fmt(format_args!("Not approved")),
                ErrorCode::InvalidOwner => {
                    fmt.write_fmt(
                        format_args!("Input account owner is not the program address"),
                    )
                }
                ErrorCode::EmptySupply => {
                    fmt.write_fmt(format_args!("Input token account empty"))
                }
                ErrorCode::InvalidInput => fmt.write_fmt(format_args!("InvalidInput")),
                ErrorCode::IncorrectLpMint => {
                    fmt.write_fmt(
                        format_args!(
                            "Address of the provided lp token mint is incorrect",
                        ),
                    )
                }
                ErrorCode::ExceededSlippage => {
                    fmt.write_fmt(format_args!("Exceeds desired slippage limit"))
                }
                ErrorCode::ZeroTradingTokens => {
                    fmt.write_fmt(
                        format_args!(
                            "Given pool token amount results in zero trading tokens",
                        ),
                    )
                }
                ErrorCode::NotSupportMint => {
                    fmt.write_fmt(format_args!("Not support token_2022 mint extension"))
                }
                ErrorCode::InvalidVault => fmt.write_fmt(format_args!("invaild vault")),
                ErrorCode::InitLpAmountTooLess => {
                    fmt.write_fmt(
                        format_args!(
                            "Init lp amount is too less(Because 100 amount lp will be locked)",
                        ),
                    )
                }
                ErrorCode::TransferFeeCalculateNotMatch => {
                    fmt.write_fmt(format_args!("TransferFee calculate not match"))
                }
                ErrorCode::InvalidAccountCount => {
                    fmt.write_fmt(
                        format_args!(
                            "Invalid account count: PDAs and compressed accounts must match",
                        ),
                    )
                }
                ErrorCode::InvalidRentRecipient => {
                    fmt.write_fmt(format_args!("Rent recipient does not match config"))
                }
                ErrorCode::InvalidLpMintAddress => {
                    fmt.write_fmt(format_args!("Invalid LP mint address derivation"))
                }
            }
        }
    }
}
pub mod instructions {
    pub mod deposit {
        use crate::curve::CurveCalculator;
        use crate::curve::RoundDirection;
        use crate::error::ErrorCode;
        use crate::states::*;
        use crate::utils::ctoken::get_bumps;
        use crate::utils::token::*;
        use crate::utils::transfer_ctoken_from_pool_vault_to_user;
        use anchor_lang::prelude::*;
        use anchor_spl::token::Token;
        use anchor_spl::token_interface::{Mint, Token2022, TokenAccount};
        use light_sdk::compressible::HasCompressionInfo;
        pub struct Deposit<'info> {
            /// Pays to mint the position
            pub owner: Signer<'info>,
            /// CHECK: pool vault and lp mint authority
            #[account(seeds = [crate::AUTH_SEED.as_bytes()], bump)]
            pub authority: UncheckedAccount<'info>,
            #[account(mut)]
            pub pool_state: Account<'info, PoolState>,
            /// Owner lp token account
            #[account(mut, token::authority = owner)]
            pub owner_lp_token: Box<InterfaceAccount<'info, TokenAccount>>,
            /// The payer's token account for token_0
            #[account(mut, token::mint = token_0_vault.mint, token::authority = owner)]
            pub token_0_account: Box<InterfaceAccount<'info, TokenAccount>>,
            /// The payer's token account for token_1
            #[account(mut, token::mint = token_1_vault.mint, token::authority = owner)]
            pub token_1_account: Box<InterfaceAccount<'info, TokenAccount>>,
            /// The address that holds pool tokens for token_0
            #[account(mut, constraint = token_0_vault.key()= = pool_state.token_0_vault)]
            pub token_0_vault: Box<InterfaceAccount<'info, TokenAccount>>,
            /// The address that holds pool tokens for token_1
            #[account(mut, constraint = token_1_vault.key()= = pool_state.token_1_vault)]
            pub token_1_vault: Box<InterfaceAccount<'info, TokenAccount>>,
            /// token Program
            pub token_program: Program<'info, Token>,
            /// Token program 2022
            pub token_program_2022: Program<'info, Token2022>,
            /// The mint of token_0 vault
            #[account(
                address = token_0_vault.mint,
                mint::token_program = pool_state.token_0_program,
            )]
            pub vault_0_mint: Box<InterfaceAccount<'info, Mint>>,
            /// The mint of token_1 vault
            #[account(
                address = token_1_vault.mint,
                mint::token_program = pool_state.token_1_program,
            )]
            pub vault_1_mint: Box<InterfaceAccount<'info, Mint>>,
            /// Lp token vault
            #[account(
                mut,
                seeds = [POOL_VAULT_SEED.as_bytes(),
                pool_state.lp_mint.as_ref()],
                bump,
                token::mint = lp_vault.mint,
                token::authority = authority
            )]
            pub lp_vault: Box<InterfaceAccount<'info, TokenAccount>>,
            /// CHECK: checked by protocol.
            pub compressed_token_program_cpi_authority: AccountInfo<'info>,
            /// CHECK: checked by protocol.
            pub compressed_token_program: AccountInfo<'info>,
            /// CHECK: checked by protocol.
            ///
            /// Every mint must be registered in the compression protocol via a
            /// compression_token_pool_pda.
            #[account(mut)]
            pub compressed_token_0_pool_pda: AccountInfo<'info>,
            /// CHECK: checked by protocol.
            #[account(mut)]
            pub compressed_token_1_pool_pda: AccountInfo<'info>,
        }
        #[automatically_derived]
        impl<'info> anchor_lang::Accounts<'info, DepositBumps> for Deposit<'info>
        where
            'info: 'info,
        {
            #[inline(never)]
            fn try_accounts(
                __program_id: &anchor_lang::solana_program::pubkey::Pubkey,
                __accounts: &mut &'info [anchor_lang::solana_program::account_info::AccountInfo<
                    'info,
                >],
                __ix_data: &[u8],
                __bumps: &mut DepositBumps,
                __reallocs: &mut std::collections::BTreeSet<
                    anchor_lang::solana_program::pubkey::Pubkey,
                >,
            ) -> anchor_lang::Result<Self> {
                let owner: Signer = anchor_lang::Accounts::try_accounts(
                        __program_id,
                        __accounts,
                        __ix_data,
                        __bumps,
                        __reallocs,
                    )
                    .map_err(|e| e.with_account_name("owner"))?;
                let authority: UncheckedAccount = anchor_lang::Accounts::try_accounts(
                        __program_id,
                        __accounts,
                        __ix_data,
                        __bumps,
                        __reallocs,
                    )
                    .map_err(|e| e.with_account_name("authority"))?;
                let pool_state: anchor_lang::accounts::account::Account<PoolState> = anchor_lang::Accounts::try_accounts(
                        __program_id,
                        __accounts,
                        __ix_data,
                        __bumps,
                        __reallocs,
                    )
                    .map_err(|e| e.with_account_name("pool_state"))?;
                let owner_lp_token: Box<
                    anchor_lang::accounts::interface_account::InterfaceAccount<
                        TokenAccount,
                    >,
                > = anchor_lang::Accounts::try_accounts(
                        __program_id,
                        __accounts,
                        __ix_data,
                        __bumps,
                        __reallocs,
                    )
                    .map_err(|e| e.with_account_name("owner_lp_token"))?;
                let token_0_account: Box<
                    anchor_lang::accounts::interface_account::InterfaceAccount<
                        TokenAccount,
                    >,
                > = anchor_lang::Accounts::try_accounts(
                        __program_id,
                        __accounts,
                        __ix_data,
                        __bumps,
                        __reallocs,
                    )
                    .map_err(|e| e.with_account_name("token_0_account"))?;
                let token_1_account: Box<
                    anchor_lang::accounts::interface_account::InterfaceAccount<
                        TokenAccount,
                    >,
                > = anchor_lang::Accounts::try_accounts(
                        __program_id,
                        __accounts,
                        __ix_data,
                        __bumps,
                        __reallocs,
                    )
                    .map_err(|e| e.with_account_name("token_1_account"))?;
                let token_0_vault: Box<
                    anchor_lang::accounts::interface_account::InterfaceAccount<
                        TokenAccount,
                    >,
                > = anchor_lang::Accounts::try_accounts(
                        __program_id,
                        __accounts,
                        __ix_data,
                        __bumps,
                        __reallocs,
                    )
                    .map_err(|e| e.with_account_name("token_0_vault"))?;
                let token_1_vault: Box<
                    anchor_lang::accounts::interface_account::InterfaceAccount<
                        TokenAccount,
                    >,
                > = anchor_lang::Accounts::try_accounts(
                        __program_id,
                        __accounts,
                        __ix_data,
                        __bumps,
                        __reallocs,
                    )
                    .map_err(|e| e.with_account_name("token_1_vault"))?;
                let token_program: anchor_lang::accounts::program::Program<Token> = anchor_lang::Accounts::try_accounts(
                        __program_id,
                        __accounts,
                        __ix_data,
                        __bumps,
                        __reallocs,
                    )
                    .map_err(|e| e.with_account_name("token_program"))?;
                let token_program_2022: anchor_lang::accounts::program::Program<
                    Token2022,
                > = anchor_lang::Accounts::try_accounts(
                        __program_id,
                        __accounts,
                        __ix_data,
                        __bumps,
                        __reallocs,
                    )
                    .map_err(|e| e.with_account_name("token_program_2022"))?;
                let vault_0_mint: Box<
                    anchor_lang::accounts::interface_account::InterfaceAccount<Mint>,
                > = Box::new({
                    if __accounts.is_empty() {
                        return Err(
                            anchor_lang::error::ErrorCode::AccountNotEnoughKeys.into(),
                        );
                    }
                    let __acc = &__accounts[0];
                    *__accounts = &__accounts[1..];
                    anchor_lang::accounts::interface_account::InterfaceAccount::try_from_with_token_program(
                            __acc,
                            &pool_state.token_0_program,
                        )
                        .map_err(|e| e.with_account_name("vault_0_mint"))?
                });
                let vault_1_mint: Box<
                    anchor_lang::accounts::interface_account::InterfaceAccount<Mint>,
                > = Box::new({
                    if __accounts.is_empty() {
                        return Err(
                            anchor_lang::error::ErrorCode::AccountNotEnoughKeys.into(),
                        );
                    }
                    let __acc = &__accounts[0];
                    *__accounts = &__accounts[1..];
                    anchor_lang::accounts::interface_account::InterfaceAccount::try_from_with_token_program(
                            __acc,
                            &pool_state.token_1_program,
                        )
                        .map_err(|e| e.with_account_name("vault_1_mint"))?
                });
                let lp_vault: Box<
                    anchor_lang::accounts::interface_account::InterfaceAccount<
                        TokenAccount,
                    >,
                > = anchor_lang::Accounts::try_accounts(
                        __program_id,
                        __accounts,
                        __ix_data,
                        __bumps,
                        __reallocs,
                    )
                    .map_err(|e| e.with_account_name("lp_vault"))?;
                let compressed_token_program_cpi_authority: AccountInfo = anchor_lang::Accounts::try_accounts(
                        __program_id,
                        __accounts,
                        __ix_data,
                        __bumps,
                        __reallocs,
                    )
                    .map_err(|e| {
                        e.with_account_name("compressed_token_program_cpi_authority")
                    })?;
                let compressed_token_program: AccountInfo = anchor_lang::Accounts::try_accounts(
                        __program_id,
                        __accounts,
                        __ix_data,
                        __bumps,
                        __reallocs,
                    )
                    .map_err(|e| e.with_account_name("compressed_token_program"))?;
                let compressed_token_0_pool_pda: AccountInfo = anchor_lang::Accounts::try_accounts(
                        __program_id,
                        __accounts,
                        __ix_data,
                        __bumps,
                        __reallocs,
                    )
                    .map_err(|e| e.with_account_name("compressed_token_0_pool_pda"))?;
                let compressed_token_1_pool_pda: AccountInfo = anchor_lang::Accounts::try_accounts(
                        __program_id,
                        __accounts,
                        __ix_data,
                        __bumps,
                        __reallocs,
                    )
                    .map_err(|e| e.with_account_name("compressed_token_1_pool_pda"))?;
                let (__pda_address, __bump) = Pubkey::find_program_address(
                    &[crate::AUTH_SEED.as_bytes()],
                    &__program_id,
                );
                __bumps.authority = __bump;
                if authority.key() != __pda_address {
                    return Err(
                        anchor_lang::error::Error::from(
                                anchor_lang::error::ErrorCode::ConstraintSeeds,
                            )
                            .with_account_name("authority")
                            .with_pubkeys((authority.key(), __pda_address)),
                    );
                }
                if !AsRef::<AccountInfo>::as_ref(&pool_state).is_writable {
                    return Err(
                        anchor_lang::error::Error::from(
                                anchor_lang::error::ErrorCode::ConstraintMut,
                            )
                            .with_account_name("pool_state"),
                    );
                }
                if !AsRef::<AccountInfo>::as_ref(owner_lp_token.as_ref()).is_writable {
                    return Err(
                        anchor_lang::error::Error::from(
                                anchor_lang::error::ErrorCode::ConstraintMut,
                            )
                            .with_account_name("owner_lp_token"),
                    );
                }
                {
                    if owner_lp_token.owner != owner.key() {
                        return Err(
                            anchor_lang::error::ErrorCode::ConstraintTokenOwner.into(),
                        );
                    }
                }
                if !AsRef::<AccountInfo>::as_ref(token_0_account.as_ref()).is_writable {
                    return Err(
                        anchor_lang::error::Error::from(
                                anchor_lang::error::ErrorCode::ConstraintMut,
                            )
                            .with_account_name("token_0_account"),
                    );
                }
                {
                    if token_0_account.owner != owner.key() {
                        return Err(
                            anchor_lang::error::ErrorCode::ConstraintTokenOwner.into(),
                        );
                    }
                    if token_0_account.mint != token_0_vault.mint.key() {
                        return Err(
                            anchor_lang::error::ErrorCode::ConstraintTokenMint.into(),
                        );
                    }
                }
                if !AsRef::<AccountInfo>::as_ref(token_1_account.as_ref()).is_writable {
                    return Err(
                        anchor_lang::error::Error::from(
                                anchor_lang::error::ErrorCode::ConstraintMut,
                            )
                            .with_account_name("token_1_account"),
                    );
                }
                {
                    if token_1_account.owner != owner.key() {
                        return Err(
                            anchor_lang::error::ErrorCode::ConstraintTokenOwner.into(),
                        );
                    }
                    if token_1_account.mint != token_1_vault.mint.key() {
                        return Err(
                            anchor_lang::error::ErrorCode::ConstraintTokenMint.into(),
                        );
                    }
                }
                if !AsRef::<AccountInfo>::as_ref(token_0_vault.as_ref()).is_writable {
                    return Err(
                        anchor_lang::error::Error::from(
                                anchor_lang::error::ErrorCode::ConstraintMut,
                            )
                            .with_account_name("token_0_vault"),
                    );
                }
                if !(token_0_vault.key() == pool_state.token_0_vault) {
                    return Err(
                        anchor_lang::error::Error::from(
                                anchor_lang::error::ErrorCode::ConstraintRaw,
                            )
                            .with_account_name("token_0_vault"),
                    );
                }
                if !AsRef::<AccountInfo>::as_ref(token_1_vault.as_ref()).is_writable {
                    return Err(
                        anchor_lang::error::Error::from(
                                anchor_lang::error::ErrorCode::ConstraintMut,
                            )
                            .with_account_name("token_1_vault"),
                    );
                }
                if !(token_1_vault.key() == pool_state.token_1_vault) {
                    return Err(
                        anchor_lang::error::Error::from(
                                anchor_lang::error::ErrorCode::ConstraintRaw,
                            )
                            .with_account_name("token_1_vault"),
                    );
                }
                {
                    let actual = vault_0_mint.key();
                    let expected = token_0_vault.mint;
                    if actual != expected {
                        return Err(
                            anchor_lang::error::Error::from(
                                    anchor_lang::error::ErrorCode::ConstraintAddress,
                                )
                                .with_account_name("vault_0_mint")
                                .with_pubkeys((actual, expected)),
                        );
                    }
                }
                {
                    let __is_ctoken = pool_state.token_0_program
                        == anchor_lang::CTOKEN_ID;
                    if __is_ctoken {
                        if AsRef::<AccountInfo>::as_ref(vault_0_mint.as_ref()).owner
                            != &anchor_lang::solana_program::system_program::ID
                        {
                            return Err(
                                anchor_lang::error::ErrorCode::ConstraintMintTokenProgram
                                    .into(),
                            );
                        }
                    } else {
                        if AsRef::<AccountInfo>::as_ref(vault_0_mint.as_ref()).owner
                            != &pool_state.token_0_program
                        {
                            return Err(
                                anchor_lang::error::ErrorCode::ConstraintMintTokenProgram
                                    .into(),
                            );
                        }
                    }
                    if !__is_ctoken {}
                }
                {
                    let actual = vault_1_mint.key();
                    let expected = token_1_vault.mint;
                    if actual != expected {
                        return Err(
                            anchor_lang::error::Error::from(
                                    anchor_lang::error::ErrorCode::ConstraintAddress,
                                )
                                .with_account_name("vault_1_mint")
                                .with_pubkeys((actual, expected)),
                        );
                    }
                }
                {
                    let __is_ctoken = pool_state.token_1_program
                        == anchor_lang::CTOKEN_ID;
                    if __is_ctoken {
                        if AsRef::<AccountInfo>::as_ref(vault_1_mint.as_ref()).owner
                            != &anchor_lang::solana_program::system_program::ID
                        {
                            return Err(
                                anchor_lang::error::ErrorCode::ConstraintMintTokenProgram
                                    .into(),
                            );
                        }
                    } else {
                        if AsRef::<AccountInfo>::as_ref(vault_1_mint.as_ref()).owner
                            != &pool_state.token_1_program
                        {
                            return Err(
                                anchor_lang::error::ErrorCode::ConstraintMintTokenProgram
                                    .into(),
                            );
                        }
                    }
                    if !__is_ctoken {}
                }
                let (__pda_address, __bump) = Pubkey::find_program_address(
                    &[POOL_VAULT_SEED.as_bytes(), pool_state.lp_mint.as_ref()],
                    &__program_id,
                );
                __bumps.lp_vault = __bump;
                if lp_vault.key() != __pda_address {
                    return Err(
                        anchor_lang::error::Error::from(
                                anchor_lang::error::ErrorCode::ConstraintSeeds,
                            )
                            .with_account_name("lp_vault")
                            .with_pubkeys((lp_vault.key(), __pda_address)),
                    );
                }
                if !AsRef::<AccountInfo>::as_ref(lp_vault.as_ref()).is_writable {
                    return Err(
                        anchor_lang::error::Error::from(
                                anchor_lang::error::ErrorCode::ConstraintMut,
                            )
                            .with_account_name("lp_vault"),
                    );
                }
                {
                    if lp_vault.owner != authority.key() {
                        return Err(
                            anchor_lang::error::ErrorCode::ConstraintTokenOwner.into(),
                        );
                    }
                    if lp_vault.mint != lp_vault.mint.key() {
                        return Err(
                            anchor_lang::error::ErrorCode::ConstraintTokenMint.into(),
                        );
                    }
                }
                if !&compressed_token_0_pool_pda.is_writable {
                    return Err(
                        anchor_lang::error::Error::from(
                                anchor_lang::error::ErrorCode::ConstraintMut,
                            )
                            .with_account_name("compressed_token_0_pool_pda"),
                    );
                }
                if !&compressed_token_1_pool_pda.is_writable {
                    return Err(
                        anchor_lang::error::Error::from(
                                anchor_lang::error::ErrorCode::ConstraintMut,
                            )
                            .with_account_name("compressed_token_1_pool_pda"),
                    );
                }
                Ok(Deposit {
                    owner,
                    authority,
                    pool_state,
                    owner_lp_token,
                    token_0_account,
                    token_1_account,
                    token_0_vault,
                    token_1_vault,
                    token_program,
                    token_program_2022,
                    vault_0_mint,
                    vault_1_mint,
                    lp_vault,
                    compressed_token_program_cpi_authority,
                    compressed_token_program,
                    compressed_token_0_pool_pda,
                    compressed_token_1_pool_pda,
                })
            }
        }
        #[automatically_derived]
        impl<'info> anchor_lang::ToAccountInfos<'info> for Deposit<'info>
        where
            'info: 'info,
        {
            fn to_account_infos(
                &self,
            ) -> Vec<anchor_lang::solana_program::account_info::AccountInfo<'info>> {
                let mut account_infos = ::alloc::vec::Vec::new();
                account_infos.extend(self.owner.to_account_infos());
                account_infos.extend(self.authority.to_account_infos());
                account_infos.extend(self.pool_state.to_account_infos());
                account_infos.extend(self.owner_lp_token.to_account_infos());
                account_infos.extend(self.token_0_account.to_account_infos());
                account_infos.extend(self.token_1_account.to_account_infos());
                account_infos.extend(self.token_0_vault.to_account_infos());
                account_infos.extend(self.token_1_vault.to_account_infos());
                account_infos.extend(self.token_program.to_account_infos());
                account_infos.extend(self.token_program_2022.to_account_infos());
                account_infos.extend(self.vault_0_mint.to_account_infos());
                account_infos.extend(self.vault_1_mint.to_account_infos());
                account_infos.extend(self.lp_vault.to_account_infos());
                account_infos
                    .extend(
                        self.compressed_token_program_cpi_authority.to_account_infos(),
                    );
                account_infos.extend(self.compressed_token_program.to_account_infos());
                account_infos
                    .extend(self.compressed_token_0_pool_pda.to_account_infos());
                account_infos
                    .extend(self.compressed_token_1_pool_pda.to_account_infos());
                account_infos
            }
        }
        #[automatically_derived]
        impl<'info> anchor_lang::ToAccountMetas for Deposit<'info> {
            fn to_account_metas(
                &self,
                is_signer: Option<bool>,
            ) -> Vec<anchor_lang::solana_program::instruction::AccountMeta> {
                let mut account_metas = ::alloc::vec::Vec::new();
                account_metas.extend(self.owner.to_account_metas(None));
                account_metas.extend(self.authority.to_account_metas(None));
                account_metas.extend(self.pool_state.to_account_metas(None));
                account_metas.extend(self.owner_lp_token.to_account_metas(None));
                account_metas.extend(self.token_0_account.to_account_metas(None));
                account_metas.extend(self.token_1_account.to_account_metas(None));
                account_metas.extend(self.token_0_vault.to_account_metas(None));
                account_metas.extend(self.token_1_vault.to_account_metas(None));
                account_metas.extend(self.token_program.to_account_metas(None));
                account_metas.extend(self.token_program_2022.to_account_metas(None));
                account_metas.extend(self.vault_0_mint.to_account_metas(None));
                account_metas.extend(self.vault_1_mint.to_account_metas(None));
                account_metas.extend(self.lp_vault.to_account_metas(None));
                account_metas
                    .extend(
                        self
                            .compressed_token_program_cpi_authority
                            .to_account_metas(None),
                    );
                account_metas
                    .extend(self.compressed_token_program.to_account_metas(None));
                account_metas
                    .extend(self.compressed_token_0_pool_pda.to_account_metas(None));
                account_metas
                    .extend(self.compressed_token_1_pool_pda.to_account_metas(None));
                account_metas
            }
        }
        #[automatically_derived]
        impl<'info> anchor_lang::AccountsFinalize<'info, DepositBumps> for Deposit<'info>
        where
            'info: 'info,
        {
            fn finalize(
                &mut self,
                program_id: &anchor_lang::solana_program::pubkey::Pubkey,
                _remaining: &[anchor_lang::solana_program::account_info::AccountInfo<
                    'info,
                >],
                _ix_data: &[u8],
                _bumps: &DepositBumps,
            ) -> anchor_lang::Result<()> {
                anchor_lang::AccountsFinalize::finalize(
                        &mut self.pool_state,
                        program_id,
                        _remaining,
                        _ix_data,
                        _bumps,
                    )
                    .map_err(|e| e.with_account_name("pool_state"))?;
                anchor_lang::AccountsFinalize::finalize(
                        &mut self.owner_lp_token,
                        program_id,
                        _remaining,
                        _ix_data,
                        _bumps,
                    )
                    .map_err(|e| e.with_account_name("owner_lp_token"))?;
                anchor_lang::AccountsFinalize::finalize(
                        &mut self.token_0_account,
                        program_id,
                        _remaining,
                        _ix_data,
                        _bumps,
                    )
                    .map_err(|e| e.with_account_name("token_0_account"))?;
                anchor_lang::AccountsFinalize::finalize(
                        &mut self.token_1_account,
                        program_id,
                        _remaining,
                        _ix_data,
                        _bumps,
                    )
                    .map_err(|e| e.with_account_name("token_1_account"))?;
                anchor_lang::AccountsFinalize::finalize(
                        &mut self.token_0_vault,
                        program_id,
                        _remaining,
                        _ix_data,
                        _bumps,
                    )
                    .map_err(|e| e.with_account_name("token_0_vault"))?;
                anchor_lang::AccountsFinalize::finalize(
                        &mut self.token_1_vault,
                        program_id,
                        _remaining,
                        _ix_data,
                        _bumps,
                    )
                    .map_err(|e| e.with_account_name("token_1_vault"))?;
                anchor_lang::AccountsFinalize::finalize(
                        &mut self.token_program,
                        program_id,
                        _remaining,
                        _ix_data,
                        _bumps,
                    )
                    .map_err(|e| e.with_account_name("token_program"))?;
                anchor_lang::AccountsFinalize::finalize(
                        &mut self.token_program_2022,
                        program_id,
                        _remaining,
                        _ix_data,
                        _bumps,
                    )
                    .map_err(|e| e.with_account_name("token_program_2022"))?;
                anchor_lang::AccountsFinalize::finalize(
                        &mut self.vault_0_mint,
                        program_id,
                        _remaining,
                        _ix_data,
                        _bumps,
                    )
                    .map_err(|e| e.with_account_name("vault_0_mint"))?;
                anchor_lang::AccountsFinalize::finalize(
                        &mut self.vault_1_mint,
                        program_id,
                        _remaining,
                        _ix_data,
                        _bumps,
                    )
                    .map_err(|e| e.with_account_name("vault_1_mint"))?;
                anchor_lang::AccountsFinalize::finalize(
                        &mut self.lp_vault,
                        program_id,
                        _remaining,
                        _ix_data,
                        _bumps,
                    )
                    .map_err(|e| e.with_account_name("lp_vault"))?;
                Ok(())
            }
        }
        #[automatically_derived]
        impl<'info> anchor_lang::AccountsExit<'info> for Deposit<'info>
        where
            'info: 'info,
        {
            fn exit(
                &self,
                program_id: &anchor_lang::solana_program::pubkey::Pubkey,
            ) -> anchor_lang::Result<()> {
                anchor_lang::AccountsExit::exit(&self.pool_state, program_id)
                    .map_err(|e| e.with_account_name("pool_state"))?;
                anchor_lang::AccountsExit::exit(&self.owner_lp_token, program_id)
                    .map_err(|e| e.with_account_name("owner_lp_token"))?;
                anchor_lang::AccountsExit::exit(&self.token_0_account, program_id)
                    .map_err(|e| e.with_account_name("token_0_account"))?;
                anchor_lang::AccountsExit::exit(&self.token_1_account, program_id)
                    .map_err(|e| e.with_account_name("token_1_account"))?;
                anchor_lang::AccountsExit::exit(&self.token_0_vault, program_id)
                    .map_err(|e| e.with_account_name("token_0_vault"))?;
                anchor_lang::AccountsExit::exit(&self.token_1_vault, program_id)
                    .map_err(|e| e.with_account_name("token_1_vault"))?;
                anchor_lang::AccountsExit::exit(&self.lp_vault, program_id)
                    .map_err(|e| e.with_account_name("lp_vault"))?;
                anchor_lang::AccountsExit::exit(
                        &self.compressed_token_0_pool_pda,
                        program_id,
                    )
                    .map_err(|e| e.with_account_name("compressed_token_0_pool_pda"))?;
                anchor_lang::AccountsExit::exit(
                        &self.compressed_token_1_pool_pda,
                        program_id,
                    )
                    .map_err(|e| e.with_account_name("compressed_token_1_pool_pda"))?;
                Ok(())
            }
        }
        pub struct DepositBumps {
            pub authority: u8,
            pub lp_vault: u8,
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for DepositBumps {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field2_finish(
                    f,
                    "DepositBumps",
                    "authority",
                    &self.authority,
                    "lp_vault",
                    &&self.lp_vault,
                )
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for DepositBumps {
            #[inline]
            fn clone(&self) -> DepositBumps {
                DepositBumps {
                    authority: ::core::clone::Clone::clone(&self.authority),
                    lp_vault: ::core::clone::Clone::clone(&self.lp_vault),
                }
            }
        }
        impl Default for DepositBumps {
            fn default() -> Self {
                DepositBumps {
                    authority: u8::MAX,
                    lp_vault: u8::MAX,
                }
            }
        }
        impl<'info> anchor_lang::Bumps for Deposit<'info>
        where
            'info: 'info,
        {
            type Bumps = DepositBumps;
        }
        /// An internal, Anchor generated module. This is used (as an
        /// implementation detail), to generate a struct for a given
        /// `#[derive(Accounts)]` implementation, where each field is a Pubkey,
        /// instead of an `AccountInfo`. This is useful for clients that want
        /// to generate a list of accounts, without explicitly knowing the
        /// order all the fields should be in.
        ///
        /// To access the struct in this module, one should use the sibling
        /// `accounts` module (also generated), which re-exports this.
        pub(crate) mod __client_accounts_deposit {
            use super::*;
            use anchor_lang::prelude::borsh;
            /// Generated client accounts for [`Deposit`].
            pub struct Deposit {
                ///Pays to mint the position
                pub owner: Pubkey,
                pub authority: Pubkey,
                pub pool_state: Pubkey,
                ///Owner lp token account
                pub owner_lp_token: Pubkey,
                ///The payer's token account for token_0
                pub token_0_account: Pubkey,
                ///The payer's token account for token_1
                pub token_1_account: Pubkey,
                ///The address that holds pool tokens for token_0
                pub token_0_vault: Pubkey,
                ///The address that holds pool tokens for token_1
                pub token_1_vault: Pubkey,
                ///token Program
                pub token_program: Pubkey,
                ///Token program 2022
                pub token_program_2022: Pubkey,
                ///The mint of token_0 vault
                pub vault_0_mint: Pubkey,
                ///The mint of token_1 vault
                pub vault_1_mint: Pubkey,
                ///Lp token vault
                pub lp_vault: Pubkey,
                pub compressed_token_program_cpi_authority: Pubkey,
                pub compressed_token_program: Pubkey,
                ///
                ///Every mint must be registered in the compression protocol via a
                ///compression_token_pool_pda.
                pub compressed_token_0_pool_pda: Pubkey,
                pub compressed_token_1_pool_pda: Pubkey,
            }
            impl borsh::ser::BorshSerialize for Deposit
            where
                Pubkey: borsh::ser::BorshSerialize,
                Pubkey: borsh::ser::BorshSerialize,
                Pubkey: borsh::ser::BorshSerialize,
                Pubkey: borsh::ser::BorshSerialize,
                Pubkey: borsh::ser::BorshSerialize,
                Pubkey: borsh::ser::BorshSerialize,
                Pubkey: borsh::ser::BorshSerialize,
                Pubkey: borsh::ser::BorshSerialize,
                Pubkey: borsh::ser::BorshSerialize,
                Pubkey: borsh::ser::BorshSerialize,
                Pubkey: borsh::ser::BorshSerialize,
                Pubkey: borsh::ser::BorshSerialize,
                Pubkey: borsh::ser::BorshSerialize,
                Pubkey: borsh::ser::BorshSerialize,
                Pubkey: borsh::ser::BorshSerialize,
                Pubkey: borsh::ser::BorshSerialize,
                Pubkey: borsh::ser::BorshSerialize,
            {
                fn serialize<W: borsh::maybestd::io::Write>(
                    &self,
                    writer: &mut W,
                ) -> ::core::result::Result<(), borsh::maybestd::io::Error> {
                    borsh::BorshSerialize::serialize(&self.owner, writer)?;
                    borsh::BorshSerialize::serialize(&self.authority, writer)?;
                    borsh::BorshSerialize::serialize(&self.pool_state, writer)?;
                    borsh::BorshSerialize::serialize(&self.owner_lp_token, writer)?;
                    borsh::BorshSerialize::serialize(&self.token_0_account, writer)?;
                    borsh::BorshSerialize::serialize(&self.token_1_account, writer)?;
                    borsh::BorshSerialize::serialize(&self.token_0_vault, writer)?;
                    borsh::BorshSerialize::serialize(&self.token_1_vault, writer)?;
                    borsh::BorshSerialize::serialize(&self.token_program, writer)?;
                    borsh::BorshSerialize::serialize(&self.token_program_2022, writer)?;
                    borsh::BorshSerialize::serialize(&self.vault_0_mint, writer)?;
                    borsh::BorshSerialize::serialize(&self.vault_1_mint, writer)?;
                    borsh::BorshSerialize::serialize(&self.lp_vault, writer)?;
                    borsh::BorshSerialize::serialize(
                        &self.compressed_token_program_cpi_authority,
                        writer,
                    )?;
                    borsh::BorshSerialize::serialize(
                        &self.compressed_token_program,
                        writer,
                    )?;
                    borsh::BorshSerialize::serialize(
                        &self.compressed_token_0_pool_pda,
                        writer,
                    )?;
                    borsh::BorshSerialize::serialize(
                        &self.compressed_token_1_pool_pda,
                        writer,
                    )?;
                    Ok(())
                }
            }
            impl anchor_lang::idl::build::IdlBuild for Deposit {
                fn create_type() -> Option<anchor_lang::idl::types::IdlTypeDef> {
                    Some(anchor_lang::idl::types::IdlTypeDef {
                        name: Self::get_full_path(),
                        docs: <[_]>::into_vec(
                            ::alloc::boxed::box_new([
                                "Generated client accounts for [`Deposit`].".into(),
                            ]),
                        ),
                        serialization: anchor_lang::idl::types::IdlSerialization::default(),
                        repr: None,
                        generics: ::alloc::vec::Vec::new(),
                        ty: anchor_lang::idl::types::IdlTypeDefTy::Struct {
                            fields: Some(
                                anchor_lang::idl::types::IdlDefinedFields::Named(
                                    <[_]>::into_vec(
                                        ::alloc::boxed::box_new([
                                            anchor_lang::idl::types::IdlField {
                                                name: "owner".into(),
                                                docs: <[_]>::into_vec(
                                                    ::alloc::boxed::box_new([
                                                        "Pays to mint the position".into(),
                                                    ]),
                                                ),
                                                ty: anchor_lang::idl::types::IdlType::Pubkey,
                                            },
                                            anchor_lang::idl::types::IdlField {
                                                name: "authority".into(),
                                                docs: ::alloc::vec::Vec::new(),
                                                ty: anchor_lang::idl::types::IdlType::Pubkey,
                                            },
                                            anchor_lang::idl::types::IdlField {
                                                name: "pool_state".into(),
                                                docs: ::alloc::vec::Vec::new(),
                                                ty: anchor_lang::idl::types::IdlType::Pubkey,
                                            },
                                            anchor_lang::idl::types::IdlField {
                                                name: "owner_lp_token".into(),
                                                docs: <[_]>::into_vec(
                                                    ::alloc::boxed::box_new(["Owner lp token account".into()]),
                                                ),
                                                ty: anchor_lang::idl::types::IdlType::Pubkey,
                                            },
                                            anchor_lang::idl::types::IdlField {
                                                name: "token_0_account".into(),
                                                docs: <[_]>::into_vec(
                                                    ::alloc::boxed::box_new([
                                                        "The payer's token account for token_0".into(),
                                                    ]),
                                                ),
                                                ty: anchor_lang::idl::types::IdlType::Pubkey,
                                            },
                                            anchor_lang::idl::types::IdlField {
                                                name: "token_1_account".into(),
                                                docs: <[_]>::into_vec(
                                                    ::alloc::boxed::box_new([
                                                        "The payer's token account for token_1".into(),
                                                    ]),
                                                ),
                                                ty: anchor_lang::idl::types::IdlType::Pubkey,
                                            },
                                            anchor_lang::idl::types::IdlField {
                                                name: "token_0_vault".into(),
                                                docs: <[_]>::into_vec(
                                                    ::alloc::boxed::box_new([
                                                        "The address that holds pool tokens for token_0".into(),
                                                    ]),
                                                ),
                                                ty: anchor_lang::idl::types::IdlType::Pubkey,
                                            },
                                            anchor_lang::idl::types::IdlField {
                                                name: "token_1_vault".into(),
                                                docs: <[_]>::into_vec(
                                                    ::alloc::boxed::box_new([
                                                        "The address that holds pool tokens for token_1".into(),
                                                    ]),
                                                ),
                                                ty: anchor_lang::idl::types::IdlType::Pubkey,
                                            },
                                            anchor_lang::idl::types::IdlField {
                                                name: "token_program".into(),
                                                docs: <[_]>::into_vec(
                                                    ::alloc::boxed::box_new(["token Program".into()]),
                                                ),
                                                ty: anchor_lang::idl::types::IdlType::Pubkey,
                                            },
                                            anchor_lang::idl::types::IdlField {
                                                name: "token_program_2022".into(),
                                                docs: <[_]>::into_vec(
                                                    ::alloc::boxed::box_new(["Token program 2022".into()]),
                                                ),
                                                ty: anchor_lang::idl::types::IdlType::Pubkey,
                                            },
                                            anchor_lang::idl::types::IdlField {
                                                name: "vault_0_mint".into(),
                                                docs: <[_]>::into_vec(
                                                    ::alloc::boxed::box_new([
                                                        "The mint of token_0 vault".into(),
                                                    ]),
                                                ),
                                                ty: anchor_lang::idl::types::IdlType::Pubkey,
                                            },
                                            anchor_lang::idl::types::IdlField {
                                                name: "vault_1_mint".into(),
                                                docs: <[_]>::into_vec(
                                                    ::alloc::boxed::box_new([
                                                        "The mint of token_1 vault".into(),
                                                    ]),
                                                ),
                                                ty: anchor_lang::idl::types::IdlType::Pubkey,
                                            },
                                            anchor_lang::idl::types::IdlField {
                                                name: "lp_vault".into(),
                                                docs: <[_]>::into_vec(
                                                    ::alloc::boxed::box_new(["Lp token vault".into()]),
                                                ),
                                                ty: anchor_lang::idl::types::IdlType::Pubkey,
                                            },
                                            anchor_lang::idl::types::IdlField {
                                                name: "compressed_token_program_cpi_authority".into(),
                                                docs: ::alloc::vec::Vec::new(),
                                                ty: anchor_lang::idl::types::IdlType::Pubkey,
                                            },
                                            anchor_lang::idl::types::IdlField {
                                                name: "compressed_token_program".into(),
                                                docs: ::alloc::vec::Vec::new(),
                                                ty: anchor_lang::idl::types::IdlType::Pubkey,
                                            },
                                            anchor_lang::idl::types::IdlField {
                                                name: "compressed_token_0_pool_pda".into(),
                                                docs: <[_]>::into_vec(
                                                    ::alloc::boxed::box_new([
                                                        "".into(),
                                                        "Every mint must be registered in the compression protocol via a"
                                                            .into(),
                                                        "compression_token_pool_pda.".into(),
                                                    ]),
                                                ),
                                                ty: anchor_lang::idl::types::IdlType::Pubkey,
                                            },
                                            anchor_lang::idl::types::IdlField {
                                                name: "compressed_token_1_pool_pda".into(),
                                                docs: ::alloc::vec::Vec::new(),
                                                ty: anchor_lang::idl::types::IdlType::Pubkey,
                                            },
                                        ]),
                                    ),
                                ),
                            ),
                        },
                    })
                }
                fn insert_types(
                    types: &mut std::collections::BTreeMap<
                        String,
                        anchor_lang::idl::types::IdlTypeDef,
                    >,
                ) {}
                fn get_full_path() -> String {
                    ::alloc::__export::must_use({
                        ::alloc::fmt::format(
                            format_args!(
                                "{0}::{1}",
                                "raydium_cp_swap::instructions::deposit::__client_accounts_deposit",
                                "Deposit",
                            ),
                        )
                    })
                }
            }
            #[automatically_derived]
            impl anchor_lang::ToAccountMetas for Deposit {
                fn to_account_metas(
                    &self,
                    is_signer: Option<bool>,
                ) -> Vec<anchor_lang::solana_program::instruction::AccountMeta> {
                    let mut account_metas = ::alloc::vec::Vec::new();
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                                self.owner,
                                true,
                            ),
                        );
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                                self.authority,
                                false,
                            ),
                        );
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new(
                                self.pool_state,
                                false,
                            ),
                        );
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new(
                                self.owner_lp_token,
                                false,
                            ),
                        );
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new(
                                self.token_0_account,
                                false,
                            ),
                        );
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new(
                                self.token_1_account,
                                false,
                            ),
                        );
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new(
                                self.token_0_vault,
                                false,
                            ),
                        );
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new(
                                self.token_1_vault,
                                false,
                            ),
                        );
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                                self.token_program,
                                false,
                            ),
                        );
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                                self.token_program_2022,
                                false,
                            ),
                        );
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                                self.vault_0_mint,
                                false,
                            ),
                        );
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                                self.vault_1_mint,
                                false,
                            ),
                        );
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new(
                                self.lp_vault,
                                false,
                            ),
                        );
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                                self.compressed_token_program_cpi_authority,
                                false,
                            ),
                        );
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                                self.compressed_token_program,
                                false,
                            ),
                        );
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new(
                                self.compressed_token_0_pool_pda,
                                false,
                            ),
                        );
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new(
                                self.compressed_token_1_pool_pda,
                                false,
                            ),
                        );
                    account_metas
                }
            }
        }
        /// An internal, Anchor generated module. This is used (as an
        /// implementation detail), to generate a CPI struct for a given
        /// `#[derive(Accounts)]` implementation, where each field is an
        /// AccountInfo.
        ///
        /// To access the struct in this module, one should use the sibling
        /// [`cpi::accounts`] module (also generated), which re-exports this.
        pub(crate) mod __cpi_client_accounts_deposit {
            use super::*;
            /// Generated CPI struct of the accounts for [`Deposit`].
            pub struct Deposit<'info> {
                ///Pays to mint the position
                pub owner: anchor_lang::solana_program::account_info::AccountInfo<'info>,
                pub authority: anchor_lang::solana_program::account_info::AccountInfo<
                    'info,
                >,
                pub pool_state: anchor_lang::solana_program::account_info::AccountInfo<
                    'info,
                >,
                ///Owner lp token account
                pub owner_lp_token: anchor_lang::solana_program::account_info::AccountInfo<
                    'info,
                >,
                ///The payer's token account for token_0
                pub token_0_account: anchor_lang::solana_program::account_info::AccountInfo<
                    'info,
                >,
                ///The payer's token account for token_1
                pub token_1_account: anchor_lang::solana_program::account_info::AccountInfo<
                    'info,
                >,
                ///The address that holds pool tokens for token_0
                pub token_0_vault: anchor_lang::solana_program::account_info::AccountInfo<
                    'info,
                >,
                ///The address that holds pool tokens for token_1
                pub token_1_vault: anchor_lang::solana_program::account_info::AccountInfo<
                    'info,
                >,
                ///token Program
                pub token_program: anchor_lang::solana_program::account_info::AccountInfo<
                    'info,
                >,
                ///Token program 2022
                pub token_program_2022: anchor_lang::solana_program::account_info::AccountInfo<
                    'info,
                >,
                ///The mint of token_0 vault
                pub vault_0_mint: anchor_lang::solana_program::account_info::AccountInfo<
                    'info,
                >,
                ///The mint of token_1 vault
                pub vault_1_mint: anchor_lang::solana_program::account_info::AccountInfo<
                    'info,
                >,
                ///Lp token vault
                pub lp_vault: anchor_lang::solana_program::account_info::AccountInfo<
                    'info,
                >,
                pub compressed_token_program_cpi_authority: anchor_lang::solana_program::account_info::AccountInfo<
                    'info,
                >,
                pub compressed_token_program: anchor_lang::solana_program::account_info::AccountInfo<
                    'info,
                >,
                ///
                ///Every mint must be registered in the compression protocol via a
                ///compression_token_pool_pda.
                pub compressed_token_0_pool_pda: anchor_lang::solana_program::account_info::AccountInfo<
                    'info,
                >,
                pub compressed_token_1_pool_pda: anchor_lang::solana_program::account_info::AccountInfo<
                    'info,
                >,
            }
            #[automatically_derived]
            impl<'info> anchor_lang::ToAccountMetas for Deposit<'info> {
                fn to_account_metas(
                    &self,
                    is_signer: Option<bool>,
                ) -> Vec<anchor_lang::solana_program::instruction::AccountMeta> {
                    let mut account_metas = ::alloc::vec::Vec::new();
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                                anchor_lang::Key::key(&self.owner),
                                true,
                            ),
                        );
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                                anchor_lang::Key::key(&self.authority),
                                false,
                            ),
                        );
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new(
                                anchor_lang::Key::key(&self.pool_state),
                                false,
                            ),
                        );
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new(
                                anchor_lang::Key::key(&self.owner_lp_token),
                                false,
                            ),
                        );
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new(
                                anchor_lang::Key::key(&self.token_0_account),
                                false,
                            ),
                        );
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new(
                                anchor_lang::Key::key(&self.token_1_account),
                                false,
                            ),
                        );
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new(
                                anchor_lang::Key::key(&self.token_0_vault),
                                false,
                            ),
                        );
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new(
                                anchor_lang::Key::key(&self.token_1_vault),
                                false,
                            ),
                        );
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                                anchor_lang::Key::key(&self.token_program),
                                false,
                            ),
                        );
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                                anchor_lang::Key::key(&self.token_program_2022),
                                false,
                            ),
                        );
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                                anchor_lang::Key::key(&self.vault_0_mint),
                                false,
                            ),
                        );
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                                anchor_lang::Key::key(&self.vault_1_mint),
                                false,
                            ),
                        );
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new(
                                anchor_lang::Key::key(&self.lp_vault),
                                false,
                            ),
                        );
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                                anchor_lang::Key::key(
                                    &self.compressed_token_program_cpi_authority,
                                ),
                                false,
                            ),
                        );
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                                anchor_lang::Key::key(&self.compressed_token_program),
                                false,
                            ),
                        );
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new(
                                anchor_lang::Key::key(&self.compressed_token_0_pool_pda),
                                false,
                            ),
                        );
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new(
                                anchor_lang::Key::key(&self.compressed_token_1_pool_pda),
                                false,
                            ),
                        );
                    account_metas
                }
            }
            #[automatically_derived]
            impl<'info> anchor_lang::ToAccountInfos<'info> for Deposit<'info> {
                fn to_account_infos(
                    &self,
                ) -> Vec<anchor_lang::solana_program::account_info::AccountInfo<'info>> {
                    let mut account_infos = ::alloc::vec::Vec::new();
                    account_infos
                        .extend(
                            anchor_lang::ToAccountInfos::to_account_infos(&self.owner),
                        );
                    account_infos
                        .extend(
                            anchor_lang::ToAccountInfos::to_account_infos(
                                &self.authority,
                            ),
                        );
                    account_infos
                        .extend(
                            anchor_lang::ToAccountInfos::to_account_infos(
                                &self.pool_state,
                            ),
                        );
                    account_infos
                        .extend(
                            anchor_lang::ToAccountInfos::to_account_infos(
                                &self.owner_lp_token,
                            ),
                        );
                    account_infos
                        .extend(
                            anchor_lang::ToAccountInfos::to_account_infos(
                                &self.token_0_account,
                            ),
                        );
                    account_infos
                        .extend(
                            anchor_lang::ToAccountInfos::to_account_infos(
                                &self.token_1_account,
                            ),
                        );
                    account_infos
                        .extend(
                            anchor_lang::ToAccountInfos::to_account_infos(
                                &self.token_0_vault,
                            ),
                        );
                    account_infos
                        .extend(
                            anchor_lang::ToAccountInfos::to_account_infos(
                                &self.token_1_vault,
                            ),
                        );
                    account_infos
                        .extend(
                            anchor_lang::ToAccountInfos::to_account_infos(
                                &self.token_program,
                            ),
                        );
                    account_infos
                        .extend(
                            anchor_lang::ToAccountInfos::to_account_infos(
                                &self.token_program_2022,
                            ),
                        );
                    account_infos
                        .extend(
                            anchor_lang::ToAccountInfos::to_account_infos(
                                &self.vault_0_mint,
                            ),
                        );
                    account_infos
                        .extend(
                            anchor_lang::ToAccountInfos::to_account_infos(
                                &self.vault_1_mint,
                            ),
                        );
                    account_infos
                        .extend(
                            anchor_lang::ToAccountInfos::to_account_infos(&self.lp_vault),
                        );
                    account_infos
                        .extend(
                            anchor_lang::ToAccountInfos::to_account_infos(
                                &self.compressed_token_program_cpi_authority,
                            ),
                        );
                    account_infos
                        .extend(
                            anchor_lang::ToAccountInfos::to_account_infos(
                                &self.compressed_token_program,
                            ),
                        );
                    account_infos
                        .extend(
                            anchor_lang::ToAccountInfos::to_account_infos(
                                &self.compressed_token_0_pool_pda,
                            ),
                        );
                    account_infos
                        .extend(
                            anchor_lang::ToAccountInfos::to_account_infos(
                                &self.compressed_token_1_pool_pda,
                            ),
                        );
                    account_infos
                }
            }
        }
        impl<'info> Deposit<'info> {
            pub fn __anchor_private_gen_idl_accounts(
                accounts: &mut std::collections::BTreeMap<
                    String,
                    anchor_lang::idl::types::IdlAccount,
                >,
                types: &mut std::collections::BTreeMap<
                    String,
                    anchor_lang::idl::types::IdlTypeDef,
                >,
            ) -> Vec<anchor_lang::idl::types::IdlInstructionAccountItem> {
                if let Some(ty) = <PoolState>::create_type() {
                    let account = anchor_lang::idl::types::IdlAccount {
                        name: ty.name.clone(),
                        discriminator: PoolState::DISCRIMINATOR.into(),
                    };
                    accounts.insert(account.name.clone(), account);
                    types.insert(ty.name.clone(), ty);
                    <PoolState>::insert_types(types);
                }
                if let Some(ty) = <TokenAccount>::create_type() {
                    let account = anchor_lang::idl::types::IdlAccount {
                        name: ty.name.clone(),
                        discriminator: TokenAccount::DISCRIMINATOR.into(),
                    };
                    accounts.insert(account.name.clone(), account);
                    types.insert(ty.name.clone(), ty);
                    <TokenAccount>::insert_types(types);
                }
                if let Some(ty) = <TokenAccount>::create_type() {
                    let account = anchor_lang::idl::types::IdlAccount {
                        name: ty.name.clone(),
                        discriminator: TokenAccount::DISCRIMINATOR.into(),
                    };
                    accounts.insert(account.name.clone(), account);
                    types.insert(ty.name.clone(), ty);
                    <TokenAccount>::insert_types(types);
                }
                if let Some(ty) = <TokenAccount>::create_type() {
                    let account = anchor_lang::idl::types::IdlAccount {
                        name: ty.name.clone(),
                        discriminator: TokenAccount::DISCRIMINATOR.into(),
                    };
                    accounts.insert(account.name.clone(), account);
                    types.insert(ty.name.clone(), ty);
                    <TokenAccount>::insert_types(types);
                }
                if let Some(ty) = <TokenAccount>::create_type() {
                    let account = anchor_lang::idl::types::IdlAccount {
                        name: ty.name.clone(),
                        discriminator: TokenAccount::DISCRIMINATOR.into(),
                    };
                    accounts.insert(account.name.clone(), account);
                    types.insert(ty.name.clone(), ty);
                    <TokenAccount>::insert_types(types);
                }
                if let Some(ty) = <TokenAccount>::create_type() {
                    let account = anchor_lang::idl::types::IdlAccount {
                        name: ty.name.clone(),
                        discriminator: TokenAccount::DISCRIMINATOR.into(),
                    };
                    accounts.insert(account.name.clone(), account);
                    types.insert(ty.name.clone(), ty);
                    <TokenAccount>::insert_types(types);
                }
                if let Some(ty) = <Mint>::create_type() {
                    let account = anchor_lang::idl::types::IdlAccount {
                        name: ty.name.clone(),
                        discriminator: Mint::DISCRIMINATOR.into(),
                    };
                    accounts.insert(account.name.clone(), account);
                    types.insert(ty.name.clone(), ty);
                    <Mint>::insert_types(types);
                }
                if let Some(ty) = <Mint>::create_type() {
                    let account = anchor_lang::idl::types::IdlAccount {
                        name: ty.name.clone(),
                        discriminator: Mint::DISCRIMINATOR.into(),
                    };
                    accounts.insert(account.name.clone(), account);
                    types.insert(ty.name.clone(), ty);
                    <Mint>::insert_types(types);
                }
                if let Some(ty) = <TokenAccount>::create_type() {
                    let account = anchor_lang::idl::types::IdlAccount {
                        name: ty.name.clone(),
                        discriminator: TokenAccount::DISCRIMINATOR.into(),
                    };
                    accounts.insert(account.name.clone(), account);
                    types.insert(ty.name.clone(), ty);
                    <TokenAccount>::insert_types(types);
                }
                <[_]>::into_vec(
                    ::alloc::boxed::box_new([
                        anchor_lang::idl::types::IdlInstructionAccountItem::Single(anchor_lang::idl::types::IdlInstructionAccount {
                            name: "owner".into(),
                            docs: <[_]>::into_vec(
                                ::alloc::boxed::box_new([
                                    "Pays to mint the position".into(),
                                ]),
                            ),
                            writable: false,
                            signer: true,
                            optional: false,
                            address: None,
                            pda: None,
                            relations: ::alloc::vec::Vec::new(),
                        }),
                        anchor_lang::idl::types::IdlInstructionAccountItem::Single(anchor_lang::idl::types::IdlInstructionAccount {
                            name: "authority".into(),
                            docs: ::alloc::vec::Vec::new(),
                            writable: false,
                            signer: false,
                            optional: false,
                            address: None,
                            pda: None,
                            relations: ::alloc::vec::Vec::new(),
                        }),
                        anchor_lang::idl::types::IdlInstructionAccountItem::Single(anchor_lang::idl::types::IdlInstructionAccount {
                            name: "pool_state".into(),
                            docs: ::alloc::vec::Vec::new(),
                            writable: true,
                            signer: false,
                            optional: false,
                            address: None,
                            pda: None,
                            relations: ::alloc::vec::Vec::new(),
                        }),
                        anchor_lang::idl::types::IdlInstructionAccountItem::Single(anchor_lang::idl::types::IdlInstructionAccount {
                            name: "owner_lp_token".into(),
                            docs: <[_]>::into_vec(
                                ::alloc::boxed::box_new(["Owner lp token account".into()]),
                            ),
                            writable: true,
                            signer: false,
                            optional: false,
                            address: None,
                            pda: None,
                            relations: ::alloc::vec::Vec::new(),
                        }),
                        anchor_lang::idl::types::IdlInstructionAccountItem::Single(anchor_lang::idl::types::IdlInstructionAccount {
                            name: "token_0_account".into(),
                            docs: <[_]>::into_vec(
                                ::alloc::boxed::box_new([
                                    "The payer's token account for token_0".into(),
                                ]),
                            ),
                            writable: true,
                            signer: false,
                            optional: false,
                            address: None,
                            pda: None,
                            relations: ::alloc::vec::Vec::new(),
                        }),
                        anchor_lang::idl::types::IdlInstructionAccountItem::Single(anchor_lang::idl::types::IdlInstructionAccount {
                            name: "token_1_account".into(),
                            docs: <[_]>::into_vec(
                                ::alloc::boxed::box_new([
                                    "The payer's token account for token_1".into(),
                                ]),
                            ),
                            writable: true,
                            signer: false,
                            optional: false,
                            address: None,
                            pda: None,
                            relations: ::alloc::vec::Vec::new(),
                        }),
                        anchor_lang::idl::types::IdlInstructionAccountItem::Single(anchor_lang::idl::types::IdlInstructionAccount {
                            name: "token_0_vault".into(),
                            docs: <[_]>::into_vec(
                                ::alloc::boxed::box_new([
                                    "The address that holds pool tokens for token_0".into(),
                                ]),
                            ),
                            writable: true,
                            signer: false,
                            optional: false,
                            address: None,
                            pda: None,
                            relations: ::alloc::vec::Vec::new(),
                        }),
                        anchor_lang::idl::types::IdlInstructionAccountItem::Single(anchor_lang::idl::types::IdlInstructionAccount {
                            name: "token_1_vault".into(),
                            docs: <[_]>::into_vec(
                                ::alloc::boxed::box_new([
                                    "The address that holds pool tokens for token_1".into(),
                                ]),
                            ),
                            writable: true,
                            signer: false,
                            optional: false,
                            address: None,
                            pda: None,
                            relations: ::alloc::vec::Vec::new(),
                        }),
                        anchor_lang::idl::types::IdlInstructionAccountItem::Single(anchor_lang::idl::types::IdlInstructionAccount {
                            name: "token_program".into(),
                            docs: <[_]>::into_vec(
                                ::alloc::boxed::box_new(["token Program".into()]),
                            ),
                            writable: false,
                            signer: false,
                            optional: false,
                            address: None,
                            pda: None,
                            relations: ::alloc::vec::Vec::new(),
                        }),
                        anchor_lang::idl::types::IdlInstructionAccountItem::Single(anchor_lang::idl::types::IdlInstructionAccount {
                            name: "token_program_2022".into(),
                            docs: <[_]>::into_vec(
                                ::alloc::boxed::box_new(["Token program 2022".into()]),
                            ),
                            writable: false,
                            signer: false,
                            optional: false,
                            address: None,
                            pda: None,
                            relations: ::alloc::vec::Vec::new(),
                        }),
                        anchor_lang::idl::types::IdlInstructionAccountItem::Single(anchor_lang::idl::types::IdlInstructionAccount {
                            name: "vault_0_mint".into(),
                            docs: <[_]>::into_vec(
                                ::alloc::boxed::box_new([
                                    "The mint of token_0 vault".into(),
                                ]),
                            ),
                            writable: false,
                            signer: false,
                            optional: false,
                            address: None,
                            pda: None,
                            relations: ::alloc::vec::Vec::new(),
                        }),
                        anchor_lang::idl::types::IdlInstructionAccountItem::Single(anchor_lang::idl::types::IdlInstructionAccount {
                            name: "vault_1_mint".into(),
                            docs: <[_]>::into_vec(
                                ::alloc::boxed::box_new([
                                    "The mint of token_1 vault".into(),
                                ]),
                            ),
                            writable: false,
                            signer: false,
                            optional: false,
                            address: None,
                            pda: None,
                            relations: ::alloc::vec::Vec::new(),
                        }),
                        anchor_lang::idl::types::IdlInstructionAccountItem::Single(anchor_lang::idl::types::IdlInstructionAccount {
                            name: "lp_vault".into(),
                            docs: <[_]>::into_vec(
                                ::alloc::boxed::box_new(["Lp token vault".into()]),
                            ),
                            writable: true,
                            signer: false,
                            optional: false,
                            address: None,
                            pda: None,
                            relations: ::alloc::vec::Vec::new(),
                        }),
                        anchor_lang::idl::types::IdlInstructionAccountItem::Single(anchor_lang::idl::types::IdlInstructionAccount {
                            name: "compressed_token_program_cpi_authority".into(),
                            docs: ::alloc::vec::Vec::new(),
                            writable: false,
                            signer: false,
                            optional: false,
                            address: None,
                            pda: None,
                            relations: ::alloc::vec::Vec::new(),
                        }),
                        anchor_lang::idl::types::IdlInstructionAccountItem::Single(anchor_lang::idl::types::IdlInstructionAccount {
                            name: "compressed_token_program".into(),
                            docs: ::alloc::vec::Vec::new(),
                            writable: false,
                            signer: false,
                            optional: false,
                            address: None,
                            pda: None,
                            relations: ::alloc::vec::Vec::new(),
                        }),
                        anchor_lang::idl::types::IdlInstructionAccountItem::Single(anchor_lang::idl::types::IdlInstructionAccount {
                            name: "compressed_token_0_pool_pda".into(),
                            docs: <[_]>::into_vec(
                                ::alloc::boxed::box_new([
                                    "".into(),
                                    "Every mint must be registered in the compression protocol via a"
                                        .into(),
                                    "compression_token_pool_pda.".into(),
                                ]),
                            ),
                            writable: true,
                            signer: false,
                            optional: false,
                            address: None,
                            pda: None,
                            relations: ::alloc::vec::Vec::new(),
                        }),
                        anchor_lang::idl::types::IdlInstructionAccountItem::Single(anchor_lang::idl::types::IdlInstructionAccount {
                            name: "compressed_token_1_pool_pda".into(),
                            docs: ::alloc::vec::Vec::new(),
                            writable: true,
                            signer: false,
                            optional: false,
                            address: None,
                            pda: None,
                            relations: ::alloc::vec::Vec::new(),
                        }),
                    ]),
                )
            }
            pub fn __anchor_private_gen_light_metadata() -> Option<
                anchor_lang::idl::types::IdlLightInstructionMeta,
            > {
                Some(anchor_lang::idl::types::IdlLightInstructionMeta {
                    ctokens: None,
                    cpdas: Some(
                        <[_]>::into_vec(
                            ::alloc::boxed::box_new([
                                anchor_lang::idl::types::IdlLightCpdaUsage {
                                    account: "pool_state".to_string(),
                                    ty: "PoolState".to_string(),
                                },
                            ]),
                        ),
                    ),
                })
            }
        }
        pub fn deposit(
            ctx: Context<Deposit>,
            lp_token_amount: u64,
            maximum_token_0_amount: u64,
            maximum_token_1_amount: u64,
        ) -> Result<()> {
            if lp_token_amount <= 0 {
                return Err(
                    anchor_lang::error::Error::from(anchor_lang::error::AnchorError {
                            error_name: anchor_lang::error::ErrorCode::RequireGtViolated
                                .name(),
                            error_code_number: anchor_lang::error::ErrorCode::RequireGtViolated
                                .into(),
                            error_msg: anchor_lang::error::ErrorCode::RequireGtViolated
                                .to_string(),
                            error_origin: Some(
                                anchor_lang::error::ErrorOrigin::Source(anchor_lang::error::Source {
                                    filename: "programs/cp-swap/src/instructions/deposit.rs",
                                    line: 119u32,
                                }),
                            ),
                            compared_values: None,
                        })
                        .with_values((lp_token_amount, 0)),
                );
            }
            let pool_id = ctx.accounts.pool_state.key();
            let pool_state = &mut ctx.accounts.pool_state;
            if !pool_state.get_status_by_bit(PoolStatusBitIndex::Deposit) {
                return Err(
                    anchor_lang::error::Error::from(anchor_lang::error::AnchorError {
                        error_name: ErrorCode::NotApproved.name(),
                        error_code_number: ErrorCode::NotApproved.into(),
                        error_msg: ErrorCode::NotApproved.to_string(),
                        error_origin: Some(
                            anchor_lang::error::ErrorOrigin::Source(anchor_lang::error::Source {
                                filename: "programs/cp-swap/src/instructions/deposit.rs",
                                line: 123u32,
                            }),
                        ),
                        compared_values: None,
                    }),
                );
            }
            let (total_token_0_amount, total_token_1_amount) = pool_state
                .vault_amount_without_fee(
                    ctx.accounts.token_0_vault.amount,
                    ctx.accounts.token_1_vault.amount,
                );
            let results = CurveCalculator::lp_tokens_to_trading_tokens(
                    u128::from(lp_token_amount),
                    u128::from(pool_state.lp_supply),
                    u128::from(total_token_0_amount),
                    u128::from(total_token_1_amount),
                    RoundDirection::Ceiling,
                )
                .ok_or(ErrorCode::ZeroTradingTokens)?;
            if results.token_0_amount == 0 || results.token_1_amount == 0 {
                return Err(
                    anchor_lang::error::Error::from(anchor_lang::error::AnchorError {
                        error_name: ErrorCode::ZeroTradingTokens.name(),
                        error_code_number: ErrorCode::ZeroTradingTokens.into(),
                        error_msg: ErrorCode::ZeroTradingTokens.to_string(),
                        error_origin: Some(
                            anchor_lang::error::ErrorOrigin::Source(anchor_lang::error::Source {
                                filename: "programs/cp-swap/src/instructions/deposit.rs",
                                line: 138u32,
                            }),
                        ),
                        compared_values: None,
                    }),
                );
            }
            let token_0_amount = u64::try_from(results.token_0_amount).unwrap();
            let (transfer_token_0_amount, transfer_token_0_fee) = {
                let transfer_fee = get_transfer_inverse_fee(
                    &ctx.accounts.vault_0_mint.to_account_info(),
                    token_0_amount,
                )?;
                (token_0_amount.checked_add(transfer_fee).unwrap(), transfer_fee)
            };
            let token_1_amount = u64::try_from(results.token_1_amount).unwrap();
            let (transfer_token_1_amount, transfer_token_1_fee) = {
                let transfer_fee = get_transfer_inverse_fee(
                    &ctx.accounts.vault_1_mint.to_account_info(),
                    token_1_amount,
                )?;
                (token_1_amount.checked_add(transfer_fee).unwrap(), transfer_fee)
            };
            {
                anchor_lang::solana_program::log::sol_log_data(
                    &[
                        &anchor_lang::Event::data(
                            &LpChangeEvent {
                                pool_id,
                                lp_amount_before: pool_state.lp_supply,
                                token_0_vault_before: total_token_0_amount,
                                token_1_vault_before: total_token_1_amount,
                                token_0_amount,
                                token_1_amount,
                                token_0_transfer_fee: transfer_token_0_fee,
                                token_1_transfer_fee: transfer_token_1_fee,
                                change_type: 0,
                            },
                        ),
                    ],
                );
            };
            if transfer_token_0_amount > maximum_token_0_amount
                || transfer_token_1_amount > maximum_token_1_amount
            {
                return Err(ErrorCode::ExceededSlippage.into());
            }
            let (compressed_token_0_pool_bump, compressed_token_1_pool_bump) = get_bumps(
                ctx.accounts.vault_0_mint.key(),
                ctx.accounts.vault_1_mint.key(),
                ctx.accounts.compressed_token_program.key(),
            );
            transfer_from_user_to_pool_vault(
                ctx.accounts.owner.to_account_info(),
                ctx.accounts.token_0_account.to_account_info(),
                ctx.accounts.token_0_vault.to_account_info(),
                Some(ctx.accounts.vault_0_mint.to_account_info()),
                Some(
                    if ctx.accounts.vault_0_mint.to_account_info().owner
                        == ctx.accounts.token_program.key
                    {
                        ctx.accounts.token_program.to_account_info()
                    } else {
                        ctx.accounts.token_program_2022.to_account_info()
                    },
                ),
                Some(ctx.accounts.compressed_token_0_pool_pda.to_account_info()),
                Some(compressed_token_0_pool_bump),
                ctx.accounts.compressed_token_program_cpi_authority.to_account_info(),
                transfer_token_0_amount,
            )?;
            transfer_from_user_to_pool_vault(
                ctx.accounts.owner.to_account_info(),
                ctx.accounts.token_1_account.to_account_info(),
                ctx.accounts.token_1_vault.to_account_info(),
                Some(ctx.accounts.vault_1_mint.to_account_info()),
                Some(
                    if ctx.accounts.vault_1_mint.to_account_info().owner
                        == ctx.accounts.token_program.key
                    {
                        ctx.accounts.token_program.to_account_info()
                    } else {
                        ctx.accounts.token_program_2022.to_account_info()
                    },
                ),
                Some(ctx.accounts.compressed_token_1_pool_pda.to_account_info()),
                Some(compressed_token_1_pool_bump),
                ctx.accounts.compressed_token_program_cpi_authority.to_account_info(),
                transfer_token_1_amount,
            )?;
            pool_state.lp_supply = pool_state
                .lp_supply
                .checked_add(lp_token_amount)
                .unwrap();
            transfer_ctoken_from_pool_vault_to_user(
                ctx.accounts.authority.to_account_info(),
                ctx.accounts.lp_vault.to_account_info(),
                ctx.accounts.owner_lp_token.to_account_info(),
                lp_token_amount,
                &[&[crate::AUTH_SEED.as_bytes(), &[pool_state.auth_bump]]],
            )?;
            pool_state.recent_epoch = Clock::get()?.epoch;
            pool_state.compression_info_mut().bump_last_written_slot()?;
            Ok(())
        }
    }
    pub mod initialize {
        use crate::curve::CurveCalculator;
        use crate::error::ErrorCode;
        use crate::states::*;
        use crate::utils::*;
        use anchor_lang::{
            accounts::interface_account::InterfaceAccount, prelude::*,
            solana_program::{clock, program::invoke, system_instruction},
        };
        use anchor_spl::{
            associated_token::AssociatedToken, token::spl_token, token::Token,
            token_interface::{Mint, TokenAccount, TokenInterface},
        };
        use light_compressed_token_sdk::instructions::create_associated_ctoken_account;
        use light_compressed_token_sdk::instructions::create_token_account::create_ctoken_account_signed;
        use light_sdk::{
            compressible::CompressibleConfig,
            instruction::{borsh_compat::ValidityProof, PackedAddressTreeInfo},
        };
        use spl_token_2022;
        use std::ops::Deref;
        #[instruction(
            init_amount_0:u64,
            init_amount_1:u64,
            open_time:u64,
            compression_params:InitializeCompressionParams
        )]
        pub struct Initialize<'info> {
            /// Address paying to create the pool. Can be anyone
            #[account(mut)]
            pub creator: Signer<'info>,
            /// Which config the pool belongs to.
            pub amm_config: Box<Account<'info, AmmConfig>>,
            /// CHECK:
            /// pool vault and lp mint authority
            #[account(seeds = [crate::AUTH_SEED.as_bytes()], bump)]
            pub authority: UncheckedAccount<'info>,
            /// CHECK: Initialize an account to store the pool state
            #[account(
                init,
                cpda::authority = authority,
                cpda::address_tree_info = compression_params.pool_address_tree_info,
                seeds = [POOL_SEED.as_bytes(),
                amm_config.to_account_info().key.as_ref(),
                token_0_mint.to_account_info().key.as_ref(),
                token_1_mint.to_account_info().key.as_ref(),
                ],
                bump,
                payer = creator,
                space = 8+PoolState::INIT_SPACE
            )]
            pub pool_state: Box<Account<'info, PoolState>>,
            /// Token_0 mint, the key must smaller than token_1 mint.
            #[account(
                constraint = token_0_mint.key()<token_1_mint.key(),
                mint::token_program = token_0_program,
            )]
            pub token_0_mint: Box<InterfaceAccount<'info, Mint>>,
            /// Token_1 mint, the key must grater then token_0 mint.
            #[account(mint::token_program = token_1_program)]
            pub token_1_mint: Box<InterfaceAccount<'info, Mint>>,
            /// Signer pda used to derive lp_mint and its compressed address.
            /// CHECK: checked by protocol.
            #[account(
                seeds = [POOL_LP_MINT_SEED.as_bytes(),
                pool_state.to_account_info().key.as_ref(),
                ],
                bump,
            )]
            pub lp_mint_signer: UncheckedAccount<'info>,
            /// Compressed mint for LP tokens
            /// CHECK: checked in instruction.
            #[account(
                mint::authority = authority,
                mint::decimals = 9,
                mint::payer = creator,
                mint::mint_signer = lp_mint_signer,
                mint::address_tree_info = compression_params.lp_mint_address_tree_info,
                metadata::name = compression_params.name,
                metadata::symbol = compression_params.symbol,
                metadata::uri = compression_params.uri,
            )]
            pub lp_mint: CMint<'info>,
            /// payer token0 account
            #[account(mut, token::mint = token_0_mint, token::authority = creator)]
            pub creator_token_0: Box<InterfaceAccount<'info, TokenAccount>>,
            /// creator token1 account
            #[account(mut, token::mint = token_1_mint, token::authority = creator)]
            pub creator_token_1: Box<InterfaceAccount<'info, TokenAccount>>,
            /// CHECK:
            #[account(mut)]
            pub creator_lp_token: UncheckedAccount<'info>,
            /// CHECK:
            #[account(
                mut,
                cctoken,
                seeds = [POOL_VAULT_SEED.as_bytes(),
                lp_mint.to_account_info().key.as_ref()],
                authority = crate::AUTH_SEED,
                bump,
            )]
            pub lp_vault: UncheckedAccount<'info>,
            /// CHECK: Token_0 vault for the pool, created by contract
            #[account(
                mut,
                cctoken,
                seeds = [POOL_VAULT_SEED.as_bytes(),
                pool_state.to_account_info().key.as_ref(),
                token_0_mint.to_account_info().key.as_ref()],
                authority = crate::AUTH_SEED,
                bump,
            )]
            pub token_0_vault: UncheckedAccount<'info>,
            /// CHECK: Token_1 vault for the pool, created by contract
            #[account(
                mut,
                cctoken,
                seeds = [POOL_VAULT_SEED.as_bytes(),
                pool_state.to_account_info().key.as_ref(),
                token_1_mint.to_account_info().key.as_ref()],
                authority = crate::AUTH_SEED,
                bump,
            )]
            pub token_1_vault: UncheckedAccount<'info>,
            /// create pool fee account
            #[account(mut, address = crate::create_pool_fee_receiver::ID)]
            pub create_pool_fee: Box<InterfaceAccount<'info, TokenAccount>>,
            /// an account to store oracle observations
            #[account(
                init,
                cpda::authority = authority,
                cpda::address_tree_info = compression_params.observation_address_tree_info,
                seeds = [OBSERVATION_SEED.as_bytes(),
                pool_state.to_account_info().key.as_ref(),
                ],
                bump,
                payer = creator,
                space = 8+ObservationState::INIT_SPACE
            )]
            pub observation_state: Box<Account<'info, ObservationState>>,
            /// Program to create mint account and mint tokens
            pub token_program: Program<'info, Token>,
            /// Spl token program or token program 2022
            pub token_0_program: Interface<'info, TokenInterface>,
            /// Spl token program or token program 2022
            pub token_1_program: Interface<'info, TokenInterface>,
            /// Program to create an ATA for receiving position NFT
            pub associated_token_program: Program<'info, AssociatedToken>,
            /// To create a new program account
            pub system_program: Program<'info, System>,
            /// Sysvar for program account
            pub rent: Sysvar<'info, Rent>,
            /// CHECK: checked via load_checked.
            pub compression_config: AccountInfo<'info>,
            /// CHECK: checked in instruction.
            #[account(mut)]
            pub rent_recipient: AccountInfo<'info>,
            /// CHECK: checked by protocol.
            pub compressed_token_program_cpi_authority: AccountInfo<'info>,
            /// CHECK: checked by protocol.
            pub compressed_token_program: AccountInfo<'info>,
            /// CHECK: checked by protocol.
            pub ctoken_config_account: AccountInfo<'info>,
            /// CHECK: checked by protocol.
            #[account(mut)]
            pub ctoken_rent_recipient: AccountInfo<'info>,
            /// CHECK: checked by protocol.
            #[account(mut)]
            pub compressed_token_0_pool_pda: AccountInfo<'info>,
            /// CHECK: checked by protocol.
            #[account(mut)]
            pub compressed_token_1_pool_pda: AccountInfo<'info>,
        }
        #[automatically_derived]
        impl<'info> anchor_lang::Accounts<'info, InitializeBumps> for Initialize<'info>
        where
            'info: 'info,
        {
            #[inline(never)]
            fn try_accounts(
                __program_id: &anchor_lang::solana_program::pubkey::Pubkey,
                __accounts: &mut &'info [anchor_lang::solana_program::account_info::AccountInfo<
                    'info,
                >],
                __ix_data: &[u8],
                __bumps: &mut InitializeBumps,
                __reallocs: &mut std::collections::BTreeSet<
                    anchor_lang::solana_program::pubkey::Pubkey,
                >,
            ) -> anchor_lang::Result<Self> {
                let mut __ix_data = __ix_data;
                struct __Args {
                    init_amount_0: u64,
                    init_amount_1: u64,
                    open_time: u64,
                    compression_params: InitializeCompressionParams,
                }
                impl borsh::ser::BorshSerialize for __Args
                where
                    u64: borsh::ser::BorshSerialize,
                    u64: borsh::ser::BorshSerialize,
                    u64: borsh::ser::BorshSerialize,
                    InitializeCompressionParams: borsh::ser::BorshSerialize,
                {
                    fn serialize<W: borsh::maybestd::io::Write>(
                        &self,
                        writer: &mut W,
                    ) -> ::core::result::Result<(), borsh::maybestd::io::Error> {
                        borsh::BorshSerialize::serialize(&self.init_amount_0, writer)?;
                        borsh::BorshSerialize::serialize(&self.init_amount_1, writer)?;
                        borsh::BorshSerialize::serialize(&self.open_time, writer)?;
                        borsh::BorshSerialize::serialize(
                            &self.compression_params,
                            writer,
                        )?;
                        Ok(())
                    }
                }
                impl anchor_lang::idl::build::IdlBuild for __Args {
                    fn create_type() -> Option<anchor_lang::idl::types::IdlTypeDef> {
                        Some(anchor_lang::idl::types::IdlTypeDef {
                            name: Self::get_full_path(),
                            docs: ::alloc::vec::Vec::new(),
                            serialization: anchor_lang::idl::types::IdlSerialization::default(),
                            repr: None,
                            generics: ::alloc::vec::Vec::new(),
                            ty: anchor_lang::idl::types::IdlTypeDefTy::Struct {
                                fields: Some(
                                    anchor_lang::idl::types::IdlDefinedFields::Named(
                                        <[_]>::into_vec(
                                            ::alloc::boxed::box_new([
                                                anchor_lang::idl::types::IdlField {
                                                    name: "init_amount_0".into(),
                                                    docs: ::alloc::vec::Vec::new(),
                                                    ty: anchor_lang::idl::types::IdlType::U64,
                                                },
                                                anchor_lang::idl::types::IdlField {
                                                    name: "init_amount_1".into(),
                                                    docs: ::alloc::vec::Vec::new(),
                                                    ty: anchor_lang::idl::types::IdlType::U64,
                                                },
                                                anchor_lang::idl::types::IdlField {
                                                    name: "open_time".into(),
                                                    docs: ::alloc::vec::Vec::new(),
                                                    ty: anchor_lang::idl::types::IdlType::U64,
                                                },
                                                anchor_lang::idl::types::IdlField {
                                                    name: "compression_params".into(),
                                                    docs: ::alloc::vec::Vec::new(),
                                                    ty: anchor_lang::idl::types::IdlType::Defined {
                                                        name: <InitializeCompressionParams>::get_full_path(),
                                                        generics: ::alloc::vec::Vec::new(),
                                                    },
                                                },
                                            ]),
                                        ),
                                    ),
                                ),
                            },
                        })
                    }
                    fn insert_types(
                        types: &mut std::collections::BTreeMap<
                            String,
                            anchor_lang::idl::types::IdlTypeDef,
                        >,
                    ) {
                        if let Some(ty) = <InitializeCompressionParams>::create_type() {
                            types
                                .insert(<InitializeCompressionParams>::get_full_path(), ty);
                            <InitializeCompressionParams>::insert_types(types);
                        }
                    }
                    fn get_full_path() -> String {
                        ::alloc::__export::must_use({
                            ::alloc::fmt::format(
                                format_args!(
                                    "{0}::{1}",
                                    "raydium_cp_swap::instructions::initialize",
                                    "__Args",
                                ),
                            )
                        })
                    }
                }
                impl borsh::de::BorshDeserialize for __Args
                where
                    u64: borsh::BorshDeserialize,
                    u64: borsh::BorshDeserialize,
                    u64: borsh::BorshDeserialize,
                    InitializeCompressionParams: borsh::BorshDeserialize,
                {
                    fn deserialize_reader<R: borsh::maybestd::io::Read>(
                        reader: &mut R,
                    ) -> ::core::result::Result<Self, borsh::maybestd::io::Error> {
                        Ok(Self {
                            init_amount_0: borsh::BorshDeserialize::deserialize_reader(
                                reader,
                            )?,
                            init_amount_1: borsh::BorshDeserialize::deserialize_reader(
                                reader,
                            )?,
                            open_time: borsh::BorshDeserialize::deserialize_reader(
                                reader,
                            )?,
                            compression_params: borsh::BorshDeserialize::deserialize_reader(
                                reader,
                            )?,
                        })
                    }
                }
                let __args: __Args = __Args::deserialize(&mut __ix_data)
                    .map_err(|_| {
                        anchor_lang::error::ErrorCode::InstructionDidNotDeserialize
                    })?;
                let init_amount_0 = __args.init_amount_0;
                let init_amount_1 = __args.init_amount_1;
                let open_time = __args.open_time;
                let compression_params = __args.compression_params;
                let _ = __args;
                let creator: Signer = anchor_lang::Accounts::try_accounts(
                        __program_id,
                        __accounts,
                        __ix_data,
                        __bumps,
                        __reallocs,
                    )
                    .map_err(|e| e.with_account_name("creator"))?;
                let amm_config: Box<
                    anchor_lang::accounts::account::Account<AmmConfig>,
                > = anchor_lang::Accounts::try_accounts(
                        __program_id,
                        __accounts,
                        __ix_data,
                        __bumps,
                        __reallocs,
                    )
                    .map_err(|e| e.with_account_name("amm_config"))?;
                let authority: UncheckedAccount = anchor_lang::Accounts::try_accounts(
                        __program_id,
                        __accounts,
                        __ix_data,
                        __bumps,
                        __reallocs,
                    )
                    .map_err(|e| e.with_account_name("authority"))?;
                if __accounts.is_empty() {
                    return Err(
                        anchor_lang::error::ErrorCode::AccountNotEnoughKeys.into(),
                    );
                }
                let pool_state = &__accounts[0];
                *__accounts = &__accounts[1..];
                let token_0_mint: Box<
                    anchor_lang::accounts::interface_account::InterfaceAccount<Mint>,
                > = Box::new({
                    if __accounts.is_empty() {
                        return Err(
                            anchor_lang::error::ErrorCode::AccountNotEnoughKeys.into(),
                        );
                    }
                    let __acc = &__accounts[0];
                    let __is_ctoken = if __accounts.len() > 13usize {
                        __accounts[13usize].key == &anchor_lang::CTOKEN_ID
                    } else {
                        false
                    };
                    *__accounts = &__accounts[1..];
                    if __is_ctoken {
                        anchor_lang::accounts::interface_account::InterfaceAccount::try_from_ctoken(
                                __acc,
                            )
                            .map_err(|e| e.with_account_name("token_0_mint"))?
                    } else {
                        anchor_lang::accounts::interface_account::InterfaceAccount::try_from(
                                __acc,
                            )
                            .map_err(|e| e.with_account_name("token_0_mint"))?
                    }
                });
                let token_1_mint: Box<
                    anchor_lang::accounts::interface_account::InterfaceAccount<Mint>,
                > = Box::new({
                    if __accounts.is_empty() {
                        return Err(
                            anchor_lang::error::ErrorCode::AccountNotEnoughKeys.into(),
                        );
                    }
                    let __acc = &__accounts[0];
                    let __is_ctoken = if __accounts.len() > 13usize {
                        __accounts[13usize].key == &anchor_lang::CTOKEN_ID
                    } else {
                        false
                    };
                    *__accounts = &__accounts[1..];
                    if __is_ctoken {
                        anchor_lang::accounts::interface_account::InterfaceAccount::try_from_ctoken(
                                __acc,
                            )
                            .map_err(|e| e.with_account_name("token_1_mint"))?
                    } else {
                        anchor_lang::accounts::interface_account::InterfaceAccount::try_from(
                                __acc,
                            )
                            .map_err(|e| e.with_account_name("token_1_mint"))?
                    }
                });
                let lp_mint_signer: UncheckedAccount = anchor_lang::Accounts::try_accounts(
                        __program_id,
                        __accounts,
                        __ix_data,
                        __bumps,
                        __reallocs,
                    )
                    .map_err(|e| e.with_account_name("lp_mint_signer"))?;
                let mut lp_mint: CMint = anchor_lang::Accounts::try_accounts(
                        __program_id,
                        __accounts,
                        __ix_data,
                        __bumps,
                        __reallocs,
                    )
                    .map_err(|e| e.with_account_name("lp_mint"))?;
                {
                    let __auth = &authority;
                    lp_mint.authority = Some(__auth.key());
                }
                lp_mint.decimals = Some(9u8);
                {
                    let __signer = &lp_mint_signer;
                    lp_mint.mint_signer = Some(__signer.to_account_info());
                }
                lp_mint.mint_signer_seeds = Some(
                    <[_]>::into_vec(
                        ::alloc::boxed::box_new([
                            Vec::from(POOL_LP_MINT_SEED.as_bytes().as_ref()),
                            Vec::from(pool_state.to_account_info().key.as_ref().as_ref()),
                        ]),
                    ),
                );
                let creator_token_0: Box<
                    anchor_lang::accounts::interface_account::InterfaceAccount<
                        TokenAccount,
                    >,
                > = anchor_lang::Accounts::try_accounts(
                        __program_id,
                        __accounts,
                        __ix_data,
                        __bumps,
                        __reallocs,
                    )
                    .map_err(|e| e.with_account_name("creator_token_0"))?;
                let creator_token_1: Box<
                    anchor_lang::accounts::interface_account::InterfaceAccount<
                        TokenAccount,
                    >,
                > = anchor_lang::Accounts::try_accounts(
                        __program_id,
                        __accounts,
                        __ix_data,
                        __bumps,
                        __reallocs,
                    )
                    .map_err(|e| e.with_account_name("creator_token_1"))?;
                let creator_lp_token: UncheckedAccount = anchor_lang::Accounts::try_accounts(
                        __program_id,
                        __accounts,
                        __ix_data,
                        __bumps,
                        __reallocs,
                    )
                    .map_err(|e| e.with_account_name("creator_lp_token"))?;
                let lp_vault: UncheckedAccount = anchor_lang::Accounts::try_accounts(
                        __program_id,
                        __accounts,
                        __ix_data,
                        __bumps,
                        __reallocs,
                    )
                    .map_err(|e| e.with_account_name("lp_vault"))?;
                let token_0_vault: UncheckedAccount = anchor_lang::Accounts::try_accounts(
                        __program_id,
                        __accounts,
                        __ix_data,
                        __bumps,
                        __reallocs,
                    )
                    .map_err(|e| e.with_account_name("token_0_vault"))?;
                let token_1_vault: UncheckedAccount = anchor_lang::Accounts::try_accounts(
                        __program_id,
                        __accounts,
                        __ix_data,
                        __bumps,
                        __reallocs,
                    )
                    .map_err(|e| e.with_account_name("token_1_vault"))?;
                let create_pool_fee: Box<
                    anchor_lang::accounts::interface_account::InterfaceAccount<
                        TokenAccount,
                    >,
                > = anchor_lang::Accounts::try_accounts(
                        __program_id,
                        __accounts,
                        __ix_data,
                        __bumps,
                        __reallocs,
                    )
                    .map_err(|e| e.with_account_name("create_pool_fee"))?;
                if __accounts.is_empty() {
                    return Err(
                        anchor_lang::error::ErrorCode::AccountNotEnoughKeys.into(),
                    );
                }
                let observation_state = &__accounts[0];
                *__accounts = &__accounts[1..];
                let token_program: anchor_lang::accounts::program::Program<Token> = anchor_lang::Accounts::try_accounts(
                        __program_id,
                        __accounts,
                        __ix_data,
                        __bumps,
                        __reallocs,
                    )
                    .map_err(|e| e.with_account_name("token_program"))?;
                let token_0_program: anchor_lang::accounts::interface::Interface<
                    TokenInterface,
                > = anchor_lang::Accounts::try_accounts(
                        __program_id,
                        __accounts,
                        __ix_data,
                        __bumps,
                        __reallocs,
                    )
                    .map_err(|e| e.with_account_name("token_0_program"))?;
                let token_1_program: anchor_lang::accounts::interface::Interface<
                    TokenInterface,
                > = anchor_lang::Accounts::try_accounts(
                        __program_id,
                        __accounts,
                        __ix_data,
                        __bumps,
                        __reallocs,
                    )
                    .map_err(|e| e.with_account_name("token_1_program"))?;
                let associated_token_program: anchor_lang::accounts::program::Program<
                    AssociatedToken,
                > = anchor_lang::Accounts::try_accounts(
                        __program_id,
                        __accounts,
                        __ix_data,
                        __bumps,
                        __reallocs,
                    )
                    .map_err(|e| e.with_account_name("associated_token_program"))?;
                let system_program: anchor_lang::accounts::program::Program<System> = anchor_lang::Accounts::try_accounts(
                        __program_id,
                        __accounts,
                        __ix_data,
                        __bumps,
                        __reallocs,
                    )
                    .map_err(|e| e.with_account_name("system_program"))?;
                let rent: Sysvar<Rent> = anchor_lang::Accounts::try_accounts(
                        __program_id,
                        __accounts,
                        __ix_data,
                        __bumps,
                        __reallocs,
                    )
                    .map_err(|e| e.with_account_name("rent"))?;
                let compression_config: AccountInfo = anchor_lang::Accounts::try_accounts(
                        __program_id,
                        __accounts,
                        __ix_data,
                        __bumps,
                        __reallocs,
                    )
                    .map_err(|e| e.with_account_name("compression_config"))?;
                let rent_recipient: AccountInfo = anchor_lang::Accounts::try_accounts(
                        __program_id,
                        __accounts,
                        __ix_data,
                        __bumps,
                        __reallocs,
                    )
                    .map_err(|e| e.with_account_name("rent_recipient"))?;
                let compressed_token_program_cpi_authority: AccountInfo = anchor_lang::Accounts::try_accounts(
                        __program_id,
                        __accounts,
                        __ix_data,
                        __bumps,
                        __reallocs,
                    )
                    .map_err(|e| {
                        e.with_account_name("compressed_token_program_cpi_authority")
                    })?;
                let compressed_token_program: AccountInfo = anchor_lang::Accounts::try_accounts(
                        __program_id,
                        __accounts,
                        __ix_data,
                        __bumps,
                        __reallocs,
                    )
                    .map_err(|e| e.with_account_name("compressed_token_program"))?;
                let ctoken_config_account: AccountInfo = anchor_lang::Accounts::try_accounts(
                        __program_id,
                        __accounts,
                        __ix_data,
                        __bumps,
                        __reallocs,
                    )
                    .map_err(|e| e.with_account_name("ctoken_config_account"))?;
                let ctoken_rent_recipient: AccountInfo = anchor_lang::Accounts::try_accounts(
                        __program_id,
                        __accounts,
                        __ix_data,
                        __bumps,
                        __reallocs,
                    )
                    .map_err(|e| e.with_account_name("ctoken_rent_recipient"))?;
                let compressed_token_0_pool_pda: AccountInfo = anchor_lang::Accounts::try_accounts(
                        __program_id,
                        __accounts,
                        __ix_data,
                        __bumps,
                        __reallocs,
                    )
                    .map_err(|e| e.with_account_name("compressed_token_0_pool_pda"))?;
                let compressed_token_1_pool_pda: AccountInfo = anchor_lang::Accounts::try_accounts(
                        __program_id,
                        __accounts,
                        __ix_data,
                        __bumps,
                        __reallocs,
                    )
                    .map_err(|e| e.with_account_name("compressed_token_1_pool_pda"))?;
                let __anchor_rent = Rent::get()?;
                let (__pda_address, __bump) = Pubkey::find_program_address(
                    &[
                        POOL_SEED.as_bytes(),
                        amm_config.to_account_info().key.as_ref(),
                        token_0_mint.to_account_info().key.as_ref(),
                        token_1_mint.to_account_info().key.as_ref(),
                    ],
                    __program_id,
                );
                __bumps.pool_state = __bump;
                if pool_state.key() != __pda_address {
                    return Err(
                        anchor_lang::error::Error::from(
                                anchor_lang::error::ErrorCode::ConstraintSeeds,
                            )
                            .with_account_name("pool_state")
                            .with_pubkeys((pool_state.key(), __pda_address)),
                    );
                }
                let pool_state = ({
                    #[inline(never)]
                    || {
                        let actual_field = AsRef::<
                            AccountInfo,
                        >::as_ref(pool_state.as_ref());
                        let actual_owner = actual_field.owner;
                        let space = 8 + PoolState::INIT_SPACE;
                        let pa: Box<
                            anchor_lang::accounts::account::Account<PoolState>,
                        > = if !false
                            || actual_owner
                                == &anchor_lang::solana_program::system_program::ID
                        {
                            let __current_lamports = pool_state.lamports();
                            if __current_lamports == 0 {
                                let space = space;
                                let lamports = __anchor_rent.minimum_balance(space);
                                let cpi_accounts = anchor_lang::system_program::CreateAccount {
                                    from: creator.to_account_info(),
                                    to: pool_state.to_account_info(),
                                };
                                let cpi_context = anchor_lang::context::CpiContext::new(
                                    system_program.to_account_info(),
                                    cpi_accounts,
                                );
                                anchor_lang::system_program::create_account(
                                    cpi_context
                                        .with_signer(
                                            &[
                                                &[
                                                    POOL_SEED.as_bytes(),
                                                    amm_config.to_account_info().key.as_ref(),
                                                    token_0_mint.to_account_info().key.as_ref(),
                                                    token_1_mint.to_account_info().key.as_ref(),
                                                    &[__bump][..],
                                                ][..],
                                            ],
                                        ),
                                    lamports,
                                    space as u64,
                                    __program_id,
                                )?;
                            } else {
                                if creator.key() == pool_state.key() {
                                    return Err(
                                        anchor_lang::error::Error::from(anchor_lang::error::AnchorError {
                                                error_name: anchor_lang::error::ErrorCode::TryingToInitPayerAsProgramAccount
                                                    .name(),
                                                error_code_number: anchor_lang::error::ErrorCode::TryingToInitPayerAsProgramAccount
                                                    .into(),
                                                error_msg: anchor_lang::error::ErrorCode::TryingToInitPayerAsProgramAccount
                                                    .to_string(),
                                                error_origin: Some(
                                                    anchor_lang::error::ErrorOrigin::Source(anchor_lang::error::Source {
                                                        filename: "programs/cp-swap/src/instructions/initialize.rs",
                                                        line: 25u32,
                                                    }),
                                                ),
                                                compared_values: None,
                                            })
                                            .with_pubkeys((creator.key(), pool_state.key())),
                                    );
                                }
                                let required_lamports = __anchor_rent
                                    .minimum_balance(space)
                                    .max(1)
                                    .saturating_sub(__current_lamports);
                                if required_lamports > 0 {
                                    let cpi_accounts = anchor_lang::system_program::Transfer {
                                        from: creator.to_account_info(),
                                        to: pool_state.to_account_info(),
                                    };
                                    let cpi_context = anchor_lang::context::CpiContext::new(
                                        system_program.to_account_info(),
                                        cpi_accounts,
                                    );
                                    anchor_lang::system_program::transfer(
                                        cpi_context,
                                        required_lamports,
                                    )?;
                                }
                                let cpi_accounts = anchor_lang::system_program::Allocate {
                                    account_to_allocate: pool_state.to_account_info(),
                                };
                                let cpi_context = anchor_lang::context::CpiContext::new(
                                    system_program.to_account_info(),
                                    cpi_accounts,
                                );
                                anchor_lang::system_program::allocate(
                                    cpi_context
                                        .with_signer(
                                            &[
                                                &[
                                                    POOL_SEED.as_bytes(),
                                                    amm_config.to_account_info().key.as_ref(),
                                                    token_0_mint.to_account_info().key.as_ref(),
                                                    token_1_mint.to_account_info().key.as_ref(),
                                                    &[__bump][..],
                                                ][..],
                                            ],
                                        ),
                                    space as u64,
                                )?;
                                let cpi_accounts = anchor_lang::system_program::Assign {
                                    account_to_assign: pool_state.to_account_info(),
                                };
                                let cpi_context = anchor_lang::context::CpiContext::new(
                                    system_program.to_account_info(),
                                    cpi_accounts,
                                );
                                anchor_lang::system_program::assign(
                                    cpi_context
                                        .with_signer(
                                            &[
                                                &[
                                                    POOL_SEED.as_bytes(),
                                                    amm_config.to_account_info().key.as_ref(),
                                                    token_0_mint.to_account_info().key.as_ref(),
                                                    token_1_mint.to_account_info().key.as_ref(),
                                                    &[__bump][..],
                                                ][..],
                                            ],
                                        ),
                                    __program_id,
                                )?;
                            }
                            Box::new(
                                match anchor_lang::accounts::account::Account::try_from_unchecked(
                                    &pool_state,
                                ) {
                                    Ok(val) => val,
                                    Err(e) => return Err(e.with_account_name("pool_state")),
                                },
                            )
                        } else {
                            Box::new(
                                match anchor_lang::accounts::account::Account::try_from(
                                    &pool_state,
                                ) {
                                    Ok(val) => val,
                                    Err(e) => return Err(e.with_account_name("pool_state")),
                                },
                            )
                        };
                        if false {
                            if space != actual_field.data_len() {
                                return Err(
                                    anchor_lang::error::Error::from(
                                            anchor_lang::error::ErrorCode::ConstraintSpace,
                                        )
                                        .with_account_name("pool_state")
                                        .with_values((space, actual_field.data_len())),
                                );
                            }
                            if actual_owner != __program_id {
                                return Err(
                                    anchor_lang::error::Error::from(
                                            anchor_lang::error::ErrorCode::ConstraintOwner,
                                        )
                                        .with_account_name("pool_state")
                                        .with_pubkeys((*actual_owner, *__program_id)),
                                );
                            }
                            {
                                let required_lamports = __anchor_rent
                                    .minimum_balance(space);
                                if pa.to_account_info().lamports() < required_lamports {
                                    return Err(
                                        anchor_lang::error::Error::from(
                                                anchor_lang::error::ErrorCode::ConstraintRentExempt,
                                            )
                                            .with_account_name("pool_state"),
                                    );
                                }
                            }
                        }
                        Ok(pa)
                    }
                })()?;
                if !AsRef::<AccountInfo>::as_ref(pool_state.as_ref()).is_writable {
                    return Err(
                        anchor_lang::error::Error::from(
                                anchor_lang::error::ErrorCode::ConstraintMut,
                            )
                            .with_account_name("pool_state"),
                    );
                }
                if !__anchor_rent
                    .is_exempt(
                        pool_state.to_account_info().lamports(),
                        pool_state.to_account_info().try_data_len()?,
                    )
                {
                    return Err(
                        anchor_lang::error::Error::from(
                                anchor_lang::error::ErrorCode::ConstraintRentExempt,
                            )
                            .with_account_name("pool_state"),
                    );
                }
                let __anchor_rent = Rent::get()?;
                let (__pda_address, __bump) = Pubkey::find_program_address(
                    &[
                        OBSERVATION_SEED.as_bytes(),
                        pool_state.to_account_info().key.as_ref(),
                    ],
                    __program_id,
                );
                __bumps.observation_state = __bump;
                if observation_state.key() != __pda_address {
                    return Err(
                        anchor_lang::error::Error::from(
                                anchor_lang::error::ErrorCode::ConstraintSeeds,
                            )
                            .with_account_name("observation_state")
                            .with_pubkeys((observation_state.key(), __pda_address)),
                    );
                }
                let observation_state = ({
                    #[inline(never)]
                    || {
                        let actual_field = AsRef::<
                            AccountInfo,
                        >::as_ref(observation_state.as_ref());
                        let actual_owner = actual_field.owner;
                        let space = 8 + ObservationState::INIT_SPACE;
                        let pa: Box<
                            anchor_lang::accounts::account::Account<ObservationState>,
                        > = if !false
                            || actual_owner
                                == &anchor_lang::solana_program::system_program::ID
                        {
                            let __current_lamports = observation_state.lamports();
                            if __current_lamports == 0 {
                                let space = space;
                                let lamports = __anchor_rent.minimum_balance(space);
                                let cpi_accounts = anchor_lang::system_program::CreateAccount {
                                    from: creator.to_account_info(),
                                    to: observation_state.to_account_info(),
                                };
                                let cpi_context = anchor_lang::context::CpiContext::new(
                                    system_program.to_account_info(),
                                    cpi_accounts,
                                );
                                anchor_lang::system_program::create_account(
                                    cpi_context
                                        .with_signer(
                                            &[
                                                &[
                                                    OBSERVATION_SEED.as_bytes(),
                                                    pool_state.to_account_info().key.as_ref(),
                                                    &[__bump][..],
                                                ][..],
                                            ],
                                        ),
                                    lamports,
                                    space as u64,
                                    __program_id,
                                )?;
                            } else {
                                if creator.key() == observation_state.key() {
                                    return Err(
                                        anchor_lang::error::Error::from(anchor_lang::error::AnchorError {
                                                error_name: anchor_lang::error::ErrorCode::TryingToInitPayerAsProgramAccount
                                                    .name(),
                                                error_code_number: anchor_lang::error::ErrorCode::TryingToInitPayerAsProgramAccount
                                                    .into(),
                                                error_msg: anchor_lang::error::ErrorCode::TryingToInitPayerAsProgramAccount
                                                    .to_string(),
                                                error_origin: Some(
                                                    anchor_lang::error::ErrorOrigin::Source(anchor_lang::error::Source {
                                                        filename: "programs/cp-swap/src/instructions/initialize.rs",
                                                        line: 25u32,
                                                    }),
                                                ),
                                                compared_values: None,
                                            })
                                            .with_pubkeys((creator.key(), observation_state.key())),
                                    );
                                }
                                let required_lamports = __anchor_rent
                                    .minimum_balance(space)
                                    .max(1)
                                    .saturating_sub(__current_lamports);
                                if required_lamports > 0 {
                                    let cpi_accounts = anchor_lang::system_program::Transfer {
                                        from: creator.to_account_info(),
                                        to: observation_state.to_account_info(),
                                    };
                                    let cpi_context = anchor_lang::context::CpiContext::new(
                                        system_program.to_account_info(),
                                        cpi_accounts,
                                    );
                                    anchor_lang::system_program::transfer(
                                        cpi_context,
                                        required_lamports,
                                    )?;
                                }
                                let cpi_accounts = anchor_lang::system_program::Allocate {
                                    account_to_allocate: observation_state.to_account_info(),
                                };
                                let cpi_context = anchor_lang::context::CpiContext::new(
                                    system_program.to_account_info(),
                                    cpi_accounts,
                                );
                                anchor_lang::system_program::allocate(
                                    cpi_context
                                        .with_signer(
                                            &[
                                                &[
                                                    OBSERVATION_SEED.as_bytes(),
                                                    pool_state.to_account_info().key.as_ref(),
                                                    &[__bump][..],
                                                ][..],
                                            ],
                                        ),
                                    space as u64,
                                )?;
                                let cpi_accounts = anchor_lang::system_program::Assign {
                                    account_to_assign: observation_state.to_account_info(),
                                };
                                let cpi_context = anchor_lang::context::CpiContext::new(
                                    system_program.to_account_info(),
                                    cpi_accounts,
                                );
                                anchor_lang::system_program::assign(
                                    cpi_context
                                        .with_signer(
                                            &[
                                                &[
                                                    OBSERVATION_SEED.as_bytes(),
                                                    pool_state.to_account_info().key.as_ref(),
                                                    &[__bump][..],
                                                ][..],
                                            ],
                                        ),
                                    __program_id,
                                )?;
                            }
                            Box::new(
                                match anchor_lang::accounts::account::Account::try_from_unchecked(
                                    &observation_state,
                                ) {
                                    Ok(val) => val,
                                    Err(e) => {
                                        return Err(e.with_account_name("observation_state"));
                                    }
                                },
                            )
                        } else {
                            Box::new(
                                match anchor_lang::accounts::account::Account::try_from(
                                    &observation_state,
                                ) {
                                    Ok(val) => val,
                                    Err(e) => {
                                        return Err(e.with_account_name("observation_state"));
                                    }
                                },
                            )
                        };
                        if false {
                            if space != actual_field.data_len() {
                                return Err(
                                    anchor_lang::error::Error::from(
                                            anchor_lang::error::ErrorCode::ConstraintSpace,
                                        )
                                        .with_account_name("observation_state")
                                        .with_values((space, actual_field.data_len())),
                                );
                            }
                            if actual_owner != __program_id {
                                return Err(
                                    anchor_lang::error::Error::from(
                                            anchor_lang::error::ErrorCode::ConstraintOwner,
                                        )
                                        .with_account_name("observation_state")
                                        .with_pubkeys((*actual_owner, *__program_id)),
                                );
                            }
                            {
                                let required_lamports = __anchor_rent
                                    .minimum_balance(space);
                                if pa.to_account_info().lamports() < required_lamports {
                                    return Err(
                                        anchor_lang::error::Error::from(
                                                anchor_lang::error::ErrorCode::ConstraintRentExempt,
                                            )
                                            .with_account_name("observation_state"),
                                    );
                                }
                            }
                        }
                        Ok(pa)
                    }
                })()?;
                if !AsRef::<AccountInfo>::as_ref(observation_state.as_ref()).is_writable
                {
                    return Err(
                        anchor_lang::error::Error::from(
                                anchor_lang::error::ErrorCode::ConstraintMut,
                            )
                            .with_account_name("observation_state"),
                    );
                }
                if !__anchor_rent
                    .is_exempt(
                        observation_state.to_account_info().lamports(),
                        observation_state.to_account_info().try_data_len()?,
                    )
                {
                    return Err(
                        anchor_lang::error::Error::from(
                                anchor_lang::error::ErrorCode::ConstraintRentExempt,
                            )
                            .with_account_name("observation_state"),
                    );
                }
                if !AsRef::<AccountInfo>::as_ref(&creator).is_writable {
                    return Err(
                        anchor_lang::error::Error::from(
                                anchor_lang::error::ErrorCode::ConstraintMut,
                            )
                            .with_account_name("creator"),
                    );
                }
                let (__pda_address, __bump) = Pubkey::find_program_address(
                    &[crate::AUTH_SEED.as_bytes()],
                    &__program_id,
                );
                __bumps.authority = __bump;
                if authority.key() != __pda_address {
                    return Err(
                        anchor_lang::error::Error::from(
                                anchor_lang::error::ErrorCode::ConstraintSeeds,
                            )
                            .with_account_name("authority")
                            .with_pubkeys((authority.key(), __pda_address)),
                    );
                }
                if !(token_0_mint.key() < token_1_mint.key()) {
                    return Err(
                        anchor_lang::error::Error::from(
                                anchor_lang::error::ErrorCode::ConstraintRaw,
                            )
                            .with_account_name("token_0_mint"),
                    );
                }
                {
                    let __is_ctoken = token_0_program.key() == anchor_lang::CTOKEN_ID;
                    if __is_ctoken {
                        if AsRef::<AccountInfo>::as_ref(token_0_mint.as_ref()).owner
                            != &anchor_lang::solana_program::system_program::ID
                        {
                            return Err(
                                anchor_lang::error::ErrorCode::ConstraintMintTokenProgram
                                    .into(),
                            );
                        }
                    } else {
                        if AsRef::<AccountInfo>::as_ref(token_0_mint.as_ref()).owner
                            != &token_0_program.key()
                        {
                            return Err(
                                anchor_lang::error::ErrorCode::ConstraintMintTokenProgram
                                    .into(),
                            );
                        }
                    }
                    if !__is_ctoken {}
                }
                {
                    let __is_ctoken = token_1_program.key() == anchor_lang::CTOKEN_ID;
                    if __is_ctoken {
                        if AsRef::<AccountInfo>::as_ref(token_1_mint.as_ref()).owner
                            != &anchor_lang::solana_program::system_program::ID
                        {
                            return Err(
                                anchor_lang::error::ErrorCode::ConstraintMintTokenProgram
                                    .into(),
                            );
                        }
                    } else {
                        if AsRef::<AccountInfo>::as_ref(token_1_mint.as_ref()).owner
                            != &token_1_program.key()
                        {
                            return Err(
                                anchor_lang::error::ErrorCode::ConstraintMintTokenProgram
                                    .into(),
                            );
                        }
                    }
                    if !__is_ctoken {}
                }
                let (__pda_address, __bump) = Pubkey::find_program_address(
                    &[
                        POOL_LP_MINT_SEED.as_bytes(),
                        pool_state.to_account_info().key.as_ref(),
                    ],
                    &__program_id,
                );
                __bumps.lp_mint_signer = __bump;
                if lp_mint_signer.key() != __pda_address {
                    return Err(
                        anchor_lang::error::Error::from(
                                anchor_lang::error::ErrorCode::ConstraintSeeds,
                            )
                            .with_account_name("lp_mint_signer")
                            .with_pubkeys((lp_mint_signer.key(), __pda_address)),
                    );
                }
                if !AsRef::<AccountInfo>::as_ref(creator_token_0.as_ref()).is_writable {
                    return Err(
                        anchor_lang::error::Error::from(
                                anchor_lang::error::ErrorCode::ConstraintMut,
                            )
                            .with_account_name("creator_token_0"),
                    );
                }
                {
                    if creator_token_0.owner != creator.key() {
                        return Err(
                            anchor_lang::error::ErrorCode::ConstraintTokenOwner.into(),
                        );
                    }
                    if creator_token_0.mint != token_0_mint.key() {
                        return Err(
                            anchor_lang::error::ErrorCode::ConstraintTokenMint.into(),
                        );
                    }
                }
                if !AsRef::<AccountInfo>::as_ref(creator_token_1.as_ref()).is_writable {
                    return Err(
                        anchor_lang::error::Error::from(
                                anchor_lang::error::ErrorCode::ConstraintMut,
                            )
                            .with_account_name("creator_token_1"),
                    );
                }
                {
                    if creator_token_1.owner != creator.key() {
                        return Err(
                            anchor_lang::error::ErrorCode::ConstraintTokenOwner.into(),
                        );
                    }
                    if creator_token_1.mint != token_1_mint.key() {
                        return Err(
                            anchor_lang::error::ErrorCode::ConstraintTokenMint.into(),
                        );
                    }
                }
                if !AsRef::<AccountInfo>::as_ref(&creator_lp_token).is_writable {
                    return Err(
                        anchor_lang::error::Error::from(
                                anchor_lang::error::ErrorCode::ConstraintMut,
                            )
                            .with_account_name("creator_lp_token"),
                    );
                }
                let (__pda_address, __bump) = Pubkey::find_program_address(
                    &[
                        POOL_VAULT_SEED.as_bytes(),
                        lp_mint.to_account_info().key.as_ref(),
                    ],
                    &__program_id,
                );
                __bumps.lp_vault = __bump;
                if lp_vault.key() != __pda_address {
                    return Err(
                        anchor_lang::error::Error::from(
                                anchor_lang::error::ErrorCode::ConstraintSeeds,
                            )
                            .with_account_name("lp_vault")
                            .with_pubkeys((lp_vault.key(), __pda_address)),
                    );
                }
                if !AsRef::<AccountInfo>::as_ref(&lp_vault).is_writable {
                    return Err(
                        anchor_lang::error::Error::from(
                                anchor_lang::error::ErrorCode::ConstraintMut,
                            )
                            .with_account_name("lp_vault"),
                    );
                }
                let (__pda_address, __bump) = Pubkey::find_program_address(
                    &[
                        POOL_VAULT_SEED.as_bytes(),
                        pool_state.to_account_info().key.as_ref(),
                        token_0_mint.to_account_info().key.as_ref(),
                    ],
                    &__program_id,
                );
                __bumps.token_0_vault = __bump;
                if token_0_vault.key() != __pda_address {
                    return Err(
                        anchor_lang::error::Error::from(
                                anchor_lang::error::ErrorCode::ConstraintSeeds,
                            )
                            .with_account_name("token_0_vault")
                            .with_pubkeys((token_0_vault.key(), __pda_address)),
                    );
                }
                if !AsRef::<AccountInfo>::as_ref(&token_0_vault).is_writable {
                    return Err(
                        anchor_lang::error::Error::from(
                                anchor_lang::error::ErrorCode::ConstraintMut,
                            )
                            .with_account_name("token_0_vault"),
                    );
                }
                let (__pda_address, __bump) = Pubkey::find_program_address(
                    &[
                        POOL_VAULT_SEED.as_bytes(),
                        pool_state.to_account_info().key.as_ref(),
                        token_1_mint.to_account_info().key.as_ref(),
                    ],
                    &__program_id,
                );
                __bumps.token_1_vault = __bump;
                if token_1_vault.key() != __pda_address {
                    return Err(
                        anchor_lang::error::Error::from(
                                anchor_lang::error::ErrorCode::ConstraintSeeds,
                            )
                            .with_account_name("token_1_vault")
                            .with_pubkeys((token_1_vault.key(), __pda_address)),
                    );
                }
                if !AsRef::<AccountInfo>::as_ref(&token_1_vault).is_writable {
                    return Err(
                        anchor_lang::error::Error::from(
                                anchor_lang::error::ErrorCode::ConstraintMut,
                            )
                            .with_account_name("token_1_vault"),
                    );
                }
                if !AsRef::<AccountInfo>::as_ref(create_pool_fee.as_ref()).is_writable {
                    return Err(
                        anchor_lang::error::Error::from(
                                anchor_lang::error::ErrorCode::ConstraintMut,
                            )
                            .with_account_name("create_pool_fee"),
                    );
                }
                {
                    let actual = create_pool_fee.key();
                    let expected = crate::create_pool_fee_receiver::ID;
                    if actual != expected {
                        return Err(
                            anchor_lang::error::Error::from(
                                    anchor_lang::error::ErrorCode::ConstraintAddress,
                                )
                                .with_account_name("create_pool_fee")
                                .with_pubkeys((actual, expected)),
                        );
                    }
                }
                if !&rent_recipient.is_writable {
                    return Err(
                        anchor_lang::error::Error::from(
                                anchor_lang::error::ErrorCode::ConstraintMut,
                            )
                            .with_account_name("rent_recipient"),
                    );
                }
                if !&ctoken_rent_recipient.is_writable {
                    return Err(
                        anchor_lang::error::Error::from(
                                anchor_lang::error::ErrorCode::ConstraintMut,
                            )
                            .with_account_name("ctoken_rent_recipient"),
                    );
                }
                if !&compressed_token_0_pool_pda.is_writable {
                    return Err(
                        anchor_lang::error::Error::from(
                                anchor_lang::error::ErrorCode::ConstraintMut,
                            )
                            .with_account_name("compressed_token_0_pool_pda"),
                    );
                }
                if !&compressed_token_1_pool_pda.is_writable {
                    return Err(
                        anchor_lang::error::Error::from(
                                anchor_lang::error::ErrorCode::ConstraintMut,
                            )
                            .with_account_name("compressed_token_1_pool_pda"),
                    );
                }
                Ok(Initialize {
                    creator,
                    amm_config,
                    authority,
                    pool_state,
                    token_0_mint,
                    token_1_mint,
                    lp_mint_signer,
                    lp_mint,
                    creator_token_0,
                    creator_token_1,
                    creator_lp_token,
                    lp_vault,
                    token_0_vault,
                    token_1_vault,
                    create_pool_fee,
                    observation_state,
                    token_program,
                    token_0_program,
                    token_1_program,
                    associated_token_program,
                    system_program,
                    rent,
                    compression_config,
                    rent_recipient,
                    compressed_token_program_cpi_authority,
                    compressed_token_program,
                    ctoken_config_account,
                    ctoken_rent_recipient,
                    compressed_token_0_pool_pda,
                    compressed_token_1_pool_pda,
                })
            }
        }
        #[automatically_derived]
        impl<'info> anchor_lang::ToAccountInfos<'info> for Initialize<'info>
        where
            'info: 'info,
        {
            fn to_account_infos(
                &self,
            ) -> Vec<anchor_lang::solana_program::account_info::AccountInfo<'info>> {
                let mut account_infos = ::alloc::vec::Vec::new();
                account_infos.extend(self.creator.to_account_infos());
                account_infos.extend(self.amm_config.to_account_infos());
                account_infos.extend(self.authority.to_account_infos());
                account_infos.extend(self.pool_state.to_account_infos());
                account_infos.extend(self.token_0_mint.to_account_infos());
                account_infos.extend(self.token_1_mint.to_account_infos());
                account_infos.extend(self.lp_mint_signer.to_account_infos());
                account_infos.extend(self.lp_mint.to_account_infos());
                account_infos.extend(self.creator_token_0.to_account_infos());
                account_infos.extend(self.creator_token_1.to_account_infos());
                account_infos.extend(self.creator_lp_token.to_account_infos());
                account_infos.extend(self.lp_vault.to_account_infos());
                account_infos.extend(self.token_0_vault.to_account_infos());
                account_infos.extend(self.token_1_vault.to_account_infos());
                account_infos.extend(self.create_pool_fee.to_account_infos());
                account_infos.extend(self.observation_state.to_account_infos());
                account_infos.extend(self.token_program.to_account_infos());
                account_infos.extend(self.token_0_program.to_account_infos());
                account_infos.extend(self.token_1_program.to_account_infos());
                account_infos.extend(self.associated_token_program.to_account_infos());
                account_infos.extend(self.system_program.to_account_infos());
                account_infos.extend(self.rent.to_account_infos());
                account_infos.extend(self.compression_config.to_account_infos());
                account_infos.extend(self.rent_recipient.to_account_infos());
                account_infos
                    .extend(
                        self.compressed_token_program_cpi_authority.to_account_infos(),
                    );
                account_infos.extend(self.compressed_token_program.to_account_infos());
                account_infos.extend(self.ctoken_config_account.to_account_infos());
                account_infos.extend(self.ctoken_rent_recipient.to_account_infos());
                account_infos
                    .extend(self.compressed_token_0_pool_pda.to_account_infos());
                account_infos
                    .extend(self.compressed_token_1_pool_pda.to_account_infos());
                account_infos
            }
        }
        #[automatically_derived]
        impl<'info> anchor_lang::ToAccountMetas for Initialize<'info> {
            fn to_account_metas(
                &self,
                is_signer: Option<bool>,
            ) -> Vec<anchor_lang::solana_program::instruction::AccountMeta> {
                let mut account_metas = ::alloc::vec::Vec::new();
                account_metas.extend(self.creator.to_account_metas(None));
                account_metas.extend(self.amm_config.to_account_metas(None));
                account_metas.extend(self.authority.to_account_metas(None));
                account_metas.extend(self.pool_state.to_account_metas(None));
                account_metas.extend(self.token_0_mint.to_account_metas(None));
                account_metas.extend(self.token_1_mint.to_account_metas(None));
                account_metas.extend(self.lp_mint_signer.to_account_metas(None));
                account_metas.extend(self.lp_mint.to_account_metas(None));
                account_metas.extend(self.creator_token_0.to_account_metas(None));
                account_metas.extend(self.creator_token_1.to_account_metas(None));
                account_metas.extend(self.creator_lp_token.to_account_metas(None));
                account_metas.extend(self.lp_vault.to_account_metas(None));
                account_metas.extend(self.token_0_vault.to_account_metas(None));
                account_metas.extend(self.token_1_vault.to_account_metas(None));
                account_metas.extend(self.create_pool_fee.to_account_metas(None));
                account_metas.extend(self.observation_state.to_account_metas(None));
                account_metas.extend(self.token_program.to_account_metas(None));
                account_metas.extend(self.token_0_program.to_account_metas(None));
                account_metas.extend(self.token_1_program.to_account_metas(None));
                account_metas
                    .extend(self.associated_token_program.to_account_metas(None));
                account_metas.extend(self.system_program.to_account_metas(None));
                account_metas.extend(self.rent.to_account_metas(None));
                account_metas.extend(self.compression_config.to_account_metas(None));
                account_metas.extend(self.rent_recipient.to_account_metas(None));
                account_metas
                    .extend(
                        self
                            .compressed_token_program_cpi_authority
                            .to_account_metas(None),
                    );
                account_metas
                    .extend(self.compressed_token_program.to_account_metas(None));
                account_metas.extend(self.ctoken_config_account.to_account_metas(None));
                account_metas.extend(self.ctoken_rent_recipient.to_account_metas(None));
                account_metas
                    .extend(self.compressed_token_0_pool_pda.to_account_metas(None));
                account_metas
                    .extend(self.compressed_token_1_pool_pda.to_account_metas(None));
                account_metas
            }
        }
        #[automatically_derived]
        impl<'info> anchor_lang::AccountsFinalize<'info, InitializeBumps>
        for Initialize<'info>
        where
            'info: 'info,
        {
            fn finalize(
                &mut self,
                program_id: &anchor_lang::solana_program::pubkey::Pubkey,
                _remaining: &[anchor_lang::solana_program::account_info::AccountInfo<
                    'info,
                >],
                _ix_data: &[u8],
                _bumps: &InitializeBumps,
            ) -> anchor_lang::Result<()> {
                anchor_lang::AccountsFinalize::finalize(
                        &mut self.amm_config,
                        program_id,
                        _remaining,
                        _ix_data,
                        _bumps,
                    )
                    .map_err(|e| e.with_account_name("amm_config"))?;
                anchor_lang::AccountsFinalize::finalize(
                        &mut self.token_0_mint,
                        program_id,
                        _remaining,
                        _ix_data,
                        _bumps,
                    )
                    .map_err(|e| e.with_account_name("token_0_mint"))?;
                anchor_lang::AccountsFinalize::finalize(
                        &mut self.token_1_mint,
                        program_id,
                        _remaining,
                        _ix_data,
                        _bumps,
                    )
                    .map_err(|e| e.with_account_name("token_1_mint"))?;
                anchor_lang::AccountsFinalize::finalize(
                        &mut self.creator_token_0,
                        program_id,
                        _remaining,
                        _ix_data,
                        _bumps,
                    )
                    .map_err(|e| e.with_account_name("creator_token_0"))?;
                anchor_lang::AccountsFinalize::finalize(
                        &mut self.creator_token_1,
                        program_id,
                        _remaining,
                        _ix_data,
                        _bumps,
                    )
                    .map_err(|e| e.with_account_name("creator_token_1"))?;
                anchor_lang::AccountsFinalize::finalize(
                        &mut self.create_pool_fee,
                        program_id,
                        _remaining,
                        _ix_data,
                        _bumps,
                    )
                    .map_err(|e| e.with_account_name("create_pool_fee"))?;
                anchor_lang::AccountsFinalize::finalize(
                        &mut self.token_program,
                        program_id,
                        _remaining,
                        _ix_data,
                        _bumps,
                    )
                    .map_err(|e| e.with_account_name("token_program"))?;
                anchor_lang::AccountsFinalize::finalize(
                        &mut self.token_0_program,
                        program_id,
                        _remaining,
                        _ix_data,
                        _bumps,
                    )
                    .map_err(|e| e.with_account_name("token_0_program"))?;
                anchor_lang::AccountsFinalize::finalize(
                        &mut self.token_1_program,
                        program_id,
                        _remaining,
                        _ix_data,
                        _bumps,
                    )
                    .map_err(|e| e.with_account_name("token_1_program"))?;
                anchor_lang::AccountsFinalize::finalize(
                        &mut self.associated_token_program,
                        program_id,
                        _remaining,
                        _ix_data,
                        _bumps,
                    )
                    .map_err(|e| e.with_account_name("associated_token_program"))?;
                anchor_lang::AccountsFinalize::finalize(
                        &mut self.system_program,
                        program_id,
                        _remaining,
                        _ix_data,
                        _bumps,
                    )
                    .map_err(|e| e.with_account_name("system_program"))?;
                anchor_lang::AccountsFinalize::finalize(
                        &mut self.rent,
                        program_id,
                        _remaining,
                        _ix_data,
                        _bumps,
                    )
                    .map_err(|e| e.with_account_name("rent"))?;
                {
                    let mut __ix_data = _ix_data;
                    struct __Args {
                        init_amount_0: u64,
                        init_amount_1: u64,
                        open_time: u64,
                        compression_params: InitializeCompressionParams,
                    }
                    impl borsh::ser::BorshSerialize for __Args
                    where
                        u64: borsh::ser::BorshSerialize,
                        u64: borsh::ser::BorshSerialize,
                        u64: borsh::ser::BorshSerialize,
                        InitializeCompressionParams: borsh::ser::BorshSerialize,
                    {
                        fn serialize<W: borsh::maybestd::io::Write>(
                            &self,
                            writer: &mut W,
                        ) -> ::core::result::Result<(), borsh::maybestd::io::Error> {
                            borsh::BorshSerialize::serialize(
                                &self.init_amount_0,
                                writer,
                            )?;
                            borsh::BorshSerialize::serialize(
                                &self.init_amount_1,
                                writer,
                            )?;
                            borsh::BorshSerialize::serialize(&self.open_time, writer)?;
                            borsh::BorshSerialize::serialize(
                                &self.compression_params,
                                writer,
                            )?;
                            Ok(())
                        }
                    }
                    impl anchor_lang::idl::build::IdlBuild for __Args {
                        fn create_type() -> Option<anchor_lang::idl::types::IdlTypeDef> {
                            Some(anchor_lang::idl::types::IdlTypeDef {
                                name: Self::get_full_path(),
                                docs: ::alloc::vec::Vec::new(),
                                serialization: anchor_lang::idl::types::IdlSerialization::default(),
                                repr: None,
                                generics: ::alloc::vec::Vec::new(),
                                ty: anchor_lang::idl::types::IdlTypeDefTy::Struct {
                                    fields: Some(
                                        anchor_lang::idl::types::IdlDefinedFields::Named(
                                            <[_]>::into_vec(
                                                ::alloc::boxed::box_new([
                                                    anchor_lang::idl::types::IdlField {
                                                        name: "init_amount_0".into(),
                                                        docs: ::alloc::vec::Vec::new(),
                                                        ty: anchor_lang::idl::types::IdlType::U64,
                                                    },
                                                    anchor_lang::idl::types::IdlField {
                                                        name: "init_amount_1".into(),
                                                        docs: ::alloc::vec::Vec::new(),
                                                        ty: anchor_lang::idl::types::IdlType::U64,
                                                    },
                                                    anchor_lang::idl::types::IdlField {
                                                        name: "open_time".into(),
                                                        docs: ::alloc::vec::Vec::new(),
                                                        ty: anchor_lang::idl::types::IdlType::U64,
                                                    },
                                                    anchor_lang::idl::types::IdlField {
                                                        name: "compression_params".into(),
                                                        docs: ::alloc::vec::Vec::new(),
                                                        ty: anchor_lang::idl::types::IdlType::Defined {
                                                            name: <InitializeCompressionParams>::get_full_path(),
                                                            generics: ::alloc::vec::Vec::new(),
                                                        },
                                                    },
                                                ]),
                                            ),
                                        ),
                                    ),
                                },
                            })
                        }
                        fn insert_types(
                            types: &mut std::collections::BTreeMap<
                                String,
                                anchor_lang::idl::types::IdlTypeDef,
                            >,
                        ) {
                            if let Some(ty) = <InitializeCompressionParams>::create_type() {
                                types
                                    .insert(<InitializeCompressionParams>::get_full_path(), ty);
                                <InitializeCompressionParams>::insert_types(types);
                            }
                        }
                        fn get_full_path() -> String {
                            ::alloc::__export::must_use({
                                ::alloc::fmt::format(
                                    format_args!(
                                        "{0}::{1}",
                                        "raydium_cp_swap::instructions::initialize",
                                        "__Args",
                                    ),
                                )
                            })
                        }
                    }
                    impl borsh::de::BorshDeserialize for __Args
                    where
                        u64: borsh::BorshDeserialize,
                        u64: borsh::BorshDeserialize,
                        u64: borsh::BorshDeserialize,
                        InitializeCompressionParams: borsh::BorshDeserialize,
                    {
                        fn deserialize_reader<R: borsh::maybestd::io::Read>(
                            reader: &mut R,
                        ) -> ::core::result::Result<Self, borsh::maybestd::io::Error> {
                            Ok(Self {
                                init_amount_0: borsh::BorshDeserialize::deserialize_reader(
                                    reader,
                                )?,
                                init_amount_1: borsh::BorshDeserialize::deserialize_reader(
                                    reader,
                                )?,
                                open_time: borsh::BorshDeserialize::deserialize_reader(
                                    reader,
                                )?,
                                compression_params: borsh::BorshDeserialize::deserialize_reader(
                                    reader,
                                )?,
                            })
                        }
                    }
                    let __args: __Args = __Args::deserialize(&mut __ix_data)
                        .map_err(|_| {
                            anchor_lang::error::ErrorCode::InstructionDidNotDeserialize
                        })?;
                    let init_amount_0 = __args.init_amount_0;
                    let init_amount_1 = __args.init_amount_1;
                    let open_time = __args.open_time;
                    let compression_params = __args.compression_params;
                    let _ = __args;
                    let cpi_accounts = light_sdk::cpi::CpiAccountsSmall::new_with_config(
                        &self.creator,
                        _remaining,
                        light_sdk_types::CpiAccountsConfig::new_with_cpi_context(
                            crate::LIGHT_CPI_SIGNER,
                        ),
                    );
                    let compression_config_data = light_sdk::compressible::CompressibleConfig::load_checked(
                        &self.compression_config,
                        &crate::ID,
                    )?;
                    let address_space = compression_config_data.address_space;
                    let mut all_compressed_infos = Vec::with_capacity(2u8 as usize);
                    let pool_state_tree_info = compression_params.pool_address_tree_info;
                    let pool_state_new_address_params = pool_state_tree_info
                        .into_new_address_params_assigned_packed(
                            self.pool_state.key().to_bytes(),
                            true,
                            Some(0u8),
                        );
                    let pool_state_compressed_address = light_compressed_account::address::derive_address(
                        &self.pool_state.key().to_bytes(),
                        &cpi_accounts
                            .get_tree_address(
                                pool_state_new_address_params
                                    .address_merkle_tree_account_index,
                            )
                            .unwrap()
                            .key
                            .to_bytes(),
                        &crate::ID.to_bytes(),
                    );
                    let pool_state_compressed_infos = if false {
                        light_sdk::compressible::prepare_accounts_for_compression_on_init::<
                            PoolState,
                        >(
                            &[&mut *self.pool_state],
                            &[pool_state_compressed_address],
                            &[pool_state_new_address_params],
                            &[0],
                            &cpi_accounts,
                        )?
                    } else {
                        light_sdk::compressible::prepare_empty_compressed_accounts_on_init::<
                            PoolState,
                        >(
                            &mut [&mut *self.pool_state],
                            &[pool_state_compressed_address],
                            &[pool_state_new_address_params],
                            &[0],
                            &cpi_accounts,
                        )?
                    };
                    all_compressed_infos.extend(pool_state_compressed_infos);
                    let observation_state_tree_info = compression_params
                        .observation_address_tree_info;
                    let observation_state_new_address_params = observation_state_tree_info
                        .into_new_address_params_assigned_packed(
                            self.observation_state.key().to_bytes(),
                            true,
                            Some(1u8),
                        );
                    let observation_state_compressed_address = light_compressed_account::address::derive_address(
                        &self.observation_state.key().to_bytes(),
                        &cpi_accounts
                            .get_tree_address(
                                observation_state_new_address_params
                                    .address_merkle_tree_account_index,
                            )
                            .unwrap()
                            .key
                            .to_bytes(),
                        &crate::ID.to_bytes(),
                    );
                    let observation_state_compressed_infos = if false {
                        light_sdk::compressible::prepare_accounts_for_compression_on_init::<
                            ObservationState,
                        >(
                            &[&mut *self.observation_state],
                            &[observation_state_compressed_address],
                            &[observation_state_new_address_params],
                            &[0],
                            &cpi_accounts,
                        )?
                    } else {
                        light_sdk::compressible::prepare_empty_compressed_accounts_on_init::<
                            ObservationState,
                        >(
                            &mut [&mut *self.observation_state],
                            &[observation_state_compressed_address],
                            &[observation_state_new_address_params],
                            &[0],
                            &cpi_accounts,
                        )?
                    };
                    all_compressed_infos.extend(observation_state_compressed_infos);
                    let cpi_inputs = light_sdk::cpi::CpiInputs::new_first_cpi(
                        all_compressed_infos,
                        <[_]>::into_vec(
                            ::alloc::boxed::box_new([
                                pool_state_new_address_params,
                                observation_state_new_address_params,
                            ]),
                        ),
                    );
                    let cpi_context = cpi_accounts.cpi_context().unwrap();
                    let cpi_context_accounts = light_sdk_types::cpi_context_write::CpiContextWriteAccounts {
                        fee_payer: cpi_accounts.fee_payer(),
                        authority: cpi_accounts.authority().unwrap(),
                        cpi_context,
                        cpi_signer: crate::LIGHT_CPI_SIGNER,
                    };
                    cpi_inputs
                        .invoke_light_system_program_cpi_context(cpi_context_accounts)?;
                    let __mint_actions = self.lp_mint.take_actions();
                    if !__mint_actions.is_empty() {
                        let compressed_mint_seed = b"compressed_mint";
                        let mint_signer_key = self
                            .lp_mint
                            .mint_signer
                            .as_ref()
                            .map(|a| a.key())
                            .expect("mint_signer is required for CMint");
                        let (expected_mint_address, mint_bump) = anchor_lang::solana_program::pubkey::Pubkey::find_program_address(
                            &[compressed_mint_seed.as_ref(), mint_signer_key.as_ref()],
                            &self.compressed_token_program.key(),
                        );
                        if self.lp_mint.key() != expected_mint_address {
                            {
                                ::core::panicking::panic_fmt(
                                    format_args!(
                                        "CMint address mismatch: expected {0:?}, got {1:?}",
                                        expected_mint_address,
                                        self.lp_mint.key(),
                                    ),
                                );
                            };
                        }
                        let output_state_tree_index = 0;
                        let __address_tree_info = compression_params
                            .lp_mint_address_tree_info;
                        let address_tree_idx = __address_tree_info
                            .address_merkle_tree_pubkey_index;
                        let address_queue_idx = __address_tree_info
                            .address_queue_pubkey_index;
                        let root_index = __address_tree_info.root_index;
                        let output_state_queue = *cpi_accounts
                            .tree_accounts()
                            .unwrap()[output_state_tree_index as usize]
                            .key;
                        let address_tree_pubkey = *cpi_accounts
                            .tree_accounts()
                            .unwrap()[address_tree_idx as usize]
                            .key;
                        use light_compressed_token_sdk::instructions::create_compressed_mint::instruction::derive_compressed_mint_from_spl_mint;
                        let mint_compressed_address = derive_compressed_mint_from_spl_mint(
                            &self.lp_mint.key(),
                            &address_tree_pubkey,
                        );
                        let metadata_extensions: Option<
                            Vec<
                                light_ctoken_types::instructions::extensions::ExtensionInstructionData,
                            >,
                        > = {
                            let metadata_name = compression_params.name;
                            let metadata_symbol = compression_params.symbol;
                            let metadata_uri = compression_params.uri;
                            let metadata_additional = None;
                            if metadata_name.len() > 32 {
                                {
                                    ::core::panicking::panic_fmt(
                                        format_args!(
                                            "CMint metadata name exceeds size limit: {0} bytes (max: 32 bytes).",
                                            metadata_name.len(),
                                        ),
                                    );
                                };
                            }
                            if metadata_symbol.len() > 10 {
                                {
                                    ::core::panicking::panic_fmt(
                                        format_args!(
                                            "CMint metadata symbol exceeds size limit: {0} bytes (max: 10 bytes).",
                                            metadata_symbol.len(),
                                        ),
                                    );
                                };
                            }
                            if metadata_uri.len() > 200 {
                                {
                                    ::core::panicking::panic_fmt(
                                        format_args!(
                                            "CMint metadata uri exceeds size limit: {0} bytes (max: 200 bytes).",
                                            metadata_uri.len(),
                                        ),
                                    );
                                };
                            }
                            let token_metadata = light_ctoken_types::instructions::extensions::TokenMetadataInstructionData {
                                update_authority: Some(
                                    {
                                        let __auth = &self.authority;
                                        __auth.key()
                                    }
                                        .into(),
                                ),
                                name: metadata_name,
                                symbol: metadata_symbol,
                                uri: metadata_uri,
                                additional_metadata: metadata_additional,
                            };
                            Some(
                                <[_]>::into_vec(
                                    ::alloc::boxed::box_new([
                                        light_ctoken_types::instructions::extensions::ExtensionInstructionData::TokenMetadata(
                                            token_metadata,
                                        ),
                                    ]),
                                ),
                            )
                        };
                        let compressed_mint_with_context = light_ctoken_types::instructions::mint_action::CompressedMintWithContext::new_with_extensions(
                            mint_compressed_address,
                            root_index,
                            self.lp_mint.decimals.unwrap_or(9),
                            Some(
                                {
                                    let __auth = &self.authority;
                                    __auth.key()
                                }
                                    .into(),
                            ),
                            None,
                            self.lp_mint.key().into(),
                            metadata_extensions,
                        );
                        let actions: Vec<
                            light_compressed_token_sdk::instructions::MintActionType,
                        > = __mint_actions
                            .iter()
                            .map(|a| light_compressed_token_sdk::instructions::MintActionType::MintToCToken {
                                account: *a.recipient.key,
                                amount: a.amount,
                            })
                            .collect();
                        let mint_signer = self
                            .lp_mint
                            .mint_signer
                            .as_ref()
                            .map(|a| a.key())
                            .expect("mint_signer is required for cmint mint_seed");
                        let inputs = light_compressed_token_sdk::instructions::CreateMintInputs {
                            compressed_mint_inputs: compressed_mint_with_context,
                            mint_seed: mint_signer,
                            mint_bump,
                            authority: {
                                let __auth = &self.authority;
                                __auth.key()
                            }
                                .into(),
                            payer: {
                                let __payer = &self.creator;
                                __payer.key()
                            },
                            proof: compression_params
                                .proof
                                .0
                                .map(|p| light_compressed_token_sdk::CompressedProof::from(
                                    p,
                                )),
                            address_tree: address_tree_pubkey,
                            output_queue: output_state_queue,
                            actions,
                        };
                        let mint_action_instruction: anchor_lang::solana_program::instruction::Instruction = light_compressed_token_sdk::instructions::create_mint_action_cpi(
                                light_compressed_token_sdk::instructions::MintActionInputs::new_create_mint(
                                    inputs,
                                ),
                                Some(
                                    light_ctoken_types::instructions::mint_action::CpiContext::last_cpi_create_mint(
                                        address_tree_idx,
                                        output_state_tree_index,
                                        2u8,
                                    ),
                                ),
                                Some(cpi_accounts.cpi_context().unwrap().key()),
                            )
                            .map_err(|_| {
                                anchor_lang::error::ErrorCode::AccountDidNotSerialize
                            })?;
                        let mut account_infos = cpi_accounts.to_account_infos();
                        account_infos
                            .extend([
                                self
                                    .compressed_token_program_cpi_authority
                                    .to_account_info(),
                                self.compressed_token_program.to_account_info(),
                                self.authority.to_account_info(),
                            ]);
                        if let Some(mint_signer) = &self.lp_mint.mint_signer {
                            account_infos.push(mint_signer.clone());
                        } else {
                            {
                                ::core::panicking::panic_fmt(
                                    format_args!("mint_signer is required"),
                                );
                            };
                        }
                        account_infos.push(self.creator.to_account_info());
                        for action in __mint_actions.iter() {
                            let recipient_info = &action.recipient;
                            let recipient_key = recipient_info.key;
                            let already_added = account_infos
                                .iter()
                                .any(|ai| ai.key == recipient_key);
                            if !already_added {
                                account_infos.push(recipient_info.clone());
                            }
                        }
                        let mint_signer_bump = _bumps.lp_mint_signer;
                        let mint_bump_array = [mint_signer_bump];
                        let mut mint_signer_seeds_vec: Vec<&[u8]> = Vec::new();
                        if let Some(seeds) = &self.lp_mint.mint_signer_seeds {
                            for seed in seeds.iter() {
                                mint_signer_seeds_vec.push(seed.as_slice());
                            }
                            mint_signer_seeds_vec.push(&mint_bump_array);
                        }
                        let mut auth_seeds_vec: Vec<&[u8]> = Vec::new();
                        let has_any_cpda = true;
                        let auth_bump_array;
                        if has_any_cpda {
                            let auth_bump = _bumps.authority;
                            auth_bump_array = [auth_bump];
                            let mut auth_seeds_for_cpi: Vec<&[u8]> = <[_]>::into_vec(
                                ::alloc::boxed::box_new([
                                    crate::AUTH_SEED.as_bytes().as_ref(),
                                ]),
                            );
                            auth_seeds_for_cpi.push(&auth_bump_array);
                            auth_seeds_vec = auth_seeds_for_cpi;
                        } else if let Some(seeds) = &self.lp_mint.program_authority_seeds
                        {
                            auth_bump_array = [
                                self
                                    .lp_mint
                                    .program_authority_bump
                                    .unwrap_or_else(|| {
                                        ::core::panicking::panic_fmt(
                                            format_args!("program_authority_bump is required"),
                                        );
                                    }),
                            ];
                            for seed in seeds.iter() {
                                auth_seeds_vec.push(seed.as_slice());
                            }
                            auth_seeds_vec.push(&auth_bump_array);
                        }
                        match (
                            mint_signer_seeds_vec.is_empty(),
                            auth_seeds_vec.is_empty(),
                        ) {
                            (false, false) => {
                                anchor_lang::solana_program::program::invoke_signed(
                                    &mint_action_instruction,
                                    &account_infos,
                                    &[
                                        mint_signer_seeds_vec.as_slice(),
                                        auth_seeds_vec.as_slice(),
                                    ],
                                )?;
                            }
                            (false, true) => {
                                anchor_lang::solana_program::program::invoke_signed(
                                    &mint_action_instruction,
                                    &account_infos,
                                    &[mint_signer_seeds_vec.as_slice()],
                                )?;
                            }
                            (true, false) => {
                                anchor_lang::solana_program::program::invoke_signed(
                                    &mint_action_instruction,
                                    &account_infos,
                                    &[auth_seeds_vec.as_slice()],
                                )?;
                            }
                            (true, true) => {
                                anchor_lang::solana_program::program::invoke_signed(
                                    &mint_action_instruction,
                                    &account_infos,
                                    &[],
                                )?;
                            }
                        }
                    }
                }
                Ok(())
            }
        }
        #[automatically_derived]
        impl<'info> anchor_lang::AccountsExit<'info> for Initialize<'info>
        where
            'info: 'info,
        {
            fn exit(
                &self,
                program_id: &anchor_lang::solana_program::pubkey::Pubkey,
            ) -> anchor_lang::Result<()> {
                anchor_lang::AccountsExit::exit(&self.creator, program_id)
                    .map_err(|e| e.with_account_name("creator"))?;
                anchor_lang::AccountsExit::exit(&self.pool_state, program_id)
                    .map_err(|e| e.with_account_name("pool_state"))?;
                anchor_lang::AccountsExit::exit(&self.creator_token_0, program_id)
                    .map_err(|e| e.with_account_name("creator_token_0"))?;
                anchor_lang::AccountsExit::exit(&self.creator_token_1, program_id)
                    .map_err(|e| e.with_account_name("creator_token_1"))?;
                anchor_lang::AccountsExit::exit(&self.creator_lp_token, program_id)
                    .map_err(|e| e.with_account_name("creator_lp_token"))?;
                anchor_lang::AccountsExit::exit(&self.lp_vault, program_id)
                    .map_err(|e| e.with_account_name("lp_vault"))?;
                anchor_lang::AccountsExit::exit(&self.token_0_vault, program_id)
                    .map_err(|e| e.with_account_name("token_0_vault"))?;
                anchor_lang::AccountsExit::exit(&self.token_1_vault, program_id)
                    .map_err(|e| e.with_account_name("token_1_vault"))?;
                anchor_lang::AccountsExit::exit(&self.create_pool_fee, program_id)
                    .map_err(|e| e.with_account_name("create_pool_fee"))?;
                anchor_lang::AccountsExit::exit(&self.observation_state, program_id)
                    .map_err(|e| e.with_account_name("observation_state"))?;
                anchor_lang::AccountsExit::exit(&self.rent_recipient, program_id)
                    .map_err(|e| e.with_account_name("rent_recipient"))?;
                anchor_lang::AccountsExit::exit(&self.ctoken_rent_recipient, program_id)
                    .map_err(|e| e.with_account_name("ctoken_rent_recipient"))?;
                anchor_lang::AccountsExit::exit(
                        &self.compressed_token_0_pool_pda,
                        program_id,
                    )
                    .map_err(|e| e.with_account_name("compressed_token_0_pool_pda"))?;
                anchor_lang::AccountsExit::exit(
                        &self.compressed_token_1_pool_pda,
                        program_id,
                    )
                    .map_err(|e| e.with_account_name("compressed_token_1_pool_pda"))?;
                Ok(())
            }
        }
        pub struct InitializeBumps {
            pub authority: u8,
            pub pool_state: u8,
            pub lp_mint_signer: u8,
            pub lp_vault: u8,
            pub token_0_vault: u8,
            pub token_1_vault: u8,
            pub observation_state: u8,
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for InitializeBumps {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                let names: &'static _ = &[
                    "authority",
                    "pool_state",
                    "lp_mint_signer",
                    "lp_vault",
                    "token_0_vault",
                    "token_1_vault",
                    "observation_state",
                ];
                let values: &[&dyn ::core::fmt::Debug] = &[
                    &self.authority,
                    &self.pool_state,
                    &self.lp_mint_signer,
                    &self.lp_vault,
                    &self.token_0_vault,
                    &self.token_1_vault,
                    &&self.observation_state,
                ];
                ::core::fmt::Formatter::debug_struct_fields_finish(
                    f,
                    "InitializeBumps",
                    names,
                    values,
                )
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for InitializeBumps {
            #[inline]
            fn clone(&self) -> InitializeBumps {
                InitializeBumps {
                    authority: ::core::clone::Clone::clone(&self.authority),
                    pool_state: ::core::clone::Clone::clone(&self.pool_state),
                    lp_mint_signer: ::core::clone::Clone::clone(&self.lp_mint_signer),
                    lp_vault: ::core::clone::Clone::clone(&self.lp_vault),
                    token_0_vault: ::core::clone::Clone::clone(&self.token_0_vault),
                    token_1_vault: ::core::clone::Clone::clone(&self.token_1_vault),
                    observation_state: ::core::clone::Clone::clone(
                        &self.observation_state,
                    ),
                }
            }
        }
        impl Default for InitializeBumps {
            fn default() -> Self {
                InitializeBumps {
                    authority: u8::MAX,
                    pool_state: u8::MAX,
                    lp_mint_signer: u8::MAX,
                    lp_vault: u8::MAX,
                    token_0_vault: u8::MAX,
                    token_1_vault: u8::MAX,
                    observation_state: u8::MAX,
                }
            }
        }
        impl<'info> anchor_lang::Bumps for Initialize<'info>
        where
            'info: 'info,
        {
            type Bumps = InitializeBumps;
        }
        /// An internal, Anchor generated module. This is used (as an
        /// implementation detail), to generate a struct for a given
        /// `#[derive(Accounts)]` implementation, where each field is a Pubkey,
        /// instead of an `AccountInfo`. This is useful for clients that want
        /// to generate a list of accounts, without explicitly knowing the
        /// order all the fields should be in.
        ///
        /// To access the struct in this module, one should use the sibling
        /// `accounts` module (also generated), which re-exports this.
        pub(crate) mod __client_accounts_initialize {
            use super::*;
            use anchor_lang::prelude::borsh;
            /// Generated client accounts for [`Initialize`].
            pub struct Initialize {
                ///Address paying to create the pool. Can be anyone
                pub creator: Pubkey,
                ///Which config the pool belongs to.
                pub amm_config: Pubkey,
                ///pool vault and lp mint authority
                pub authority: Pubkey,
                pub pool_state: Pubkey,
                ///Token_0 mint, the key must smaller than token_1 mint.
                pub token_0_mint: Pubkey,
                ///Token_1 mint, the key must grater then token_0 mint.
                pub token_1_mint: Pubkey,
                ///Signer pda used to derive lp_mint and its compressed address.
                pub lp_mint_signer: Pubkey,
                ///Compressed mint for LP tokens
                pub lp_mint: Pubkey,
                ///payer token0 account
                pub creator_token_0: Pubkey,
                ///creator token1 account
                pub creator_token_1: Pubkey,
                pub creator_lp_token: Pubkey,
                pub lp_vault: Pubkey,
                pub token_0_vault: Pubkey,
                pub token_1_vault: Pubkey,
                ///create pool fee account
                pub create_pool_fee: Pubkey,
                ///an account to store oracle observations
                pub observation_state: Pubkey,
                ///Program to create mint account and mint tokens
                pub token_program: Pubkey,
                ///Spl token program or token program 2022
                pub token_0_program: Pubkey,
                ///Spl token program or token program 2022
                pub token_1_program: Pubkey,
                ///Program to create an ATA for receiving position NFT
                pub associated_token_program: Pubkey,
                ///To create a new program account
                pub system_program: Pubkey,
                ///Sysvar for program account
                pub rent: Pubkey,
                pub compression_config: Pubkey,
                pub rent_recipient: Pubkey,
                pub compressed_token_program_cpi_authority: Pubkey,
                pub compressed_token_program: Pubkey,
                pub ctoken_config_account: Pubkey,
                pub ctoken_rent_recipient: Pubkey,
                pub compressed_token_0_pool_pda: Pubkey,
                pub compressed_token_1_pool_pda: Pubkey,
            }
            impl borsh::ser::BorshSerialize for Initialize
            where
                Pubkey: borsh::ser::BorshSerialize,
                Pubkey: borsh::ser::BorshSerialize,
                Pubkey: borsh::ser::BorshSerialize,
                Pubkey: borsh::ser::BorshSerialize,
                Pubkey: borsh::ser::BorshSerialize,
                Pubkey: borsh::ser::BorshSerialize,
                Pubkey: borsh::ser::BorshSerialize,
                Pubkey: borsh::ser::BorshSerialize,
                Pubkey: borsh::ser::BorshSerialize,
                Pubkey: borsh::ser::BorshSerialize,
                Pubkey: borsh::ser::BorshSerialize,
                Pubkey: borsh::ser::BorshSerialize,
                Pubkey: borsh::ser::BorshSerialize,
                Pubkey: borsh::ser::BorshSerialize,
                Pubkey: borsh::ser::BorshSerialize,
                Pubkey: borsh::ser::BorshSerialize,
                Pubkey: borsh::ser::BorshSerialize,
                Pubkey: borsh::ser::BorshSerialize,
                Pubkey: borsh::ser::BorshSerialize,
                Pubkey: borsh::ser::BorshSerialize,
                Pubkey: borsh::ser::BorshSerialize,
                Pubkey: borsh::ser::BorshSerialize,
                Pubkey: borsh::ser::BorshSerialize,
                Pubkey: borsh::ser::BorshSerialize,
                Pubkey: borsh::ser::BorshSerialize,
                Pubkey: borsh::ser::BorshSerialize,
                Pubkey: borsh::ser::BorshSerialize,
                Pubkey: borsh::ser::BorshSerialize,
                Pubkey: borsh::ser::BorshSerialize,
                Pubkey: borsh::ser::BorshSerialize,
            {
                fn serialize<W: borsh::maybestd::io::Write>(
                    &self,
                    writer: &mut W,
                ) -> ::core::result::Result<(), borsh::maybestd::io::Error> {
                    borsh::BorshSerialize::serialize(&self.creator, writer)?;
                    borsh::BorshSerialize::serialize(&self.amm_config, writer)?;
                    borsh::BorshSerialize::serialize(&self.authority, writer)?;
                    borsh::BorshSerialize::serialize(&self.pool_state, writer)?;
                    borsh::BorshSerialize::serialize(&self.token_0_mint, writer)?;
                    borsh::BorshSerialize::serialize(&self.token_1_mint, writer)?;
                    borsh::BorshSerialize::serialize(&self.lp_mint_signer, writer)?;
                    borsh::BorshSerialize::serialize(&self.lp_mint, writer)?;
                    borsh::BorshSerialize::serialize(&self.creator_token_0, writer)?;
                    borsh::BorshSerialize::serialize(&self.creator_token_1, writer)?;
                    borsh::BorshSerialize::serialize(&self.creator_lp_token, writer)?;
                    borsh::BorshSerialize::serialize(&self.lp_vault, writer)?;
                    borsh::BorshSerialize::serialize(&self.token_0_vault, writer)?;
                    borsh::BorshSerialize::serialize(&self.token_1_vault, writer)?;
                    borsh::BorshSerialize::serialize(&self.create_pool_fee, writer)?;
                    borsh::BorshSerialize::serialize(&self.observation_state, writer)?;
                    borsh::BorshSerialize::serialize(&self.token_program, writer)?;
                    borsh::BorshSerialize::serialize(&self.token_0_program, writer)?;
                    borsh::BorshSerialize::serialize(&self.token_1_program, writer)?;
                    borsh::BorshSerialize::serialize(
                        &self.associated_token_program,
                        writer,
                    )?;
                    borsh::BorshSerialize::serialize(&self.system_program, writer)?;
                    borsh::BorshSerialize::serialize(&self.rent, writer)?;
                    borsh::BorshSerialize::serialize(&self.compression_config, writer)?;
                    borsh::BorshSerialize::serialize(&self.rent_recipient, writer)?;
                    borsh::BorshSerialize::serialize(
                        &self.compressed_token_program_cpi_authority,
                        writer,
                    )?;
                    borsh::BorshSerialize::serialize(
                        &self.compressed_token_program,
                        writer,
                    )?;
                    borsh::BorshSerialize::serialize(
                        &self.ctoken_config_account,
                        writer,
                    )?;
                    borsh::BorshSerialize::serialize(
                        &self.ctoken_rent_recipient,
                        writer,
                    )?;
                    borsh::BorshSerialize::serialize(
                        &self.compressed_token_0_pool_pda,
                        writer,
                    )?;
                    borsh::BorshSerialize::serialize(
                        &self.compressed_token_1_pool_pda,
                        writer,
                    )?;
                    Ok(())
                }
            }
            impl anchor_lang::idl::build::IdlBuild for Initialize {
                fn create_type() -> Option<anchor_lang::idl::types::IdlTypeDef> {
                    Some(anchor_lang::idl::types::IdlTypeDef {
                        name: Self::get_full_path(),
                        docs: <[_]>::into_vec(
                            ::alloc::boxed::box_new([
                                "Generated client accounts for [`Initialize`].".into(),
                            ]),
                        ),
                        serialization: anchor_lang::idl::types::IdlSerialization::default(),
                        repr: None,
                        generics: ::alloc::vec::Vec::new(),
                        ty: anchor_lang::idl::types::IdlTypeDefTy::Struct {
                            fields: Some(
                                anchor_lang::idl::types::IdlDefinedFields::Named(
                                    <[_]>::into_vec(
                                        ::alloc::boxed::box_new([
                                            anchor_lang::idl::types::IdlField {
                                                name: "creator".into(),
                                                docs: <[_]>::into_vec(
                                                    ::alloc::boxed::box_new([
                                                        "Address paying to create the pool. Can be anyone".into(),
                                                    ]),
                                                ),
                                                ty: anchor_lang::idl::types::IdlType::Pubkey,
                                            },
                                            anchor_lang::idl::types::IdlField {
                                                name: "amm_config".into(),
                                                docs: <[_]>::into_vec(
                                                    ::alloc::boxed::box_new([
                                                        "Which config the pool belongs to.".into(),
                                                    ]),
                                                ),
                                                ty: anchor_lang::idl::types::IdlType::Pubkey,
                                            },
                                            anchor_lang::idl::types::IdlField {
                                                name: "authority".into(),
                                                docs: <[_]>::into_vec(
                                                    ::alloc::boxed::box_new([
                                                        "pool vault and lp mint authority".into(),
                                                    ]),
                                                ),
                                                ty: anchor_lang::idl::types::IdlType::Pubkey,
                                            },
                                            anchor_lang::idl::types::IdlField {
                                                name: "pool_state".into(),
                                                docs: ::alloc::vec::Vec::new(),
                                                ty: anchor_lang::idl::types::IdlType::Pubkey,
                                            },
                                            anchor_lang::idl::types::IdlField {
                                                name: "token_0_mint".into(),
                                                docs: <[_]>::into_vec(
                                                    ::alloc::boxed::box_new([
                                                        "Token_0 mint, the key must smaller than token_1 mint."
                                                            .into(),
                                                    ]),
                                                ),
                                                ty: anchor_lang::idl::types::IdlType::Pubkey,
                                            },
                                            anchor_lang::idl::types::IdlField {
                                                name: "token_1_mint".into(),
                                                docs: <[_]>::into_vec(
                                                    ::alloc::boxed::box_new([
                                                        "Token_1 mint, the key must grater then token_0 mint."
                                                            .into(),
                                                    ]),
                                                ),
                                                ty: anchor_lang::idl::types::IdlType::Pubkey,
                                            },
                                            anchor_lang::idl::types::IdlField {
                                                name: "lp_mint_signer".into(),
                                                docs: <[_]>::into_vec(
                                                    ::alloc::boxed::box_new([
                                                        "Signer pda used to derive lp_mint and its compressed address."
                                                            .into(),
                                                    ]),
                                                ),
                                                ty: anchor_lang::idl::types::IdlType::Pubkey,
                                            },
                                            anchor_lang::idl::types::IdlField {
                                                name: "lp_mint".into(),
                                                docs: <[_]>::into_vec(
                                                    ::alloc::boxed::box_new([
                                                        "Compressed mint for LP tokens".into(),
                                                    ]),
                                                ),
                                                ty: anchor_lang::idl::types::IdlType::Pubkey,
                                            },
                                            anchor_lang::idl::types::IdlField {
                                                name: "creator_token_0".into(),
                                                docs: <[_]>::into_vec(
                                                    ::alloc::boxed::box_new(["payer token0 account".into()]),
                                                ),
                                                ty: anchor_lang::idl::types::IdlType::Pubkey,
                                            },
                                            anchor_lang::idl::types::IdlField {
                                                name: "creator_token_1".into(),
                                                docs: <[_]>::into_vec(
                                                    ::alloc::boxed::box_new(["creator token1 account".into()]),
                                                ),
                                                ty: anchor_lang::idl::types::IdlType::Pubkey,
                                            },
                                            anchor_lang::idl::types::IdlField {
                                                name: "creator_lp_token".into(),
                                                docs: ::alloc::vec::Vec::new(),
                                                ty: anchor_lang::idl::types::IdlType::Pubkey,
                                            },
                                            anchor_lang::idl::types::IdlField {
                                                name: "lp_vault".into(),
                                                docs: ::alloc::vec::Vec::new(),
                                                ty: anchor_lang::idl::types::IdlType::Pubkey,
                                            },
                                            anchor_lang::idl::types::IdlField {
                                                name: "token_0_vault".into(),
                                                docs: ::alloc::vec::Vec::new(),
                                                ty: anchor_lang::idl::types::IdlType::Pubkey,
                                            },
                                            anchor_lang::idl::types::IdlField {
                                                name: "token_1_vault".into(),
                                                docs: ::alloc::vec::Vec::new(),
                                                ty: anchor_lang::idl::types::IdlType::Pubkey,
                                            },
                                            anchor_lang::idl::types::IdlField {
                                                name: "create_pool_fee".into(),
                                                docs: <[_]>::into_vec(
                                                    ::alloc::boxed::box_new(["create pool fee account".into()]),
                                                ),
                                                ty: anchor_lang::idl::types::IdlType::Pubkey,
                                            },
                                            anchor_lang::idl::types::IdlField {
                                                name: "observation_state".into(),
                                                docs: <[_]>::into_vec(
                                                    ::alloc::boxed::box_new([
                                                        "an account to store oracle observations".into(),
                                                    ]),
                                                ),
                                                ty: anchor_lang::idl::types::IdlType::Pubkey,
                                            },
                                            anchor_lang::idl::types::IdlField {
                                                name: "token_program".into(),
                                                docs: <[_]>::into_vec(
                                                    ::alloc::boxed::box_new([
                                                        "Program to create mint account and mint tokens".into(),
                                                    ]),
                                                ),
                                                ty: anchor_lang::idl::types::IdlType::Pubkey,
                                            },
                                            anchor_lang::idl::types::IdlField {
                                                name: "token_0_program".into(),
                                                docs: <[_]>::into_vec(
                                                    ::alloc::boxed::box_new([
                                                        "Spl token program or token program 2022".into(),
                                                    ]),
                                                ),
                                                ty: anchor_lang::idl::types::IdlType::Pubkey,
                                            },
                                            anchor_lang::idl::types::IdlField {
                                                name: "token_1_program".into(),
                                                docs: <[_]>::into_vec(
                                                    ::alloc::boxed::box_new([
                                                        "Spl token program or token program 2022".into(),
                                                    ]),
                                                ),
                                                ty: anchor_lang::idl::types::IdlType::Pubkey,
                                            },
                                            anchor_lang::idl::types::IdlField {
                                                name: "associated_token_program".into(),
                                                docs: <[_]>::into_vec(
                                                    ::alloc::boxed::box_new([
                                                        "Program to create an ATA for receiving position NFT".into(),
                                                    ]),
                                                ),
                                                ty: anchor_lang::idl::types::IdlType::Pubkey,
                                            },
                                            anchor_lang::idl::types::IdlField {
                                                name: "system_program".into(),
                                                docs: <[_]>::into_vec(
                                                    ::alloc::boxed::box_new([
                                                        "To create a new program account".into(),
                                                    ]),
                                                ),
                                                ty: anchor_lang::idl::types::IdlType::Pubkey,
                                            },
                                            anchor_lang::idl::types::IdlField {
                                                name: "rent".into(),
                                                docs: <[_]>::into_vec(
                                                    ::alloc::boxed::box_new([
                                                        "Sysvar for program account".into(),
                                                    ]),
                                                ),
                                                ty: anchor_lang::idl::types::IdlType::Pubkey,
                                            },
                                            anchor_lang::idl::types::IdlField {
                                                name: "compression_config".into(),
                                                docs: ::alloc::vec::Vec::new(),
                                                ty: anchor_lang::idl::types::IdlType::Pubkey,
                                            },
                                            anchor_lang::idl::types::IdlField {
                                                name: "rent_recipient".into(),
                                                docs: ::alloc::vec::Vec::new(),
                                                ty: anchor_lang::idl::types::IdlType::Pubkey,
                                            },
                                            anchor_lang::idl::types::IdlField {
                                                name: "compressed_token_program_cpi_authority".into(),
                                                docs: ::alloc::vec::Vec::new(),
                                                ty: anchor_lang::idl::types::IdlType::Pubkey,
                                            },
                                            anchor_lang::idl::types::IdlField {
                                                name: "compressed_token_program".into(),
                                                docs: ::alloc::vec::Vec::new(),
                                                ty: anchor_lang::idl::types::IdlType::Pubkey,
                                            },
                                            anchor_lang::idl::types::IdlField {
                                                name: "ctoken_config_account".into(),
                                                docs: ::alloc::vec::Vec::new(),
                                                ty: anchor_lang::idl::types::IdlType::Pubkey,
                                            },
                                            anchor_lang::idl::types::IdlField {
                                                name: "ctoken_rent_recipient".into(),
                                                docs: ::alloc::vec::Vec::new(),
                                                ty: anchor_lang::idl::types::IdlType::Pubkey,
                                            },
                                            anchor_lang::idl::types::IdlField {
                                                name: "compressed_token_0_pool_pda".into(),
                                                docs: ::alloc::vec::Vec::new(),
                                                ty: anchor_lang::idl::types::IdlType::Pubkey,
                                            },
                                            anchor_lang::idl::types::IdlField {
                                                name: "compressed_token_1_pool_pda".into(),
                                                docs: ::alloc::vec::Vec::new(),
                                                ty: anchor_lang::idl::types::IdlType::Pubkey,
                                            },
                                        ]),
                                    ),
                                ),
                            ),
                        },
                    })
                }
                fn insert_types(
                    types: &mut std::collections::BTreeMap<
                        String,
                        anchor_lang::idl::types::IdlTypeDef,
                    >,
                ) {}
                fn get_full_path() -> String {
                    ::alloc::__export::must_use({
                        ::alloc::fmt::format(
                            format_args!(
                                "{0}::{1}",
                                "raydium_cp_swap::instructions::initialize::__client_accounts_initialize",
                                "Initialize",
                            ),
                        )
                    })
                }
            }
            #[automatically_derived]
            impl anchor_lang::ToAccountMetas for Initialize {
                fn to_account_metas(
                    &self,
                    is_signer: Option<bool>,
                ) -> Vec<anchor_lang::solana_program::instruction::AccountMeta> {
                    let mut account_metas = ::alloc::vec::Vec::new();
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new(
                                self.creator,
                                true,
                            ),
                        );
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                                self.amm_config,
                                false,
                            ),
                        );
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                                self.authority,
                                false,
                            ),
                        );
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new(
                                self.pool_state,
                                false,
                            ),
                        );
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                                self.token_0_mint,
                                false,
                            ),
                        );
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                                self.token_1_mint,
                                false,
                            ),
                        );
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                                self.lp_mint_signer,
                                false,
                            ),
                        );
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                                self.lp_mint,
                                false,
                            ),
                        );
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new(
                                self.creator_token_0,
                                false,
                            ),
                        );
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new(
                                self.creator_token_1,
                                false,
                            ),
                        );
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new(
                                self.creator_lp_token,
                                false,
                            ),
                        );
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new(
                                self.lp_vault,
                                false,
                            ),
                        );
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new(
                                self.token_0_vault,
                                false,
                            ),
                        );
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new(
                                self.token_1_vault,
                                false,
                            ),
                        );
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new(
                                self.create_pool_fee,
                                false,
                            ),
                        );
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new(
                                self.observation_state,
                                false,
                            ),
                        );
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                                self.token_program,
                                false,
                            ),
                        );
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                                self.token_0_program,
                                false,
                            ),
                        );
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                                self.token_1_program,
                                false,
                            ),
                        );
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                                self.associated_token_program,
                                false,
                            ),
                        );
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                                self.system_program,
                                false,
                            ),
                        );
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                                self.rent,
                                false,
                            ),
                        );
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                                self.compression_config,
                                false,
                            ),
                        );
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new(
                                self.rent_recipient,
                                false,
                            ),
                        );
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                                self.compressed_token_program_cpi_authority,
                                false,
                            ),
                        );
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                                self.compressed_token_program,
                                false,
                            ),
                        );
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                                self.ctoken_config_account,
                                false,
                            ),
                        );
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new(
                                self.ctoken_rent_recipient,
                                false,
                            ),
                        );
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new(
                                self.compressed_token_0_pool_pda,
                                false,
                            ),
                        );
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new(
                                self.compressed_token_1_pool_pda,
                                false,
                            ),
                        );
                    account_metas
                }
            }
        }
        /// An internal, Anchor generated module. This is used (as an
        /// implementation detail), to generate a CPI struct for a given
        /// `#[derive(Accounts)]` implementation, where each field is an
        /// AccountInfo.
        ///
        /// To access the struct in this module, one should use the sibling
        /// [`cpi::accounts`] module (also generated), which re-exports this.
        pub(crate) mod __cpi_client_accounts_initialize {
            use super::*;
            /// Generated CPI struct of the accounts for [`Initialize`].
            pub struct Initialize<'info> {
                ///Address paying to create the pool. Can be anyone
                pub creator: anchor_lang::solana_program::account_info::AccountInfo<
                    'info,
                >,
                ///Which config the pool belongs to.
                pub amm_config: anchor_lang::solana_program::account_info::AccountInfo<
                    'info,
                >,
                ///pool vault and lp mint authority
                pub authority: anchor_lang::solana_program::account_info::AccountInfo<
                    'info,
                >,
                pub pool_state: anchor_lang::solana_program::account_info::AccountInfo<
                    'info,
                >,
                ///Token_0 mint, the key must smaller than token_1 mint.
                pub token_0_mint: anchor_lang::solana_program::account_info::AccountInfo<
                    'info,
                >,
                ///Token_1 mint, the key must grater then token_0 mint.
                pub token_1_mint: anchor_lang::solana_program::account_info::AccountInfo<
                    'info,
                >,
                ///Signer pda used to derive lp_mint and its compressed address.
                pub lp_mint_signer: anchor_lang::solana_program::account_info::AccountInfo<
                    'info,
                >,
                ///Compressed mint for LP tokens
                pub lp_mint: anchor_lang::solana_program::account_info::AccountInfo<
                    'info,
                >,
                ///payer token0 account
                pub creator_token_0: anchor_lang::solana_program::account_info::AccountInfo<
                    'info,
                >,
                ///creator token1 account
                pub creator_token_1: anchor_lang::solana_program::account_info::AccountInfo<
                    'info,
                >,
                pub creator_lp_token: anchor_lang::solana_program::account_info::AccountInfo<
                    'info,
                >,
                pub lp_vault: anchor_lang::solana_program::account_info::AccountInfo<
                    'info,
                >,
                pub token_0_vault: anchor_lang::solana_program::account_info::AccountInfo<
                    'info,
                >,
                pub token_1_vault: anchor_lang::solana_program::account_info::AccountInfo<
                    'info,
                >,
                ///create pool fee account
                pub create_pool_fee: anchor_lang::solana_program::account_info::AccountInfo<
                    'info,
                >,
                ///an account to store oracle observations
                pub observation_state: anchor_lang::solana_program::account_info::AccountInfo<
                    'info,
                >,
                ///Program to create mint account and mint tokens
                pub token_program: anchor_lang::solana_program::account_info::AccountInfo<
                    'info,
                >,
                ///Spl token program or token program 2022
                pub token_0_program: anchor_lang::solana_program::account_info::AccountInfo<
                    'info,
                >,
                ///Spl token program or token program 2022
                pub token_1_program: anchor_lang::solana_program::account_info::AccountInfo<
                    'info,
                >,
                ///Program to create an ATA for receiving position NFT
                pub associated_token_program: anchor_lang::solana_program::account_info::AccountInfo<
                    'info,
                >,
                ///To create a new program account
                pub system_program: anchor_lang::solana_program::account_info::AccountInfo<
                    'info,
                >,
                ///Sysvar for program account
                pub rent: anchor_lang::solana_program::account_info::AccountInfo<'info>,
                pub compression_config: anchor_lang::solana_program::account_info::AccountInfo<
                    'info,
                >,
                pub rent_recipient: anchor_lang::solana_program::account_info::AccountInfo<
                    'info,
                >,
                pub compressed_token_program_cpi_authority: anchor_lang::solana_program::account_info::AccountInfo<
                    'info,
                >,
                pub compressed_token_program: anchor_lang::solana_program::account_info::AccountInfo<
                    'info,
                >,
                pub ctoken_config_account: anchor_lang::solana_program::account_info::AccountInfo<
                    'info,
                >,
                pub ctoken_rent_recipient: anchor_lang::solana_program::account_info::AccountInfo<
                    'info,
                >,
                pub compressed_token_0_pool_pda: anchor_lang::solana_program::account_info::AccountInfo<
                    'info,
                >,
                pub compressed_token_1_pool_pda: anchor_lang::solana_program::account_info::AccountInfo<
                    'info,
                >,
            }
            #[automatically_derived]
            impl<'info> anchor_lang::ToAccountMetas for Initialize<'info> {
                fn to_account_metas(
                    &self,
                    is_signer: Option<bool>,
                ) -> Vec<anchor_lang::solana_program::instruction::AccountMeta> {
                    let mut account_metas = ::alloc::vec::Vec::new();
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new(
                                anchor_lang::Key::key(&self.creator),
                                true,
                            ),
                        );
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                                anchor_lang::Key::key(&self.amm_config),
                                false,
                            ),
                        );
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                                anchor_lang::Key::key(&self.authority),
                                false,
                            ),
                        );
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new(
                                anchor_lang::Key::key(&self.pool_state),
                                false,
                            ),
                        );
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                                anchor_lang::Key::key(&self.token_0_mint),
                                false,
                            ),
                        );
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                                anchor_lang::Key::key(&self.token_1_mint),
                                false,
                            ),
                        );
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                                anchor_lang::Key::key(&self.lp_mint_signer),
                                false,
                            ),
                        );
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                                anchor_lang::Key::key(&self.lp_mint),
                                false,
                            ),
                        );
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new(
                                anchor_lang::Key::key(&self.creator_token_0),
                                false,
                            ),
                        );
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new(
                                anchor_lang::Key::key(&self.creator_token_1),
                                false,
                            ),
                        );
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new(
                                anchor_lang::Key::key(&self.creator_lp_token),
                                false,
                            ),
                        );
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new(
                                anchor_lang::Key::key(&self.lp_vault),
                                false,
                            ),
                        );
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new(
                                anchor_lang::Key::key(&self.token_0_vault),
                                false,
                            ),
                        );
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new(
                                anchor_lang::Key::key(&self.token_1_vault),
                                false,
                            ),
                        );
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new(
                                anchor_lang::Key::key(&self.create_pool_fee),
                                false,
                            ),
                        );
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new(
                                anchor_lang::Key::key(&self.observation_state),
                                false,
                            ),
                        );
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                                anchor_lang::Key::key(&self.token_program),
                                false,
                            ),
                        );
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                                anchor_lang::Key::key(&self.token_0_program),
                                false,
                            ),
                        );
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                                anchor_lang::Key::key(&self.token_1_program),
                                false,
                            ),
                        );
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                                anchor_lang::Key::key(&self.associated_token_program),
                                false,
                            ),
                        );
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                                anchor_lang::Key::key(&self.system_program),
                                false,
                            ),
                        );
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                                anchor_lang::Key::key(&self.rent),
                                false,
                            ),
                        );
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                                anchor_lang::Key::key(&self.compression_config),
                                false,
                            ),
                        );
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new(
                                anchor_lang::Key::key(&self.rent_recipient),
                                false,
                            ),
                        );
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                                anchor_lang::Key::key(
                                    &self.compressed_token_program_cpi_authority,
                                ),
                                false,
                            ),
                        );
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                                anchor_lang::Key::key(&self.compressed_token_program),
                                false,
                            ),
                        );
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                                anchor_lang::Key::key(&self.ctoken_config_account),
                                false,
                            ),
                        );
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new(
                                anchor_lang::Key::key(&self.ctoken_rent_recipient),
                                false,
                            ),
                        );
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new(
                                anchor_lang::Key::key(&self.compressed_token_0_pool_pda),
                                false,
                            ),
                        );
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new(
                                anchor_lang::Key::key(&self.compressed_token_1_pool_pda),
                                false,
                            ),
                        );
                    account_metas
                }
            }
            #[automatically_derived]
            impl<'info> anchor_lang::ToAccountInfos<'info> for Initialize<'info> {
                fn to_account_infos(
                    &self,
                ) -> Vec<anchor_lang::solana_program::account_info::AccountInfo<'info>> {
                    let mut account_infos = ::alloc::vec::Vec::new();
                    account_infos
                        .extend(
                            anchor_lang::ToAccountInfos::to_account_infos(&self.creator),
                        );
                    account_infos
                        .extend(
                            anchor_lang::ToAccountInfos::to_account_infos(
                                &self.amm_config,
                            ),
                        );
                    account_infos
                        .extend(
                            anchor_lang::ToAccountInfos::to_account_infos(
                                &self.authority,
                            ),
                        );
                    account_infos
                        .extend(
                            anchor_lang::ToAccountInfos::to_account_infos(
                                &self.pool_state,
                            ),
                        );
                    account_infos
                        .extend(
                            anchor_lang::ToAccountInfos::to_account_infos(
                                &self.token_0_mint,
                            ),
                        );
                    account_infos
                        .extend(
                            anchor_lang::ToAccountInfos::to_account_infos(
                                &self.token_1_mint,
                            ),
                        );
                    account_infos
                        .extend(
                            anchor_lang::ToAccountInfos::to_account_infos(
                                &self.lp_mint_signer,
                            ),
                        );
                    account_infos
                        .extend(
                            anchor_lang::ToAccountInfos::to_account_infos(&self.lp_mint),
                        );
                    account_infos
                        .extend(
                            anchor_lang::ToAccountInfos::to_account_infos(
                                &self.creator_token_0,
                            ),
                        );
                    account_infos
                        .extend(
                            anchor_lang::ToAccountInfos::to_account_infos(
                                &self.creator_token_1,
                            ),
                        );
                    account_infos
                        .extend(
                            anchor_lang::ToAccountInfos::to_account_infos(
                                &self.creator_lp_token,
                            ),
                        );
                    account_infos
                        .extend(
                            anchor_lang::ToAccountInfos::to_account_infos(&self.lp_vault),
                        );
                    account_infos
                        .extend(
                            anchor_lang::ToAccountInfos::to_account_infos(
                                &self.token_0_vault,
                            ),
                        );
                    account_infos
                        .extend(
                            anchor_lang::ToAccountInfos::to_account_infos(
                                &self.token_1_vault,
                            ),
                        );
                    account_infos
                        .extend(
                            anchor_lang::ToAccountInfos::to_account_infos(
                                &self.create_pool_fee,
                            ),
                        );
                    account_infos
                        .extend(
                            anchor_lang::ToAccountInfos::to_account_infos(
                                &self.observation_state,
                            ),
                        );
                    account_infos
                        .extend(
                            anchor_lang::ToAccountInfos::to_account_infos(
                                &self.token_program,
                            ),
                        );
                    account_infos
                        .extend(
                            anchor_lang::ToAccountInfos::to_account_infos(
                                &self.token_0_program,
                            ),
                        );
                    account_infos
                        .extend(
                            anchor_lang::ToAccountInfos::to_account_infos(
                                &self.token_1_program,
                            ),
                        );
                    account_infos
                        .extend(
                            anchor_lang::ToAccountInfos::to_account_infos(
                                &self.associated_token_program,
                            ),
                        );
                    account_infos
                        .extend(
                            anchor_lang::ToAccountInfos::to_account_infos(
                                &self.system_program,
                            ),
                        );
                    account_infos
                        .extend(
                            anchor_lang::ToAccountInfos::to_account_infos(&self.rent),
                        );
                    account_infos
                        .extend(
                            anchor_lang::ToAccountInfos::to_account_infos(
                                &self.compression_config,
                            ),
                        );
                    account_infos
                        .extend(
                            anchor_lang::ToAccountInfos::to_account_infos(
                                &self.rent_recipient,
                            ),
                        );
                    account_infos
                        .extend(
                            anchor_lang::ToAccountInfos::to_account_infos(
                                &self.compressed_token_program_cpi_authority,
                            ),
                        );
                    account_infos
                        .extend(
                            anchor_lang::ToAccountInfos::to_account_infos(
                                &self.compressed_token_program,
                            ),
                        );
                    account_infos
                        .extend(
                            anchor_lang::ToAccountInfos::to_account_infos(
                                &self.ctoken_config_account,
                            ),
                        );
                    account_infos
                        .extend(
                            anchor_lang::ToAccountInfos::to_account_infos(
                                &self.ctoken_rent_recipient,
                            ),
                        );
                    account_infos
                        .extend(
                            anchor_lang::ToAccountInfos::to_account_infos(
                                &self.compressed_token_0_pool_pda,
                            ),
                        );
                    account_infos
                        .extend(
                            anchor_lang::ToAccountInfos::to_account_infos(
                                &self.compressed_token_1_pool_pda,
                            ),
                        );
                    account_infos
                }
            }
        }
        impl<'info> Initialize<'info> {
            pub fn __anchor_private_gen_idl_accounts(
                accounts: &mut std::collections::BTreeMap<
                    String,
                    anchor_lang::idl::types::IdlAccount,
                >,
                types: &mut std::collections::BTreeMap<
                    String,
                    anchor_lang::idl::types::IdlTypeDef,
                >,
            ) -> Vec<anchor_lang::idl::types::IdlInstructionAccountItem> {
                if let Some(ty) = <AmmConfig>::create_type() {
                    let account = anchor_lang::idl::types::IdlAccount {
                        name: ty.name.clone(),
                        discriminator: AmmConfig::DISCRIMINATOR.into(),
                    };
                    accounts.insert(account.name.clone(), account);
                    types.insert(ty.name.clone(), ty);
                    <AmmConfig>::insert_types(types);
                }
                if let Some(ty) = <PoolState>::create_type() {
                    let account = anchor_lang::idl::types::IdlAccount {
                        name: ty.name.clone(),
                        discriminator: PoolState::DISCRIMINATOR.into(),
                    };
                    accounts.insert(account.name.clone(), account);
                    types.insert(ty.name.clone(), ty);
                    <PoolState>::insert_types(types);
                }
                if let Some(ty) = <Mint>::create_type() {
                    let account = anchor_lang::idl::types::IdlAccount {
                        name: ty.name.clone(),
                        discriminator: Mint::DISCRIMINATOR.into(),
                    };
                    accounts.insert(account.name.clone(), account);
                    types.insert(ty.name.clone(), ty);
                    <Mint>::insert_types(types);
                }
                if let Some(ty) = <Mint>::create_type() {
                    let account = anchor_lang::idl::types::IdlAccount {
                        name: ty.name.clone(),
                        discriminator: Mint::DISCRIMINATOR.into(),
                    };
                    accounts.insert(account.name.clone(), account);
                    types.insert(ty.name.clone(), ty);
                    <Mint>::insert_types(types);
                }
                if let Some(ty) = <TokenAccount>::create_type() {
                    let account = anchor_lang::idl::types::IdlAccount {
                        name: ty.name.clone(),
                        discriminator: TokenAccount::DISCRIMINATOR.into(),
                    };
                    accounts.insert(account.name.clone(), account);
                    types.insert(ty.name.clone(), ty);
                    <TokenAccount>::insert_types(types);
                }
                if let Some(ty) = <TokenAccount>::create_type() {
                    let account = anchor_lang::idl::types::IdlAccount {
                        name: ty.name.clone(),
                        discriminator: TokenAccount::DISCRIMINATOR.into(),
                    };
                    accounts.insert(account.name.clone(), account);
                    types.insert(ty.name.clone(), ty);
                    <TokenAccount>::insert_types(types);
                }
                if let Some(ty) = <TokenAccount>::create_type() {
                    let account = anchor_lang::idl::types::IdlAccount {
                        name: ty.name.clone(),
                        discriminator: TokenAccount::DISCRIMINATOR.into(),
                    };
                    accounts.insert(account.name.clone(), account);
                    types.insert(ty.name.clone(), ty);
                    <TokenAccount>::insert_types(types);
                }
                if let Some(ty) = <ObservationState>::create_type() {
                    let account = anchor_lang::idl::types::IdlAccount {
                        name: ty.name.clone(),
                        discriminator: ObservationState::DISCRIMINATOR.into(),
                    };
                    accounts.insert(account.name.clone(), account);
                    types.insert(ty.name.clone(), ty);
                    <ObservationState>::insert_types(types);
                }
                <[_]>::into_vec(
                    ::alloc::boxed::box_new([
                        anchor_lang::idl::types::IdlInstructionAccountItem::Single(anchor_lang::idl::types::IdlInstructionAccount {
                            name: "creator".into(),
                            docs: <[_]>::into_vec(
                                ::alloc::boxed::box_new([
                                    "Address paying to create the pool. Can be anyone".into(),
                                ]),
                            ),
                            writable: true,
                            signer: true,
                            optional: false,
                            address: None,
                            pda: None,
                            relations: ::alloc::vec::Vec::new(),
                        }),
                        anchor_lang::idl::types::IdlInstructionAccountItem::Single(anchor_lang::idl::types::IdlInstructionAccount {
                            name: "amm_config".into(),
                            docs: <[_]>::into_vec(
                                ::alloc::boxed::box_new([
                                    "Which config the pool belongs to.".into(),
                                ]),
                            ),
                            writable: false,
                            signer: false,
                            optional: false,
                            address: None,
                            pda: None,
                            relations: ::alloc::vec::Vec::new(),
                        }),
                        anchor_lang::idl::types::IdlInstructionAccountItem::Single(anchor_lang::idl::types::IdlInstructionAccount {
                            name: "authority".into(),
                            docs: <[_]>::into_vec(
                                ::alloc::boxed::box_new([
                                    "pool vault and lp mint authority".into(),
                                ]),
                            ),
                            writable: false,
                            signer: false,
                            optional: false,
                            address: None,
                            pda: None,
                            relations: ::alloc::vec::Vec::new(),
                        }),
                        anchor_lang::idl::types::IdlInstructionAccountItem::Single(anchor_lang::idl::types::IdlInstructionAccount {
                            name: "pool_state".into(),
                            docs: {
                                let mut v = ::alloc::vec::Vec::new();
                                v.push("cpda".into());
                                v
                            },
                            writable: true,
                            signer: false,
                            optional: false,
                            address: None,
                            pda: None,
                            relations: ::alloc::vec::Vec::new(),
                        }),
                        anchor_lang::idl::types::IdlInstructionAccountItem::Single(anchor_lang::idl::types::IdlInstructionAccount {
                            name: "token_0_mint".into(),
                            docs: <[_]>::into_vec(
                                ::alloc::boxed::box_new([
                                    "Token_0 mint, the key must smaller than token_1 mint."
                                        .into(),
                                ]),
                            ),
                            writable: false,
                            signer: false,
                            optional: false,
                            address: None,
                            pda: None,
                            relations: ::alloc::vec::Vec::new(),
                        }),
                        anchor_lang::idl::types::IdlInstructionAccountItem::Single(anchor_lang::idl::types::IdlInstructionAccount {
                            name: "token_1_mint".into(),
                            docs: <[_]>::into_vec(
                                ::alloc::boxed::box_new([
                                    "Token_1 mint, the key must grater then token_0 mint."
                                        .into(),
                                ]),
                            ),
                            writable: false,
                            signer: false,
                            optional: false,
                            address: None,
                            pda: None,
                            relations: ::alloc::vec::Vec::new(),
                        }),
                        anchor_lang::idl::types::IdlInstructionAccountItem::Single(anchor_lang::idl::types::IdlInstructionAccount {
                            name: "lp_mint_signer".into(),
                            docs: <[_]>::into_vec(
                                ::alloc::boxed::box_new([
                                    "Signer pda used to derive lp_mint and its compressed address."
                                        .into(),
                                ]),
                            ),
                            writable: false,
                            signer: false,
                            optional: false,
                            address: None,
                            pda: None,
                            relations: ::alloc::vec::Vec::new(),
                        }),
                        anchor_lang::idl::types::IdlInstructionAccountItem::Single(anchor_lang::idl::types::IdlInstructionAccount {
                            name: "lp_mint".into(),
                            docs: <[_]>::into_vec(
                                ::alloc::boxed::box_new([
                                    "Compressed mint for LP tokens".into(),
                                ]),
                            ),
                            writable: false,
                            signer: false,
                            optional: false,
                            address: None,
                            pda: None,
                            relations: ::alloc::vec::Vec::new(),
                        }),
                        anchor_lang::idl::types::IdlInstructionAccountItem::Single(anchor_lang::idl::types::IdlInstructionAccount {
                            name: "creator_token_0".into(),
                            docs: <[_]>::into_vec(
                                ::alloc::boxed::box_new(["payer token0 account".into()]),
                            ),
                            writable: true,
                            signer: false,
                            optional: false,
                            address: None,
                            pda: None,
                            relations: ::alloc::vec::Vec::new(),
                        }),
                        anchor_lang::idl::types::IdlInstructionAccountItem::Single(anchor_lang::idl::types::IdlInstructionAccount {
                            name: "creator_token_1".into(),
                            docs: <[_]>::into_vec(
                                ::alloc::boxed::box_new(["creator token1 account".into()]),
                            ),
                            writable: true,
                            signer: false,
                            optional: false,
                            address: None,
                            pda: None,
                            relations: ::alloc::vec::Vec::new(),
                        }),
                        anchor_lang::idl::types::IdlInstructionAccountItem::Single(anchor_lang::idl::types::IdlInstructionAccount {
                            name: "creator_lp_token".into(),
                            docs: ::alloc::vec::Vec::new(),
                            writable: true,
                            signer: false,
                            optional: false,
                            address: None,
                            pda: None,
                            relations: ::alloc::vec::Vec::new(),
                        }),
                        anchor_lang::idl::types::IdlInstructionAccountItem::Single(anchor_lang::idl::types::IdlInstructionAccount {
                            name: "lp_vault".into(),
                            docs: {
                                let mut v = ::alloc::vec::Vec::new();
                                v.push("cctoken".into());
                                v
                            },
                            writable: true,
                            signer: false,
                            optional: false,
                            address: None,
                            pda: None,
                            relations: ::alloc::vec::Vec::new(),
                        }),
                        anchor_lang::idl::types::IdlInstructionAccountItem::Single(anchor_lang::idl::types::IdlInstructionAccount {
                            name: "token_0_vault".into(),
                            docs: {
                                let mut v = ::alloc::vec::Vec::new();
                                v.push("cctoken".into());
                                v
                            },
                            writable: true,
                            signer: false,
                            optional: false,
                            address: None,
                            pda: None,
                            relations: ::alloc::vec::Vec::new(),
                        }),
                        anchor_lang::idl::types::IdlInstructionAccountItem::Single(anchor_lang::idl::types::IdlInstructionAccount {
                            name: "token_1_vault".into(),
                            docs: {
                                let mut v = ::alloc::vec::Vec::new();
                                v.push("cctoken".into());
                                v
                            },
                            writable: true,
                            signer: false,
                            optional: false,
                            address: None,
                            pda: None,
                            relations: ::alloc::vec::Vec::new(),
                        }),
                        anchor_lang::idl::types::IdlInstructionAccountItem::Single(anchor_lang::idl::types::IdlInstructionAccount {
                            name: "create_pool_fee".into(),
                            docs: <[_]>::into_vec(
                                ::alloc::boxed::box_new(["create pool fee account".into()]),
                            ),
                            writable: true,
                            signer: false,
                            optional: false,
                            address: None,
                            pda: None,
                            relations: ::alloc::vec::Vec::new(),
                        }),
                        anchor_lang::idl::types::IdlInstructionAccountItem::Single(anchor_lang::idl::types::IdlInstructionAccount {
                            name: "observation_state".into(),
                            docs: {
                                let mut v = <[_]>::into_vec(
                                    ::alloc::boxed::box_new([
                                        "an account to store oracle observations".into(),
                                    ]),
                                );
                                v.push("cpda".into());
                                v
                            },
                            writable: true,
                            signer: false,
                            optional: false,
                            address: None,
                            pda: None,
                            relations: ::alloc::vec::Vec::new(),
                        }),
                        anchor_lang::idl::types::IdlInstructionAccountItem::Single(anchor_lang::idl::types::IdlInstructionAccount {
                            name: "token_program".into(),
                            docs: <[_]>::into_vec(
                                ::alloc::boxed::box_new([
                                    "Program to create mint account and mint tokens".into(),
                                ]),
                            ),
                            writable: false,
                            signer: false,
                            optional: false,
                            address: None,
                            pda: None,
                            relations: ::alloc::vec::Vec::new(),
                        }),
                        anchor_lang::idl::types::IdlInstructionAccountItem::Single(anchor_lang::idl::types::IdlInstructionAccount {
                            name: "token_0_program".into(),
                            docs: <[_]>::into_vec(
                                ::alloc::boxed::box_new([
                                    "Spl token program or token program 2022".into(),
                                ]),
                            ),
                            writable: false,
                            signer: false,
                            optional: false,
                            address: None,
                            pda: None,
                            relations: ::alloc::vec::Vec::new(),
                        }),
                        anchor_lang::idl::types::IdlInstructionAccountItem::Single(anchor_lang::idl::types::IdlInstructionAccount {
                            name: "token_1_program".into(),
                            docs: <[_]>::into_vec(
                                ::alloc::boxed::box_new([
                                    "Spl token program or token program 2022".into(),
                                ]),
                            ),
                            writable: false,
                            signer: false,
                            optional: false,
                            address: None,
                            pda: None,
                            relations: ::alloc::vec::Vec::new(),
                        }),
                        anchor_lang::idl::types::IdlInstructionAccountItem::Single(anchor_lang::idl::types::IdlInstructionAccount {
                            name: "associated_token_program".into(),
                            docs: <[_]>::into_vec(
                                ::alloc::boxed::box_new([
                                    "Program to create an ATA for receiving position NFT".into(),
                                ]),
                            ),
                            writable: false,
                            signer: false,
                            optional: false,
                            address: None,
                            pda: None,
                            relations: ::alloc::vec::Vec::new(),
                        }),
                        anchor_lang::idl::types::IdlInstructionAccountItem::Single(anchor_lang::idl::types::IdlInstructionAccount {
                            name: "system_program".into(),
                            docs: <[_]>::into_vec(
                                ::alloc::boxed::box_new([
                                    "To create a new program account".into(),
                                ]),
                            ),
                            writable: false,
                            signer: false,
                            optional: false,
                            address: None,
                            pda: None,
                            relations: ::alloc::vec::Vec::new(),
                        }),
                        anchor_lang::idl::types::IdlInstructionAccountItem::Single(anchor_lang::idl::types::IdlInstructionAccount {
                            name: "rent".into(),
                            docs: <[_]>::into_vec(
                                ::alloc::boxed::box_new([
                                    "Sysvar for program account".into(),
                                ]),
                            ),
                            writable: false,
                            signer: false,
                            optional: false,
                            address: None,
                            pda: None,
                            relations: ::alloc::vec::Vec::new(),
                        }),
                        anchor_lang::idl::types::IdlInstructionAccountItem::Single(anchor_lang::idl::types::IdlInstructionAccount {
                            name: "compression_config".into(),
                            docs: ::alloc::vec::Vec::new(),
                            writable: false,
                            signer: false,
                            optional: false,
                            address: None,
                            pda: None,
                            relations: ::alloc::vec::Vec::new(),
                        }),
                        anchor_lang::idl::types::IdlInstructionAccountItem::Single(anchor_lang::idl::types::IdlInstructionAccount {
                            name: "rent_recipient".into(),
                            docs: ::alloc::vec::Vec::new(),
                            writable: true,
                            signer: false,
                            optional: false,
                            address: None,
                            pda: None,
                            relations: ::alloc::vec::Vec::new(),
                        }),
                        anchor_lang::idl::types::IdlInstructionAccountItem::Single(anchor_lang::idl::types::IdlInstructionAccount {
                            name: "compressed_token_program_cpi_authority".into(),
                            docs: ::alloc::vec::Vec::new(),
                            writable: false,
                            signer: false,
                            optional: false,
                            address: None,
                            pda: None,
                            relations: ::alloc::vec::Vec::new(),
                        }),
                        anchor_lang::idl::types::IdlInstructionAccountItem::Single(anchor_lang::idl::types::IdlInstructionAccount {
                            name: "compressed_token_program".into(),
                            docs: ::alloc::vec::Vec::new(),
                            writable: false,
                            signer: false,
                            optional: false,
                            address: None,
                            pda: None,
                            relations: ::alloc::vec::Vec::new(),
                        }),
                        anchor_lang::idl::types::IdlInstructionAccountItem::Single(anchor_lang::idl::types::IdlInstructionAccount {
                            name: "ctoken_config_account".into(),
                            docs: ::alloc::vec::Vec::new(),
                            writable: false,
                            signer: false,
                            optional: false,
                            address: None,
                            pda: None,
                            relations: ::alloc::vec::Vec::new(),
                        }),
                        anchor_lang::idl::types::IdlInstructionAccountItem::Single(anchor_lang::idl::types::IdlInstructionAccount {
                            name: "ctoken_rent_recipient".into(),
                            docs: ::alloc::vec::Vec::new(),
                            writable: true,
                            signer: false,
                            optional: false,
                            address: None,
                            pda: None,
                            relations: ::alloc::vec::Vec::new(),
                        }),
                        anchor_lang::idl::types::IdlInstructionAccountItem::Single(anchor_lang::idl::types::IdlInstructionAccount {
                            name: "compressed_token_0_pool_pda".into(),
                            docs: ::alloc::vec::Vec::new(),
                            writable: true,
                            signer: false,
                            optional: false,
                            address: None,
                            pda: None,
                            relations: ::alloc::vec::Vec::new(),
                        }),
                        anchor_lang::idl::types::IdlInstructionAccountItem::Single(anchor_lang::idl::types::IdlInstructionAccount {
                            name: "compressed_token_1_pool_pda".into(),
                            docs: ::alloc::vec::Vec::new(),
                            writable: true,
                            signer: false,
                            optional: false,
                            address: None,
                            pda: None,
                            relations: ::alloc::vec::Vec::new(),
                        }),
                    ]),
                )
            }
            pub fn __anchor_private_gen_light_metadata() -> Option<
                anchor_lang::idl::types::IdlLightInstructionMeta,
            > {
                Some(anchor_lang::idl::types::IdlLightInstructionMeta {
                    ctokens: Some(
                        <[_]>::into_vec(
                            ::alloc::boxed::box_new([
                                anchor_lang::idl::types::IdlLightCtokenUsage {
                                    account: "lp_vault".to_string(),
                                    possible_variants: <[_]>::into_vec(
                                        ::alloc::boxed::box_new(["LpVault".to_string()]),
                                    ),
                                    seeds: ::alloc::vec::Vec::new(),
                                    authority: None,
                                    mint: None,
                                    seed_aliases: None,
                                },
                                anchor_lang::idl::types::IdlLightCtokenUsage {
                                    account: "token_0_vault".to_string(),
                                    possible_variants: <[_]>::into_vec(
                                        ::alloc::boxed::box_new(["Token0Vault".to_string()]),
                                    ),
                                    seeds: ::alloc::vec::Vec::new(),
                                    authority: None,
                                    mint: None,
                                    seed_aliases: None,
                                },
                                anchor_lang::idl::types::IdlLightCtokenUsage {
                                    account: "token_1_vault".to_string(),
                                    possible_variants: <[_]>::into_vec(
                                        ::alloc::boxed::box_new(["Token1Vault".to_string()]),
                                    ),
                                    seeds: ::alloc::vec::Vec::new(),
                                    authority: None,
                                    mint: None,
                                    seed_aliases: None,
                                },
                            ]),
                        ),
                    ),
                    cpdas: Some(
                        <[_]>::into_vec(
                            ::alloc::boxed::box_new([
                                anchor_lang::idl::types::IdlLightCpdaUsage {
                                    account: "pool_state".to_string(),
                                    ty: "PoolState".to_string(),
                                },
                                anchor_lang::idl::types::IdlLightCpdaUsage {
                                    account: "observation_state".to_string(),
                                    ty: "ObservationState".to_string(),
                                },
                            ]),
                        ),
                    ),
                })
            }
        }
        pub fn initialize<'info>(
            ctx: Context<'_, '_, '_, 'info, Initialize<'info>>,
            init_amount_0: u64,
            init_amount_1: u64,
            mut open_time: u64,
            compression_params: InitializeCompressionParams,
        ) -> Result<()> {
            if !(is_supported_mint(&ctx.accounts.token_0_mint).unwrap()
                && is_supported_mint(&ctx.accounts.token_1_mint).unwrap())
            {
                return Err(
                    anchor_lang::error::Error::from(anchor_lang::error::AnchorError {
                        error_name: ErrorCode::NotSupportMint.name(),
                        error_code_number: ErrorCode::NotSupportMint.into(),
                        error_msg: ErrorCode::NotSupportMint.to_string(),
                        error_origin: Some(
                            anchor_lang::error::ErrorOrigin::Source(anchor_lang::error::Source {
                                filename: "programs/cp-swap/src/instructions/initialize.rs",
                                line: 235u32,
                            }),
                        ),
                        compared_values: None,
                    }),
                );
            }
            if ctx.accounts.amm_config.disable_create_pool {
                return Err(
                    anchor_lang::error::Error::from(anchor_lang::error::AnchorError {
                        error_name: ErrorCode::NotApproved.name(),
                        error_code_number: ErrorCode::NotApproved.into(),
                        error_msg: ErrorCode::NotApproved.to_string(),
                        error_origin: Some(
                            anchor_lang::error::ErrorOrigin::Source(anchor_lang::error::Source {
                                filename: "programs/cp-swap/src/instructions/initialize.rs",
                                line: 239u32,
                            }),
                        ),
                        compared_values: None,
                    }),
                );
            }
            let block_timestamp = clock::Clock::get()?.unix_timestamp as u64;
            if open_time <= block_timestamp {
                open_time = block_timestamp + 1;
            }
            create_ctoken_account_signed(
                crate::ID,
                ctx.accounts.creator.to_account_info(),
                ctx.accounts.token_0_vault.to_account_info(),
                ctx.accounts.token_0_mint.to_account_info(),
                *ctx.accounts.authority.to_account_info().key,
                &[
                    POOL_VAULT_SEED.as_bytes(),
                    ctx.accounts.pool_state.to_account_info().key.as_ref(),
                    ctx.accounts.token_0_mint.to_account_info().key.as_ref(),
                    &[ctx.bumps.token_0_vault][..],
                ],
                ctx.accounts.ctoken_rent_recipient.to_account_info(),
                ctx.accounts.ctoken_config_account.to_account_info(),
                Some(1),
                None,
            )?;
            create_ctoken_account_signed(
                crate::ID,
                ctx.accounts.creator.to_account_info(),
                ctx.accounts.token_1_vault.to_account_info(),
                ctx.accounts.token_1_mint.to_account_info(),
                *ctx.accounts.authority.to_account_info().key,
                &[
                    POOL_VAULT_SEED.as_bytes(),
                    ctx.accounts.pool_state.to_account_info().key.as_ref(),
                    ctx.accounts.token_1_mint.to_account_info().key.as_ref(),
                    &[ctx.bumps.token_1_vault][..],
                ],
                ctx.accounts.ctoken_rent_recipient.to_account_info(),
                ctx.accounts.ctoken_config_account.to_account_info(),
                Some(1),
                None,
            )?;
            let (compressed_token_0_pool_bump, compressed_token_1_pool_bump) = get_bumps(
                ctx.accounts.token_0_mint.key(),
                ctx.accounts.token_1_mint.key(),
                ctx.accounts.compressed_token_program.key(),
            );
            let pool_state = &mut ctx.accounts.pool_state;
            let pool_state_key = pool_state.key();
            let observation_state = &mut ctx.accounts.observation_state;
            let observation_state_key = observation_state.key();
            observation_state.pool_id = pool_state_key;
            transfer_from_user_to_pool_vault(
                ctx.accounts.creator.to_account_info(),
                ctx.accounts.creator_token_0.to_account_info(),
                ctx.accounts.token_0_vault.to_account_info(),
                Some(ctx.accounts.token_0_mint.to_account_info()),
                Some(ctx.accounts.token_0_program.to_account_info()),
                Some(ctx.accounts.compressed_token_0_pool_pda.to_account_info()),
                Some(compressed_token_0_pool_bump),
                ctx.accounts.compressed_token_program_cpi_authority.to_account_info(),
                init_amount_0,
            )?;
            transfer_from_user_to_pool_vault(
                ctx.accounts.creator.to_account_info(),
                ctx.accounts.creator_token_1.to_account_info(),
                ctx.accounts.token_1_vault.to_account_info(),
                Some(ctx.accounts.token_1_mint.to_account_info()),
                Some(ctx.accounts.token_1_program.to_account_info()),
                Some(ctx.accounts.compressed_token_1_pool_pda.to_account_info()),
                Some(compressed_token_1_pool_bump),
                ctx.accounts.compressed_token_program_cpi_authority.to_account_info(),
                init_amount_1,
            )?;
            let token_0_vault = spl_token_2022::extension::StateWithExtensions::<
                spl_token_2022::state::Account,
            >::unpack(
                    ctx
                        .accounts
                        .token_0_vault
                        .to_account_info()
                        .try_borrow_data()?
                        .deref(),
                )?
                .base;
            let token_1_vault = spl_token_2022::extension::StateWithExtensions::<
                spl_token_2022::state::Account,
            >::unpack(
                    ctx
                        .accounts
                        .token_1_vault
                        .to_account_info()
                        .try_borrow_data()?
                        .deref(),
                )?
                .base;
            CurveCalculator::validate_supply(
                token_0_vault.amount,
                token_1_vault.amount,
            )?;
            if ctx.accounts.amm_config.create_pool_fee != 0 {
                invoke(
                    &system_instruction::transfer(
                        ctx.accounts.creator.key,
                        &ctx.accounts.create_pool_fee.key(),
                        u64::from(ctx.accounts.amm_config.create_pool_fee),
                    ),
                    &[
                        ctx.accounts.creator.to_account_info(),
                        ctx.accounts.create_pool_fee.to_account_info(),
                        ctx.accounts.system_program.to_account_info(),
                    ],
                )?;
                invoke(
                    &spl_token::instruction::sync_native(
                        ctx.accounts.token_program.key,
                        &ctx.accounts.create_pool_fee.key(),
                    )?,
                    &[
                        ctx.accounts.token_program.to_account_info(),
                        ctx.accounts.create_pool_fee.to_account_info(),
                    ],
                )?;
            }
            let liquidity = U128::from(token_0_vault.amount)
                .checked_mul(token_1_vault.amount.into())
                .unwrap()
                .integer_sqrt()
                .as_u64();
            let lock_lp_amount = 100;
            let user_lp_amount = liquidity
                .checked_sub(lock_lp_amount)
                .ok_or(ErrorCode::InitLpAmountTooLess)?;
            let vault_lp_amount = u64::MAX
                .checked_sub(user_lp_amount)
                .ok_or(ErrorCode::InitLpAmountTooLess)?;
            pool_state
                .initialize(
                    ctx.bumps.authority,
                    liquidity,
                    open_time,
                    ctx.accounts.creator.key(),
                    ctx.accounts.amm_config.key(),
                    ctx.accounts.token_0_vault.key(),
                    ctx.accounts.token_1_vault.key(),
                    &ctx.accounts.token_0_mint,
                    &ctx.accounts.token_1_mint,
                    ctx.accounts.token_0_program.key(),
                    ctx.accounts.token_1_program.key(),
                    &ctx.accounts.lp_vault,
                    &ctx.accounts.lp_mint.to_account_info(),
                    observation_state_key,
                );
            create_ctoken_account_signed(
                crate::ID,
                ctx.accounts.creator.to_account_info(),
                ctx.accounts.lp_vault.to_account_info(),
                ctx.accounts.lp_mint.to_account_info(),
                *ctx.accounts.authority.to_account_info().key,
                &[
                    POOL_VAULT_SEED.as_bytes(),
                    ctx.accounts.lp_mint.to_account_info().key.as_ref(),
                    &[ctx.bumps.lp_vault][..],
                ],
                ctx.accounts.ctoken_rent_recipient.to_account_info(),
                ctx.accounts.ctoken_config_account.to_account_info(),
                Some(1),
                None,
            )?;
            create_associated_ctoken_account(
                ctx.accounts.creator.to_account_info(),
                ctx.accounts.creator_lp_token.to_account_info(),
                ctx.accounts.system_program.to_account_info(),
                ctx.accounts.ctoken_config_account.to_account_info(),
                ctx.accounts.ctoken_rent_recipient.to_account_info(),
                ctx.accounts.creator.to_account_info(),
                *ctx.accounts.lp_mint.to_account_info().key,
                compression_params.creator_lp_token_bump,
                Some(1),
                None,
            )?;
            ctx.accounts
                .lp_mint
                .mint_to(
                    &ctx.accounts.creator_lp_token.to_account_info(),
                    user_lp_amount,
                )?;
            ctx.accounts
                .lp_mint
                .mint_to(&ctx.accounts.lp_vault.to_account_info(), vault_lp_amount)?;
            Ok(())
        }
        pub struct InitializeCompressionParams {
            pub pool_address_tree_info: PackedAddressTreeInfo,
            pub observation_address_tree_info: PackedAddressTreeInfo,
            pub lp_mint_address_tree_info: PackedAddressTreeInfo,
            pub lp_mint_bump: u8,
            pub creator_lp_token_bump: u8,
            pub name: Vec<u8>,
            pub symbol: Vec<u8>,
            pub uri: Vec<u8>,
            pub proof: ValidityProof,
            pub output_state_tree_index: u8,
        }
        impl borsh::ser::BorshSerialize for InitializeCompressionParams
        where
            PackedAddressTreeInfo: borsh::ser::BorshSerialize,
            PackedAddressTreeInfo: borsh::ser::BorshSerialize,
            PackedAddressTreeInfo: borsh::ser::BorshSerialize,
            u8: borsh::ser::BorshSerialize,
            u8: borsh::ser::BorshSerialize,
            Vec<u8>: borsh::ser::BorshSerialize,
            Vec<u8>: borsh::ser::BorshSerialize,
            Vec<u8>: borsh::ser::BorshSerialize,
            ValidityProof: borsh::ser::BorshSerialize,
            u8: borsh::ser::BorshSerialize,
        {
            fn serialize<W: borsh::maybestd::io::Write>(
                &self,
                writer: &mut W,
            ) -> ::core::result::Result<(), borsh::maybestd::io::Error> {
                borsh::BorshSerialize::serialize(&self.pool_address_tree_info, writer)?;
                borsh::BorshSerialize::serialize(
                    &self.observation_address_tree_info,
                    writer,
                )?;
                borsh::BorshSerialize::serialize(
                    &self.lp_mint_address_tree_info,
                    writer,
                )?;
                borsh::BorshSerialize::serialize(&self.lp_mint_bump, writer)?;
                borsh::BorshSerialize::serialize(&self.creator_lp_token_bump, writer)?;
                borsh::BorshSerialize::serialize(&self.name, writer)?;
                borsh::BorshSerialize::serialize(&self.symbol, writer)?;
                borsh::BorshSerialize::serialize(&self.uri, writer)?;
                borsh::BorshSerialize::serialize(&self.proof, writer)?;
                borsh::BorshSerialize::serialize(&self.output_state_tree_index, writer)?;
                Ok(())
            }
        }
        impl anchor_lang::idl::build::IdlBuild for InitializeCompressionParams {
            fn create_type() -> Option<anchor_lang::idl::types::IdlTypeDef> {
                Some(anchor_lang::idl::types::IdlTypeDef {
                    name: Self::get_full_path(),
                    docs: ::alloc::vec::Vec::new(),
                    serialization: anchor_lang::idl::types::IdlSerialization::default(),
                    repr: None,
                    generics: ::alloc::vec::Vec::new(),
                    ty: anchor_lang::idl::types::IdlTypeDefTy::Struct {
                        fields: Some(
                            anchor_lang::idl::types::IdlDefinedFields::Named(
                                <[_]>::into_vec(
                                    ::alloc::boxed::box_new([
                                        anchor_lang::idl::types::IdlField {
                                            name: "pool_address_tree_info".into(),
                                            docs: ::alloc::vec::Vec::new(),
                                            ty: anchor_lang::idl::types::IdlType::Defined {
                                                name: <PackedAddressTreeInfo>::get_full_path(),
                                                generics: ::alloc::vec::Vec::new(),
                                            },
                                        },
                                        anchor_lang::idl::types::IdlField {
                                            name: "observation_address_tree_info".into(),
                                            docs: ::alloc::vec::Vec::new(),
                                            ty: anchor_lang::idl::types::IdlType::Defined {
                                                name: <PackedAddressTreeInfo>::get_full_path(),
                                                generics: ::alloc::vec::Vec::new(),
                                            },
                                        },
                                        anchor_lang::idl::types::IdlField {
                                            name: "lp_mint_address_tree_info".into(),
                                            docs: ::alloc::vec::Vec::new(),
                                            ty: anchor_lang::idl::types::IdlType::Defined {
                                                name: <PackedAddressTreeInfo>::get_full_path(),
                                                generics: ::alloc::vec::Vec::new(),
                                            },
                                        },
                                        anchor_lang::idl::types::IdlField {
                                            name: "lp_mint_bump".into(),
                                            docs: ::alloc::vec::Vec::new(),
                                            ty: anchor_lang::idl::types::IdlType::U8,
                                        },
                                        anchor_lang::idl::types::IdlField {
                                            name: "creator_lp_token_bump".into(),
                                            docs: ::alloc::vec::Vec::new(),
                                            ty: anchor_lang::idl::types::IdlType::U8,
                                        },
                                        anchor_lang::idl::types::IdlField {
                                            name: "name".into(),
                                            docs: ::alloc::vec::Vec::new(),
                                            ty: anchor_lang::idl::types::IdlType::Bytes,
                                        },
                                        anchor_lang::idl::types::IdlField {
                                            name: "symbol".into(),
                                            docs: ::alloc::vec::Vec::new(),
                                            ty: anchor_lang::idl::types::IdlType::Bytes,
                                        },
                                        anchor_lang::idl::types::IdlField {
                                            name: "uri".into(),
                                            docs: ::alloc::vec::Vec::new(),
                                            ty: anchor_lang::idl::types::IdlType::Bytes,
                                        },
                                        anchor_lang::idl::types::IdlField {
                                            name: "proof".into(),
                                            docs: ::alloc::vec::Vec::new(),
                                            ty: anchor_lang::idl::types::IdlType::Defined {
                                                name: <ValidityProof>::get_full_path(),
                                                generics: ::alloc::vec::Vec::new(),
                                            },
                                        },
                                        anchor_lang::idl::types::IdlField {
                                            name: "output_state_tree_index".into(),
                                            docs: ::alloc::vec::Vec::new(),
                                            ty: anchor_lang::idl::types::IdlType::U8,
                                        },
                                    ]),
                                ),
                            ),
                        ),
                    },
                })
            }
            fn insert_types(
                types: &mut std::collections::BTreeMap<
                    String,
                    anchor_lang::idl::types::IdlTypeDef,
                >,
            ) {
                if let Some(ty) = <PackedAddressTreeInfo>::create_type() {
                    types.insert(<PackedAddressTreeInfo>::get_full_path(), ty);
                    <PackedAddressTreeInfo>::insert_types(types);
                }
                if let Some(ty) = <PackedAddressTreeInfo>::create_type() {
                    types.insert(<PackedAddressTreeInfo>::get_full_path(), ty);
                    <PackedAddressTreeInfo>::insert_types(types);
                }
                if let Some(ty) = <PackedAddressTreeInfo>::create_type() {
                    types.insert(<PackedAddressTreeInfo>::get_full_path(), ty);
                    <PackedAddressTreeInfo>::insert_types(types);
                }
                if let Some(ty) = <ValidityProof>::create_type() {
                    types.insert(<ValidityProof>::get_full_path(), ty);
                    <ValidityProof>::insert_types(types);
                }
            }
            fn get_full_path() -> String {
                ::alloc::__export::must_use({
                    ::alloc::fmt::format(
                        format_args!(
                            "{0}::{1}",
                            "raydium_cp_swap::instructions::initialize",
                            "InitializeCompressionParams",
                        ),
                    )
                })
            }
        }
        impl borsh::de::BorshDeserialize for InitializeCompressionParams
        where
            PackedAddressTreeInfo: borsh::BorshDeserialize,
            PackedAddressTreeInfo: borsh::BorshDeserialize,
            PackedAddressTreeInfo: borsh::BorshDeserialize,
            u8: borsh::BorshDeserialize,
            u8: borsh::BorshDeserialize,
            Vec<u8>: borsh::BorshDeserialize,
            Vec<u8>: borsh::BorshDeserialize,
            Vec<u8>: borsh::BorshDeserialize,
            ValidityProof: borsh::BorshDeserialize,
            u8: borsh::BorshDeserialize,
        {
            fn deserialize_reader<R: borsh::maybestd::io::Read>(
                reader: &mut R,
            ) -> ::core::result::Result<Self, borsh::maybestd::io::Error> {
                Ok(Self {
                    pool_address_tree_info: borsh::BorshDeserialize::deserialize_reader(
                        reader,
                    )?,
                    observation_address_tree_info: borsh::BorshDeserialize::deserialize_reader(
                        reader,
                    )?,
                    lp_mint_address_tree_info: borsh::BorshDeserialize::deserialize_reader(
                        reader,
                    )?,
                    lp_mint_bump: borsh::BorshDeserialize::deserialize_reader(reader)?,
                    creator_lp_token_bump: borsh::BorshDeserialize::deserialize_reader(
                        reader,
                    )?,
                    name: borsh::BorshDeserialize::deserialize_reader(reader)?,
                    symbol: borsh::BorshDeserialize::deserialize_reader(reader)?,
                    uri: borsh::BorshDeserialize::deserialize_reader(reader)?,
                    proof: borsh::BorshDeserialize::deserialize_reader(reader)?,
                    output_state_tree_index: borsh::BorshDeserialize::deserialize_reader(
                        reader,
                    )?,
                })
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for InitializeCompressionParams {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                let names: &'static _ = &[
                    "pool_address_tree_info",
                    "observation_address_tree_info",
                    "lp_mint_address_tree_info",
                    "lp_mint_bump",
                    "creator_lp_token_bump",
                    "name",
                    "symbol",
                    "uri",
                    "proof",
                    "output_state_tree_index",
                ];
                let values: &[&dyn ::core::fmt::Debug] = &[
                    &self.pool_address_tree_info,
                    &self.observation_address_tree_info,
                    &self.lp_mint_address_tree_info,
                    &self.lp_mint_bump,
                    &self.creator_lp_token_bump,
                    &self.name,
                    &self.symbol,
                    &self.uri,
                    &self.proof,
                    &&self.output_state_tree_index,
                ];
                ::core::fmt::Formatter::debug_struct_fields_finish(
                    f,
                    "InitializeCompressionParams",
                    names,
                    values,
                )
            }
        }
    }
    pub mod swap_base_input {
        use crate::curve::calculator::CurveCalculator;
        use crate::curve::TradeDirection;
        use crate::error::ErrorCode;
        use crate::states::*;
        use crate::utils::ctoken::get_bumps;
        use crate::utils::token::*;
        use anchor_lang::prelude::*;
        use anchor_lang::solana_program;
        use anchor_spl::token_interface::{Mint, TokenAccount, TokenInterface};
        use light_sdk::compressible::HasCompressionInfo;
        pub struct Swap<'info> {
            /// The user performing the swap
            pub payer: Signer<'info>,
            /// CHECK: pool vault and lp mint authority
            #[account(seeds = [crate::AUTH_SEED.as_bytes()], bump)]
            pub authority: UncheckedAccount<'info>,
            /// The factory state to read protocol fees
            #[account(address = pool_state.amm_config)]
            pub amm_config: Box<Account<'info, AmmConfig>>,
            /// The program account of the pool in which the swap will be performed
            #[account(mut)]
            pub pool_state: Box<Account<'info, PoolState>>,
            /// The user token account for input token
            #[account(mut)]
            pub input_token_account: Box<InterfaceAccount<'info, TokenAccount>>,
            /// The user token account for output token
            #[account(mut)]
            pub output_token_account: Box<InterfaceAccount<'info, TokenAccount>>,
            /// The vault token account for input token
            #[account(
                mut,
                cctoken(variant = Token0Vault|Token1Vault),
                seeds = [POOL_VAULT_SEED.as_bytes(),
                pool_state.key().as_ref(),
                input_token_mint.key().as_ref()],
                bump,
                constraint = input_vault.key(

                )= = pool_state.token_0_vault||input_vault.key(

                )= = pool_state.token_1_vault
            )]
            pub input_vault: Box<InterfaceAccount<'info, TokenAccount>>,
            /// The vault token account for output token
            #[account(
                mut,
                cctoken(variant = Token0Vault|Token1Vault),
                seeds = [POOL_VAULT_SEED.as_bytes(),
                pool_state.key().as_ref(),
                output_token_mint.key().as_ref()],
                bump,
                constraint = output_vault.key(

                )= = pool_state.token_0_vault||output_vault.key(

                )= = pool_state.token_1_vault
            )]
            pub output_vault: Box<InterfaceAccount<'info, TokenAccount>>,
            /// SPL program for input token transfers
            pub input_token_program: Interface<'info, TokenInterface>,
            /// SPL program for output token transfers
            pub output_token_program: Interface<'info, TokenInterface>,
            /// The mint of input token
            #[account(
                address = input_vault.mint,
                mint::token_program = input_token_program.key(),
            )]
            pub input_token_mint: Box<InterfaceAccount<'info, Mint>>,
            /// The mint of output token
            #[account(
                address = output_vault.mint,
                mint::token_program = output_token_program.key(),
            )]
            pub output_token_mint: Box<InterfaceAccount<'info, Mint>>,
            /// The program account for the most recent oracle observation
            #[account(mut, address = pool_state.observation_key)]
            pub observation_state: Account<'info, ObservationState>,
            /// CHECK: checked by protocol.
            pub compressed_token_program_cpi_authority: AccountInfo<'info>,
            /// CHECK: checked by protocol.
            pub compressed_token_program: AccountInfo<'info>,
            /// CHECK: checked by protocol.
            ///
            /// Every mint must be registered in the compression protocol via a
            /// compression_token_pool_pda.
            #[account(mut)]
            pub compressed_token_0_pool_pda: AccountInfo<'info>,
            /// CHECK: checked by protocol.
            #[account(mut)]
            pub compressed_token_1_pool_pda: AccountInfo<'info>,
        }
        #[automatically_derived]
        impl<'info> anchor_lang::Accounts<'info, SwapBumps> for Swap<'info>
        where
            'info: 'info,
        {
            #[inline(never)]
            fn try_accounts(
                __program_id: &anchor_lang::solana_program::pubkey::Pubkey,
                __accounts: &mut &'info [anchor_lang::solana_program::account_info::AccountInfo<
                    'info,
                >],
                __ix_data: &[u8],
                __bumps: &mut SwapBumps,
                __reallocs: &mut std::collections::BTreeSet<
                    anchor_lang::solana_program::pubkey::Pubkey,
                >,
            ) -> anchor_lang::Result<Self> {
                let payer: Signer = anchor_lang::Accounts::try_accounts(
                        __program_id,
                        __accounts,
                        __ix_data,
                        __bumps,
                        __reallocs,
                    )
                    .map_err(|e| e.with_account_name("payer"))?;
                let authority: UncheckedAccount = anchor_lang::Accounts::try_accounts(
                        __program_id,
                        __accounts,
                        __ix_data,
                        __bumps,
                        __reallocs,
                    )
                    .map_err(|e| e.with_account_name("authority"))?;
                let amm_config: Box<
                    anchor_lang::accounts::account::Account<AmmConfig>,
                > = anchor_lang::Accounts::try_accounts(
                        __program_id,
                        __accounts,
                        __ix_data,
                        __bumps,
                        __reallocs,
                    )
                    .map_err(|e| e.with_account_name("amm_config"))?;
                let pool_state: Box<
                    anchor_lang::accounts::account::Account<PoolState>,
                > = anchor_lang::Accounts::try_accounts(
                        __program_id,
                        __accounts,
                        __ix_data,
                        __bumps,
                        __reallocs,
                    )
                    .map_err(|e| e.with_account_name("pool_state"))?;
                let input_token_account: Box<
                    anchor_lang::accounts::interface_account::InterfaceAccount<
                        TokenAccount,
                    >,
                > = anchor_lang::Accounts::try_accounts(
                        __program_id,
                        __accounts,
                        __ix_data,
                        __bumps,
                        __reallocs,
                    )
                    .map_err(|e| e.with_account_name("input_token_account"))?;
                let output_token_account: Box<
                    anchor_lang::accounts::interface_account::InterfaceAccount<
                        TokenAccount,
                    >,
                > = anchor_lang::Accounts::try_accounts(
                        __program_id,
                        __accounts,
                        __ix_data,
                        __bumps,
                        __reallocs,
                    )
                    .map_err(|e| e.with_account_name("output_token_account"))?;
                let input_vault: Box<
                    anchor_lang::accounts::interface_account::InterfaceAccount<
                        TokenAccount,
                    >,
                > = anchor_lang::Accounts::try_accounts(
                        __program_id,
                        __accounts,
                        __ix_data,
                        __bumps,
                        __reallocs,
                    )
                    .map_err(|e| e.with_account_name("input_vault"))?;
                let output_vault: Box<
                    anchor_lang::accounts::interface_account::InterfaceAccount<
                        TokenAccount,
                    >,
                > = anchor_lang::Accounts::try_accounts(
                        __program_id,
                        __accounts,
                        __ix_data,
                        __bumps,
                        __reallocs,
                    )
                    .map_err(|e| e.with_account_name("output_vault"))?;
                let input_token_program: anchor_lang::accounts::interface::Interface<
                    TokenInterface,
                > = anchor_lang::Accounts::try_accounts(
                        __program_id,
                        __accounts,
                        __ix_data,
                        __bumps,
                        __reallocs,
                    )
                    .map_err(|e| e.with_account_name("input_token_program"))?;
                let output_token_program: anchor_lang::accounts::interface::Interface<
                    TokenInterface,
                > = anchor_lang::Accounts::try_accounts(
                        __program_id,
                        __accounts,
                        __ix_data,
                        __bumps,
                        __reallocs,
                    )
                    .map_err(|e| e.with_account_name("output_token_program"))?;
                let input_token_mint: Box<
                    anchor_lang::accounts::interface_account::InterfaceAccount<Mint>,
                > = Box::new({
                    if __accounts.is_empty() {
                        return Err(
                            anchor_lang::error::ErrorCode::AccountNotEnoughKeys.into(),
                        );
                    }
                    let __acc = &__accounts[0];
                    *__accounts = &__accounts[1..];
                    anchor_lang::accounts::interface_account::InterfaceAccount::try_from_with_token_program(
                            __acc,
                            &input_token_program.key(),
                        )
                        .map_err(|e| e.with_account_name("input_token_mint"))?
                });
                let output_token_mint: Box<
                    anchor_lang::accounts::interface_account::InterfaceAccount<Mint>,
                > = Box::new({
                    if __accounts.is_empty() {
                        return Err(
                            anchor_lang::error::ErrorCode::AccountNotEnoughKeys.into(),
                        );
                    }
                    let __acc = &__accounts[0];
                    *__accounts = &__accounts[1..];
                    anchor_lang::accounts::interface_account::InterfaceAccount::try_from_with_token_program(
                            __acc,
                            &output_token_program.key(),
                        )
                        .map_err(|e| e.with_account_name("output_token_mint"))?
                });
                let observation_state: anchor_lang::accounts::account::Account<
                    ObservationState,
                > = anchor_lang::Accounts::try_accounts(
                        __program_id,
                        __accounts,
                        __ix_data,
                        __bumps,
                        __reallocs,
                    )
                    .map_err(|e| e.with_account_name("observation_state"))?;
                let compressed_token_program_cpi_authority: AccountInfo = anchor_lang::Accounts::try_accounts(
                        __program_id,
                        __accounts,
                        __ix_data,
                        __bumps,
                        __reallocs,
                    )
                    .map_err(|e| {
                        e.with_account_name("compressed_token_program_cpi_authority")
                    })?;
                let compressed_token_program: AccountInfo = anchor_lang::Accounts::try_accounts(
                        __program_id,
                        __accounts,
                        __ix_data,
                        __bumps,
                        __reallocs,
                    )
                    .map_err(|e| e.with_account_name("compressed_token_program"))?;
                let compressed_token_0_pool_pda: AccountInfo = anchor_lang::Accounts::try_accounts(
                        __program_id,
                        __accounts,
                        __ix_data,
                        __bumps,
                        __reallocs,
                    )
                    .map_err(|e| e.with_account_name("compressed_token_0_pool_pda"))?;
                let compressed_token_1_pool_pda: AccountInfo = anchor_lang::Accounts::try_accounts(
                        __program_id,
                        __accounts,
                        __ix_data,
                        __bumps,
                        __reallocs,
                    )
                    .map_err(|e| e.with_account_name("compressed_token_1_pool_pda"))?;
                let (__pda_address, __bump) = Pubkey::find_program_address(
                    &[crate::AUTH_SEED.as_bytes()],
                    &__program_id,
                );
                __bumps.authority = __bump;
                if authority.key() != __pda_address {
                    return Err(
                        anchor_lang::error::Error::from(
                                anchor_lang::error::ErrorCode::ConstraintSeeds,
                            )
                            .with_account_name("authority")
                            .with_pubkeys((authority.key(), __pda_address)),
                    );
                }
                {
                    let actual = amm_config.key();
                    let expected = pool_state.amm_config;
                    if actual != expected {
                        return Err(
                            anchor_lang::error::Error::from(
                                    anchor_lang::error::ErrorCode::ConstraintAddress,
                                )
                                .with_account_name("amm_config")
                                .with_pubkeys((actual, expected)),
                        );
                    }
                }
                if !AsRef::<AccountInfo>::as_ref(pool_state.as_ref()).is_writable {
                    return Err(
                        anchor_lang::error::Error::from(
                                anchor_lang::error::ErrorCode::ConstraintMut,
                            )
                            .with_account_name("pool_state"),
                    );
                }
                if !AsRef::<AccountInfo>::as_ref(input_token_account.as_ref())
                    .is_writable
                {
                    return Err(
                        anchor_lang::error::Error::from(
                                anchor_lang::error::ErrorCode::ConstraintMut,
                            )
                            .with_account_name("input_token_account"),
                    );
                }
                if !AsRef::<AccountInfo>::as_ref(output_token_account.as_ref())
                    .is_writable
                {
                    return Err(
                        anchor_lang::error::Error::from(
                                anchor_lang::error::ErrorCode::ConstraintMut,
                            )
                            .with_account_name("output_token_account"),
                    );
                }
                let (__pda_address, __bump) = Pubkey::find_program_address(
                    &[
                        POOL_VAULT_SEED.as_bytes(),
                        pool_state.key().as_ref(),
                        input_token_mint.key().as_ref(),
                    ],
                    &__program_id,
                );
                __bumps.input_vault = __bump;
                if input_vault.key() != __pda_address {
                    return Err(
                        anchor_lang::error::Error::from(
                                anchor_lang::error::ErrorCode::ConstraintSeeds,
                            )
                            .with_account_name("input_vault")
                            .with_pubkeys((input_vault.key(), __pda_address)),
                    );
                }
                if !AsRef::<AccountInfo>::as_ref(input_vault.as_ref()).is_writable {
                    return Err(
                        anchor_lang::error::Error::from(
                                anchor_lang::error::ErrorCode::ConstraintMut,
                            )
                            .with_account_name("input_vault"),
                    );
                }
                if !(input_vault.key() == pool_state.token_0_vault
                    || input_vault.key() == pool_state.token_1_vault)
                {
                    return Err(
                        anchor_lang::error::Error::from(
                                anchor_lang::error::ErrorCode::ConstraintRaw,
                            )
                            .with_account_name("input_vault"),
                    );
                }
                let (__pda_address, __bump) = Pubkey::find_program_address(
                    &[
                        POOL_VAULT_SEED.as_bytes(),
                        pool_state.key().as_ref(),
                        output_token_mint.key().as_ref(),
                    ],
                    &__program_id,
                );
                __bumps.output_vault = __bump;
                if output_vault.key() != __pda_address {
                    return Err(
                        anchor_lang::error::Error::from(
                                anchor_lang::error::ErrorCode::ConstraintSeeds,
                            )
                            .with_account_name("output_vault")
                            .with_pubkeys((output_vault.key(), __pda_address)),
                    );
                }
                if !AsRef::<AccountInfo>::as_ref(output_vault.as_ref()).is_writable {
                    return Err(
                        anchor_lang::error::Error::from(
                                anchor_lang::error::ErrorCode::ConstraintMut,
                            )
                            .with_account_name("output_vault"),
                    );
                }
                if !(output_vault.key() == pool_state.token_0_vault
                    || output_vault.key() == pool_state.token_1_vault)
                {
                    return Err(
                        anchor_lang::error::Error::from(
                                anchor_lang::error::ErrorCode::ConstraintRaw,
                            )
                            .with_account_name("output_vault"),
                    );
                }
                {
                    let actual = input_token_mint.key();
                    let expected = input_vault.mint;
                    if actual != expected {
                        return Err(
                            anchor_lang::error::Error::from(
                                    anchor_lang::error::ErrorCode::ConstraintAddress,
                                )
                                .with_account_name("input_token_mint")
                                .with_pubkeys((actual, expected)),
                        );
                    }
                }
                {
                    let __is_ctoken = input_token_program.key()
                        == anchor_lang::CTOKEN_ID;
                    if __is_ctoken {
                        if AsRef::<AccountInfo>::as_ref(input_token_mint.as_ref()).owner
                            != &anchor_lang::solana_program::system_program::ID
                        {
                            return Err(
                                anchor_lang::error::ErrorCode::ConstraintMintTokenProgram
                                    .into(),
                            );
                        }
                    } else {
                        if AsRef::<AccountInfo>::as_ref(input_token_mint.as_ref()).owner
                            != &input_token_program.key()
                        {
                            return Err(
                                anchor_lang::error::ErrorCode::ConstraintMintTokenProgram
                                    .into(),
                            );
                        }
                    }
                    if !__is_ctoken {}
                }
                {
                    let actual = output_token_mint.key();
                    let expected = output_vault.mint;
                    if actual != expected {
                        return Err(
                            anchor_lang::error::Error::from(
                                    anchor_lang::error::ErrorCode::ConstraintAddress,
                                )
                                .with_account_name("output_token_mint")
                                .with_pubkeys((actual, expected)),
                        );
                    }
                }
                {
                    let __is_ctoken = output_token_program.key()
                        == anchor_lang::CTOKEN_ID;
                    if __is_ctoken {
                        if AsRef::<AccountInfo>::as_ref(output_token_mint.as_ref()).owner
                            != &anchor_lang::solana_program::system_program::ID
                        {
                            return Err(
                                anchor_lang::error::ErrorCode::ConstraintMintTokenProgram
                                    .into(),
                            );
                        }
                    } else {
                        if AsRef::<AccountInfo>::as_ref(output_token_mint.as_ref()).owner
                            != &output_token_program.key()
                        {
                            return Err(
                                anchor_lang::error::ErrorCode::ConstraintMintTokenProgram
                                    .into(),
                            );
                        }
                    }
                    if !__is_ctoken {}
                }
                if !AsRef::<AccountInfo>::as_ref(&observation_state).is_writable {
                    return Err(
                        anchor_lang::error::Error::from(
                                anchor_lang::error::ErrorCode::ConstraintMut,
                            )
                            .with_account_name("observation_state"),
                    );
                }
                {
                    let actual = observation_state.key();
                    let expected = pool_state.observation_key;
                    if actual != expected {
                        return Err(
                            anchor_lang::error::Error::from(
                                    anchor_lang::error::ErrorCode::ConstraintAddress,
                                )
                                .with_account_name("observation_state")
                                .with_pubkeys((actual, expected)),
                        );
                    }
                }
                if !&compressed_token_0_pool_pda.is_writable {
                    return Err(
                        anchor_lang::error::Error::from(
                                anchor_lang::error::ErrorCode::ConstraintMut,
                            )
                            .with_account_name("compressed_token_0_pool_pda"),
                    );
                }
                if !&compressed_token_1_pool_pda.is_writable {
                    return Err(
                        anchor_lang::error::Error::from(
                                anchor_lang::error::ErrorCode::ConstraintMut,
                            )
                            .with_account_name("compressed_token_1_pool_pda"),
                    );
                }
                Ok(Swap {
                    payer,
                    authority,
                    amm_config,
                    pool_state,
                    input_token_account,
                    output_token_account,
                    input_vault,
                    output_vault,
                    input_token_program,
                    output_token_program,
                    input_token_mint,
                    output_token_mint,
                    observation_state,
                    compressed_token_program_cpi_authority,
                    compressed_token_program,
                    compressed_token_0_pool_pda,
                    compressed_token_1_pool_pda,
                })
            }
        }
        #[automatically_derived]
        impl<'info> anchor_lang::ToAccountInfos<'info> for Swap<'info>
        where
            'info: 'info,
        {
            fn to_account_infos(
                &self,
            ) -> Vec<anchor_lang::solana_program::account_info::AccountInfo<'info>> {
                let mut account_infos = ::alloc::vec::Vec::new();
                account_infos.extend(self.payer.to_account_infos());
                account_infos.extend(self.authority.to_account_infos());
                account_infos.extend(self.amm_config.to_account_infos());
                account_infos.extend(self.pool_state.to_account_infos());
                account_infos.extend(self.input_token_account.to_account_infos());
                account_infos.extend(self.output_token_account.to_account_infos());
                account_infos.extend(self.input_vault.to_account_infos());
                account_infos.extend(self.output_vault.to_account_infos());
                account_infos.extend(self.input_token_program.to_account_infos());
                account_infos.extend(self.output_token_program.to_account_infos());
                account_infos.extend(self.input_token_mint.to_account_infos());
                account_infos.extend(self.output_token_mint.to_account_infos());
                account_infos.extend(self.observation_state.to_account_infos());
                account_infos
                    .extend(
                        self.compressed_token_program_cpi_authority.to_account_infos(),
                    );
                account_infos.extend(self.compressed_token_program.to_account_infos());
                account_infos
                    .extend(self.compressed_token_0_pool_pda.to_account_infos());
                account_infos
                    .extend(self.compressed_token_1_pool_pda.to_account_infos());
                account_infos
            }
        }
        #[automatically_derived]
        impl<'info> anchor_lang::ToAccountMetas for Swap<'info> {
            fn to_account_metas(
                &self,
                is_signer: Option<bool>,
            ) -> Vec<anchor_lang::solana_program::instruction::AccountMeta> {
                let mut account_metas = ::alloc::vec::Vec::new();
                account_metas.extend(self.payer.to_account_metas(None));
                account_metas.extend(self.authority.to_account_metas(None));
                account_metas.extend(self.amm_config.to_account_metas(None));
                account_metas.extend(self.pool_state.to_account_metas(None));
                account_metas.extend(self.input_token_account.to_account_metas(None));
                account_metas.extend(self.output_token_account.to_account_metas(None));
                account_metas.extend(self.input_vault.to_account_metas(None));
                account_metas.extend(self.output_vault.to_account_metas(None));
                account_metas.extend(self.input_token_program.to_account_metas(None));
                account_metas.extend(self.output_token_program.to_account_metas(None));
                account_metas.extend(self.input_token_mint.to_account_metas(None));
                account_metas.extend(self.output_token_mint.to_account_metas(None));
                account_metas.extend(self.observation_state.to_account_metas(None));
                account_metas
                    .extend(
                        self
                            .compressed_token_program_cpi_authority
                            .to_account_metas(None),
                    );
                account_metas
                    .extend(self.compressed_token_program.to_account_metas(None));
                account_metas
                    .extend(self.compressed_token_0_pool_pda.to_account_metas(None));
                account_metas
                    .extend(self.compressed_token_1_pool_pda.to_account_metas(None));
                account_metas
            }
        }
        #[automatically_derived]
        impl<'info> anchor_lang::AccountsFinalize<'info, SwapBumps> for Swap<'info>
        where
            'info: 'info,
        {
            fn finalize(
                &mut self,
                program_id: &anchor_lang::solana_program::pubkey::Pubkey,
                _remaining: &[anchor_lang::solana_program::account_info::AccountInfo<
                    'info,
                >],
                _ix_data: &[u8],
                _bumps: &SwapBumps,
            ) -> anchor_lang::Result<()> {
                anchor_lang::AccountsFinalize::finalize(
                        &mut self.amm_config,
                        program_id,
                        _remaining,
                        _ix_data,
                        _bumps,
                    )
                    .map_err(|e| e.with_account_name("amm_config"))?;
                anchor_lang::AccountsFinalize::finalize(
                        &mut self.pool_state,
                        program_id,
                        _remaining,
                        _ix_data,
                        _bumps,
                    )
                    .map_err(|e| e.with_account_name("pool_state"))?;
                anchor_lang::AccountsFinalize::finalize(
                        &mut self.input_token_account,
                        program_id,
                        _remaining,
                        _ix_data,
                        _bumps,
                    )
                    .map_err(|e| e.with_account_name("input_token_account"))?;
                anchor_lang::AccountsFinalize::finalize(
                        &mut self.output_token_account,
                        program_id,
                        _remaining,
                        _ix_data,
                        _bumps,
                    )
                    .map_err(|e| e.with_account_name("output_token_account"))?;
                anchor_lang::AccountsFinalize::finalize(
                        &mut self.input_vault,
                        program_id,
                        _remaining,
                        _ix_data,
                        _bumps,
                    )
                    .map_err(|e| e.with_account_name("input_vault"))?;
                anchor_lang::AccountsFinalize::finalize(
                        &mut self.output_vault,
                        program_id,
                        _remaining,
                        _ix_data,
                        _bumps,
                    )
                    .map_err(|e| e.with_account_name("output_vault"))?;
                anchor_lang::AccountsFinalize::finalize(
                        &mut self.input_token_program,
                        program_id,
                        _remaining,
                        _ix_data,
                        _bumps,
                    )
                    .map_err(|e| e.with_account_name("input_token_program"))?;
                anchor_lang::AccountsFinalize::finalize(
                        &mut self.output_token_program,
                        program_id,
                        _remaining,
                        _ix_data,
                        _bumps,
                    )
                    .map_err(|e| e.with_account_name("output_token_program"))?;
                anchor_lang::AccountsFinalize::finalize(
                        &mut self.input_token_mint,
                        program_id,
                        _remaining,
                        _ix_data,
                        _bumps,
                    )
                    .map_err(|e| e.with_account_name("input_token_mint"))?;
                anchor_lang::AccountsFinalize::finalize(
                        &mut self.output_token_mint,
                        program_id,
                        _remaining,
                        _ix_data,
                        _bumps,
                    )
                    .map_err(|e| e.with_account_name("output_token_mint"))?;
                anchor_lang::AccountsFinalize::finalize(
                        &mut self.observation_state,
                        program_id,
                        _remaining,
                        _ix_data,
                        _bumps,
                    )
                    .map_err(|e| e.with_account_name("observation_state"))?;
                Ok(())
            }
        }
        #[automatically_derived]
        impl<'info> anchor_lang::AccountsExit<'info> for Swap<'info>
        where
            'info: 'info,
        {
            fn exit(
                &self,
                program_id: &anchor_lang::solana_program::pubkey::Pubkey,
            ) -> anchor_lang::Result<()> {
                anchor_lang::AccountsExit::exit(&self.pool_state, program_id)
                    .map_err(|e| e.with_account_name("pool_state"))?;
                anchor_lang::AccountsExit::exit(&self.input_token_account, program_id)
                    .map_err(|e| e.with_account_name("input_token_account"))?;
                anchor_lang::AccountsExit::exit(&self.output_token_account, program_id)
                    .map_err(|e| e.with_account_name("output_token_account"))?;
                anchor_lang::AccountsExit::exit(&self.input_vault, program_id)
                    .map_err(|e| e.with_account_name("input_vault"))?;
                anchor_lang::AccountsExit::exit(&self.output_vault, program_id)
                    .map_err(|e| e.with_account_name("output_vault"))?;
                anchor_lang::AccountsExit::exit(&self.observation_state, program_id)
                    .map_err(|e| e.with_account_name("observation_state"))?;
                anchor_lang::AccountsExit::exit(
                        &self.compressed_token_0_pool_pda,
                        program_id,
                    )
                    .map_err(|e| e.with_account_name("compressed_token_0_pool_pda"))?;
                anchor_lang::AccountsExit::exit(
                        &self.compressed_token_1_pool_pda,
                        program_id,
                    )
                    .map_err(|e| e.with_account_name("compressed_token_1_pool_pda"))?;
                Ok(())
            }
        }
        pub struct SwapBumps {
            pub authority: u8,
            pub input_vault: u8,
            pub output_vault: u8,
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for SwapBumps {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field3_finish(
                    f,
                    "SwapBumps",
                    "authority",
                    &self.authority,
                    "input_vault",
                    &self.input_vault,
                    "output_vault",
                    &&self.output_vault,
                )
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for SwapBumps {
            #[inline]
            fn clone(&self) -> SwapBumps {
                SwapBumps {
                    authority: ::core::clone::Clone::clone(&self.authority),
                    input_vault: ::core::clone::Clone::clone(&self.input_vault),
                    output_vault: ::core::clone::Clone::clone(&self.output_vault),
                }
            }
        }
        impl Default for SwapBumps {
            fn default() -> Self {
                SwapBumps {
                    authority: u8::MAX,
                    input_vault: u8::MAX,
                    output_vault: u8::MAX,
                }
            }
        }
        impl<'info> anchor_lang::Bumps for Swap<'info>
        where
            'info: 'info,
        {
            type Bumps = SwapBumps;
        }
        /// An internal, Anchor generated module. This is used (as an
        /// implementation detail), to generate a struct for a given
        /// `#[derive(Accounts)]` implementation, where each field is a Pubkey,
        /// instead of an `AccountInfo`. This is useful for clients that want
        /// to generate a list of accounts, without explicitly knowing the
        /// order all the fields should be in.
        ///
        /// To access the struct in this module, one should use the sibling
        /// `accounts` module (also generated), which re-exports this.
        pub(crate) mod __client_accounts_swap {
            use super::*;
            use anchor_lang::prelude::borsh;
            /// Generated client accounts for [`Swap`].
            pub struct Swap {
                ///The user performing the swap
                pub payer: Pubkey,
                pub authority: Pubkey,
                ///The factory state to read protocol fees
                pub amm_config: Pubkey,
                ///The program account of the pool in which the swap will be performed
                pub pool_state: Pubkey,
                ///The user token account for input token
                pub input_token_account: Pubkey,
                ///The user token account for output token
                pub output_token_account: Pubkey,
                ///The vault token account for input token
                pub input_vault: Pubkey,
                ///The vault token account for output token
                pub output_vault: Pubkey,
                ///SPL program for input token transfers
                pub input_token_program: Pubkey,
                ///SPL program for output token transfers
                pub output_token_program: Pubkey,
                ///The mint of input token
                pub input_token_mint: Pubkey,
                ///The mint of output token
                pub output_token_mint: Pubkey,
                ///The program account for the most recent oracle observation
                pub observation_state: Pubkey,
                pub compressed_token_program_cpi_authority: Pubkey,
                pub compressed_token_program: Pubkey,
                ///
                ///Every mint must be registered in the compression protocol via a
                ///compression_token_pool_pda.
                pub compressed_token_0_pool_pda: Pubkey,
                pub compressed_token_1_pool_pda: Pubkey,
            }
            impl borsh::ser::BorshSerialize for Swap
            where
                Pubkey: borsh::ser::BorshSerialize,
                Pubkey: borsh::ser::BorshSerialize,
                Pubkey: borsh::ser::BorshSerialize,
                Pubkey: borsh::ser::BorshSerialize,
                Pubkey: borsh::ser::BorshSerialize,
                Pubkey: borsh::ser::BorshSerialize,
                Pubkey: borsh::ser::BorshSerialize,
                Pubkey: borsh::ser::BorshSerialize,
                Pubkey: borsh::ser::BorshSerialize,
                Pubkey: borsh::ser::BorshSerialize,
                Pubkey: borsh::ser::BorshSerialize,
                Pubkey: borsh::ser::BorshSerialize,
                Pubkey: borsh::ser::BorshSerialize,
                Pubkey: borsh::ser::BorshSerialize,
                Pubkey: borsh::ser::BorshSerialize,
                Pubkey: borsh::ser::BorshSerialize,
                Pubkey: borsh::ser::BorshSerialize,
            {
                fn serialize<W: borsh::maybestd::io::Write>(
                    &self,
                    writer: &mut W,
                ) -> ::core::result::Result<(), borsh::maybestd::io::Error> {
                    borsh::BorshSerialize::serialize(&self.payer, writer)?;
                    borsh::BorshSerialize::serialize(&self.authority, writer)?;
                    borsh::BorshSerialize::serialize(&self.amm_config, writer)?;
                    borsh::BorshSerialize::serialize(&self.pool_state, writer)?;
                    borsh::BorshSerialize::serialize(&self.input_token_account, writer)?;
                    borsh::BorshSerialize::serialize(
                        &self.output_token_account,
                        writer,
                    )?;
                    borsh::BorshSerialize::serialize(&self.input_vault, writer)?;
                    borsh::BorshSerialize::serialize(&self.output_vault, writer)?;
                    borsh::BorshSerialize::serialize(&self.input_token_program, writer)?;
                    borsh::BorshSerialize::serialize(
                        &self.output_token_program,
                        writer,
                    )?;
                    borsh::BorshSerialize::serialize(&self.input_token_mint, writer)?;
                    borsh::BorshSerialize::serialize(&self.output_token_mint, writer)?;
                    borsh::BorshSerialize::serialize(&self.observation_state, writer)?;
                    borsh::BorshSerialize::serialize(
                        &self.compressed_token_program_cpi_authority,
                        writer,
                    )?;
                    borsh::BorshSerialize::serialize(
                        &self.compressed_token_program,
                        writer,
                    )?;
                    borsh::BorshSerialize::serialize(
                        &self.compressed_token_0_pool_pda,
                        writer,
                    )?;
                    borsh::BorshSerialize::serialize(
                        &self.compressed_token_1_pool_pda,
                        writer,
                    )?;
                    Ok(())
                }
            }
            impl anchor_lang::idl::build::IdlBuild for Swap {
                fn create_type() -> Option<anchor_lang::idl::types::IdlTypeDef> {
                    Some(anchor_lang::idl::types::IdlTypeDef {
                        name: Self::get_full_path(),
                        docs: <[_]>::into_vec(
                            ::alloc::boxed::box_new([
                                "Generated client accounts for [`Swap`].".into(),
                            ]),
                        ),
                        serialization: anchor_lang::idl::types::IdlSerialization::default(),
                        repr: None,
                        generics: ::alloc::vec::Vec::new(),
                        ty: anchor_lang::idl::types::IdlTypeDefTy::Struct {
                            fields: Some(
                                anchor_lang::idl::types::IdlDefinedFields::Named(
                                    <[_]>::into_vec(
                                        ::alloc::boxed::box_new([
                                            anchor_lang::idl::types::IdlField {
                                                name: "payer".into(),
                                                docs: <[_]>::into_vec(
                                                    ::alloc::boxed::box_new([
                                                        "The user performing the swap".into(),
                                                    ]),
                                                ),
                                                ty: anchor_lang::idl::types::IdlType::Pubkey,
                                            },
                                            anchor_lang::idl::types::IdlField {
                                                name: "authority".into(),
                                                docs: ::alloc::vec::Vec::new(),
                                                ty: anchor_lang::idl::types::IdlType::Pubkey,
                                            },
                                            anchor_lang::idl::types::IdlField {
                                                name: "amm_config".into(),
                                                docs: <[_]>::into_vec(
                                                    ::alloc::boxed::box_new([
                                                        "The factory state to read protocol fees".into(),
                                                    ]),
                                                ),
                                                ty: anchor_lang::idl::types::IdlType::Pubkey,
                                            },
                                            anchor_lang::idl::types::IdlField {
                                                name: "pool_state".into(),
                                                docs: <[_]>::into_vec(
                                                    ::alloc::boxed::box_new([
                                                        "The program account of the pool in which the swap will be performed"
                                                            .into(),
                                                    ]),
                                                ),
                                                ty: anchor_lang::idl::types::IdlType::Pubkey,
                                            },
                                            anchor_lang::idl::types::IdlField {
                                                name: "input_token_account".into(),
                                                docs: <[_]>::into_vec(
                                                    ::alloc::boxed::box_new([
                                                        "The user token account for input token".into(),
                                                    ]),
                                                ),
                                                ty: anchor_lang::idl::types::IdlType::Pubkey,
                                            },
                                            anchor_lang::idl::types::IdlField {
                                                name: "output_token_account".into(),
                                                docs: <[_]>::into_vec(
                                                    ::alloc::boxed::box_new([
                                                        "The user token account for output token".into(),
                                                    ]),
                                                ),
                                                ty: anchor_lang::idl::types::IdlType::Pubkey,
                                            },
                                            anchor_lang::idl::types::IdlField {
                                                name: "input_vault".into(),
                                                docs: <[_]>::into_vec(
                                                    ::alloc::boxed::box_new([
                                                        "The vault token account for input token".into(),
                                                    ]),
                                                ),
                                                ty: anchor_lang::idl::types::IdlType::Pubkey,
                                            },
                                            anchor_lang::idl::types::IdlField {
                                                name: "output_vault".into(),
                                                docs: <[_]>::into_vec(
                                                    ::alloc::boxed::box_new([
                                                        "The vault token account for output token".into(),
                                                    ]),
                                                ),
                                                ty: anchor_lang::idl::types::IdlType::Pubkey,
                                            },
                                            anchor_lang::idl::types::IdlField {
                                                name: "input_token_program".into(),
                                                docs: <[_]>::into_vec(
                                                    ::alloc::boxed::box_new([
                                                        "SPL program for input token transfers".into(),
                                                    ]),
                                                ),
                                                ty: anchor_lang::idl::types::IdlType::Pubkey,
                                            },
                                            anchor_lang::idl::types::IdlField {
                                                name: "output_token_program".into(),
                                                docs: <[_]>::into_vec(
                                                    ::alloc::boxed::box_new([
                                                        "SPL program for output token transfers".into(),
                                                    ]),
                                                ),
                                                ty: anchor_lang::idl::types::IdlType::Pubkey,
                                            },
                                            anchor_lang::idl::types::IdlField {
                                                name: "input_token_mint".into(),
                                                docs: <[_]>::into_vec(
                                                    ::alloc::boxed::box_new(["The mint of input token".into()]),
                                                ),
                                                ty: anchor_lang::idl::types::IdlType::Pubkey,
                                            },
                                            anchor_lang::idl::types::IdlField {
                                                name: "output_token_mint".into(),
                                                docs: <[_]>::into_vec(
                                                    ::alloc::boxed::box_new(["The mint of output token".into()]),
                                                ),
                                                ty: anchor_lang::idl::types::IdlType::Pubkey,
                                            },
                                            anchor_lang::idl::types::IdlField {
                                                name: "observation_state".into(),
                                                docs: <[_]>::into_vec(
                                                    ::alloc::boxed::box_new([
                                                        "The program account for the most recent oracle observation"
                                                            .into(),
                                                    ]),
                                                ),
                                                ty: anchor_lang::idl::types::IdlType::Pubkey,
                                            },
                                            anchor_lang::idl::types::IdlField {
                                                name: "compressed_token_program_cpi_authority".into(),
                                                docs: ::alloc::vec::Vec::new(),
                                                ty: anchor_lang::idl::types::IdlType::Pubkey,
                                            },
                                            anchor_lang::idl::types::IdlField {
                                                name: "compressed_token_program".into(),
                                                docs: ::alloc::vec::Vec::new(),
                                                ty: anchor_lang::idl::types::IdlType::Pubkey,
                                            },
                                            anchor_lang::idl::types::IdlField {
                                                name: "compressed_token_0_pool_pda".into(),
                                                docs: <[_]>::into_vec(
                                                    ::alloc::boxed::box_new([
                                                        "".into(),
                                                        "Every mint must be registered in the compression protocol via a"
                                                            .into(),
                                                        "compression_token_pool_pda.".into(),
                                                    ]),
                                                ),
                                                ty: anchor_lang::idl::types::IdlType::Pubkey,
                                            },
                                            anchor_lang::idl::types::IdlField {
                                                name: "compressed_token_1_pool_pda".into(),
                                                docs: ::alloc::vec::Vec::new(),
                                                ty: anchor_lang::idl::types::IdlType::Pubkey,
                                            },
                                        ]),
                                    ),
                                ),
                            ),
                        },
                    })
                }
                fn insert_types(
                    types: &mut std::collections::BTreeMap<
                        String,
                        anchor_lang::idl::types::IdlTypeDef,
                    >,
                ) {}
                fn get_full_path() -> String {
                    ::alloc::__export::must_use({
                        ::alloc::fmt::format(
                            format_args!(
                                "{0}::{1}",
                                "raydium_cp_swap::instructions::swap_base_input::__client_accounts_swap",
                                "Swap",
                            ),
                        )
                    })
                }
            }
            #[automatically_derived]
            impl anchor_lang::ToAccountMetas for Swap {
                fn to_account_metas(
                    &self,
                    is_signer: Option<bool>,
                ) -> Vec<anchor_lang::solana_program::instruction::AccountMeta> {
                    let mut account_metas = ::alloc::vec::Vec::new();
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                                self.payer,
                                true,
                            ),
                        );
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                                self.authority,
                                false,
                            ),
                        );
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                                self.amm_config,
                                false,
                            ),
                        );
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new(
                                self.pool_state,
                                false,
                            ),
                        );
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new(
                                self.input_token_account,
                                false,
                            ),
                        );
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new(
                                self.output_token_account,
                                false,
                            ),
                        );
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new(
                                self.input_vault,
                                false,
                            ),
                        );
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new(
                                self.output_vault,
                                false,
                            ),
                        );
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                                self.input_token_program,
                                false,
                            ),
                        );
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                                self.output_token_program,
                                false,
                            ),
                        );
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                                self.input_token_mint,
                                false,
                            ),
                        );
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                                self.output_token_mint,
                                false,
                            ),
                        );
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new(
                                self.observation_state,
                                false,
                            ),
                        );
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                                self.compressed_token_program_cpi_authority,
                                false,
                            ),
                        );
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                                self.compressed_token_program,
                                false,
                            ),
                        );
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new(
                                self.compressed_token_0_pool_pda,
                                false,
                            ),
                        );
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new(
                                self.compressed_token_1_pool_pda,
                                false,
                            ),
                        );
                    account_metas
                }
            }
        }
        /// An internal, Anchor generated module. This is used (as an
        /// implementation detail), to generate a CPI struct for a given
        /// `#[derive(Accounts)]` implementation, where each field is an
        /// AccountInfo.
        ///
        /// To access the struct in this module, one should use the sibling
        /// [`cpi::accounts`] module (also generated), which re-exports this.
        pub(crate) mod __cpi_client_accounts_swap {
            use super::*;
            /// Generated CPI struct of the accounts for [`Swap`].
            pub struct Swap<'info> {
                ///The user performing the swap
                pub payer: anchor_lang::solana_program::account_info::AccountInfo<'info>,
                pub authority: anchor_lang::solana_program::account_info::AccountInfo<
                    'info,
                >,
                ///The factory state to read protocol fees
                pub amm_config: anchor_lang::solana_program::account_info::AccountInfo<
                    'info,
                >,
                ///The program account of the pool in which the swap will be performed
                pub pool_state: anchor_lang::solana_program::account_info::AccountInfo<
                    'info,
                >,
                ///The user token account for input token
                pub input_token_account: anchor_lang::solana_program::account_info::AccountInfo<
                    'info,
                >,
                ///The user token account for output token
                pub output_token_account: anchor_lang::solana_program::account_info::AccountInfo<
                    'info,
                >,
                ///The vault token account for input token
                pub input_vault: anchor_lang::solana_program::account_info::AccountInfo<
                    'info,
                >,
                ///The vault token account for output token
                pub output_vault: anchor_lang::solana_program::account_info::AccountInfo<
                    'info,
                >,
                ///SPL program for input token transfers
                pub input_token_program: anchor_lang::solana_program::account_info::AccountInfo<
                    'info,
                >,
                ///SPL program for output token transfers
                pub output_token_program: anchor_lang::solana_program::account_info::AccountInfo<
                    'info,
                >,
                ///The mint of input token
                pub input_token_mint: anchor_lang::solana_program::account_info::AccountInfo<
                    'info,
                >,
                ///The mint of output token
                pub output_token_mint: anchor_lang::solana_program::account_info::AccountInfo<
                    'info,
                >,
                ///The program account for the most recent oracle observation
                pub observation_state: anchor_lang::solana_program::account_info::AccountInfo<
                    'info,
                >,
                pub compressed_token_program_cpi_authority: anchor_lang::solana_program::account_info::AccountInfo<
                    'info,
                >,
                pub compressed_token_program: anchor_lang::solana_program::account_info::AccountInfo<
                    'info,
                >,
                ///
                ///Every mint must be registered in the compression protocol via a
                ///compression_token_pool_pda.
                pub compressed_token_0_pool_pda: anchor_lang::solana_program::account_info::AccountInfo<
                    'info,
                >,
                pub compressed_token_1_pool_pda: anchor_lang::solana_program::account_info::AccountInfo<
                    'info,
                >,
            }
            #[automatically_derived]
            impl<'info> anchor_lang::ToAccountMetas for Swap<'info> {
                fn to_account_metas(
                    &self,
                    is_signer: Option<bool>,
                ) -> Vec<anchor_lang::solana_program::instruction::AccountMeta> {
                    let mut account_metas = ::alloc::vec::Vec::new();
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                                anchor_lang::Key::key(&self.payer),
                                true,
                            ),
                        );
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                                anchor_lang::Key::key(&self.authority),
                                false,
                            ),
                        );
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                                anchor_lang::Key::key(&self.amm_config),
                                false,
                            ),
                        );
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new(
                                anchor_lang::Key::key(&self.pool_state),
                                false,
                            ),
                        );
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new(
                                anchor_lang::Key::key(&self.input_token_account),
                                false,
                            ),
                        );
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new(
                                anchor_lang::Key::key(&self.output_token_account),
                                false,
                            ),
                        );
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new(
                                anchor_lang::Key::key(&self.input_vault),
                                false,
                            ),
                        );
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new(
                                anchor_lang::Key::key(&self.output_vault),
                                false,
                            ),
                        );
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                                anchor_lang::Key::key(&self.input_token_program),
                                false,
                            ),
                        );
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                                anchor_lang::Key::key(&self.output_token_program),
                                false,
                            ),
                        );
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                                anchor_lang::Key::key(&self.input_token_mint),
                                false,
                            ),
                        );
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                                anchor_lang::Key::key(&self.output_token_mint),
                                false,
                            ),
                        );
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new(
                                anchor_lang::Key::key(&self.observation_state),
                                false,
                            ),
                        );
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                                anchor_lang::Key::key(
                                    &self.compressed_token_program_cpi_authority,
                                ),
                                false,
                            ),
                        );
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                                anchor_lang::Key::key(&self.compressed_token_program),
                                false,
                            ),
                        );
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new(
                                anchor_lang::Key::key(&self.compressed_token_0_pool_pda),
                                false,
                            ),
                        );
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new(
                                anchor_lang::Key::key(&self.compressed_token_1_pool_pda),
                                false,
                            ),
                        );
                    account_metas
                }
            }
            #[automatically_derived]
            impl<'info> anchor_lang::ToAccountInfos<'info> for Swap<'info> {
                fn to_account_infos(
                    &self,
                ) -> Vec<anchor_lang::solana_program::account_info::AccountInfo<'info>> {
                    let mut account_infos = ::alloc::vec::Vec::new();
                    account_infos
                        .extend(
                            anchor_lang::ToAccountInfos::to_account_infos(&self.payer),
                        );
                    account_infos
                        .extend(
                            anchor_lang::ToAccountInfos::to_account_infos(
                                &self.authority,
                            ),
                        );
                    account_infos
                        .extend(
                            anchor_lang::ToAccountInfos::to_account_infos(
                                &self.amm_config,
                            ),
                        );
                    account_infos
                        .extend(
                            anchor_lang::ToAccountInfos::to_account_infos(
                                &self.pool_state,
                            ),
                        );
                    account_infos
                        .extend(
                            anchor_lang::ToAccountInfos::to_account_infos(
                                &self.input_token_account,
                            ),
                        );
                    account_infos
                        .extend(
                            anchor_lang::ToAccountInfos::to_account_infos(
                                &self.output_token_account,
                            ),
                        );
                    account_infos
                        .extend(
                            anchor_lang::ToAccountInfos::to_account_infos(
                                &self.input_vault,
                            ),
                        );
                    account_infos
                        .extend(
                            anchor_lang::ToAccountInfos::to_account_infos(
                                &self.output_vault,
                            ),
                        );
                    account_infos
                        .extend(
                            anchor_lang::ToAccountInfos::to_account_infos(
                                &self.input_token_program,
                            ),
                        );
                    account_infos
                        .extend(
                            anchor_lang::ToAccountInfos::to_account_infos(
                                &self.output_token_program,
                            ),
                        );
                    account_infos
                        .extend(
                            anchor_lang::ToAccountInfos::to_account_infos(
                                &self.input_token_mint,
                            ),
                        );
                    account_infos
                        .extend(
                            anchor_lang::ToAccountInfos::to_account_infos(
                                &self.output_token_mint,
                            ),
                        );
                    account_infos
                        .extend(
                            anchor_lang::ToAccountInfos::to_account_infos(
                                &self.observation_state,
                            ),
                        );
                    account_infos
                        .extend(
                            anchor_lang::ToAccountInfos::to_account_infos(
                                &self.compressed_token_program_cpi_authority,
                            ),
                        );
                    account_infos
                        .extend(
                            anchor_lang::ToAccountInfos::to_account_infos(
                                &self.compressed_token_program,
                            ),
                        );
                    account_infos
                        .extend(
                            anchor_lang::ToAccountInfos::to_account_infos(
                                &self.compressed_token_0_pool_pda,
                            ),
                        );
                    account_infos
                        .extend(
                            anchor_lang::ToAccountInfos::to_account_infos(
                                &self.compressed_token_1_pool_pda,
                            ),
                        );
                    account_infos
                }
            }
        }
        impl<'info> Swap<'info> {
            pub fn __anchor_private_gen_idl_accounts(
                accounts: &mut std::collections::BTreeMap<
                    String,
                    anchor_lang::idl::types::IdlAccount,
                >,
                types: &mut std::collections::BTreeMap<
                    String,
                    anchor_lang::idl::types::IdlTypeDef,
                >,
            ) -> Vec<anchor_lang::idl::types::IdlInstructionAccountItem> {
                if let Some(ty) = <AmmConfig>::create_type() {
                    let account = anchor_lang::idl::types::IdlAccount {
                        name: ty.name.clone(),
                        discriminator: AmmConfig::DISCRIMINATOR.into(),
                    };
                    accounts.insert(account.name.clone(), account);
                    types.insert(ty.name.clone(), ty);
                    <AmmConfig>::insert_types(types);
                }
                if let Some(ty) = <PoolState>::create_type() {
                    let account = anchor_lang::idl::types::IdlAccount {
                        name: ty.name.clone(),
                        discriminator: PoolState::DISCRIMINATOR.into(),
                    };
                    accounts.insert(account.name.clone(), account);
                    types.insert(ty.name.clone(), ty);
                    <PoolState>::insert_types(types);
                }
                if let Some(ty) = <TokenAccount>::create_type() {
                    let account = anchor_lang::idl::types::IdlAccount {
                        name: ty.name.clone(),
                        discriminator: TokenAccount::DISCRIMINATOR.into(),
                    };
                    accounts.insert(account.name.clone(), account);
                    types.insert(ty.name.clone(), ty);
                    <TokenAccount>::insert_types(types);
                }
                if let Some(ty) = <TokenAccount>::create_type() {
                    let account = anchor_lang::idl::types::IdlAccount {
                        name: ty.name.clone(),
                        discriminator: TokenAccount::DISCRIMINATOR.into(),
                    };
                    accounts.insert(account.name.clone(), account);
                    types.insert(ty.name.clone(), ty);
                    <TokenAccount>::insert_types(types);
                }
                if let Some(ty) = <TokenAccount>::create_type() {
                    let account = anchor_lang::idl::types::IdlAccount {
                        name: ty.name.clone(),
                        discriminator: TokenAccount::DISCRIMINATOR.into(),
                    };
                    accounts.insert(account.name.clone(), account);
                    types.insert(ty.name.clone(), ty);
                    <TokenAccount>::insert_types(types);
                }
                if let Some(ty) = <TokenAccount>::create_type() {
                    let account = anchor_lang::idl::types::IdlAccount {
                        name: ty.name.clone(),
                        discriminator: TokenAccount::DISCRIMINATOR.into(),
                    };
                    accounts.insert(account.name.clone(), account);
                    types.insert(ty.name.clone(), ty);
                    <TokenAccount>::insert_types(types);
                }
                if let Some(ty) = <Mint>::create_type() {
                    let account = anchor_lang::idl::types::IdlAccount {
                        name: ty.name.clone(),
                        discriminator: Mint::DISCRIMINATOR.into(),
                    };
                    accounts.insert(account.name.clone(), account);
                    types.insert(ty.name.clone(), ty);
                    <Mint>::insert_types(types);
                }
                if let Some(ty) = <Mint>::create_type() {
                    let account = anchor_lang::idl::types::IdlAccount {
                        name: ty.name.clone(),
                        discriminator: Mint::DISCRIMINATOR.into(),
                    };
                    accounts.insert(account.name.clone(), account);
                    types.insert(ty.name.clone(), ty);
                    <Mint>::insert_types(types);
                }
                if let Some(ty) = <ObservationState>::create_type() {
                    let account = anchor_lang::idl::types::IdlAccount {
                        name: ty.name.clone(),
                        discriminator: ObservationState::DISCRIMINATOR.into(),
                    };
                    accounts.insert(account.name.clone(), account);
                    types.insert(ty.name.clone(), ty);
                    <ObservationState>::insert_types(types);
                }
                <[_]>::into_vec(
                    ::alloc::boxed::box_new([
                        anchor_lang::idl::types::IdlInstructionAccountItem::Single(anchor_lang::idl::types::IdlInstructionAccount {
                            name: "payer".into(),
                            docs: <[_]>::into_vec(
                                ::alloc::boxed::box_new([
                                    "The user performing the swap".into(),
                                ]),
                            ),
                            writable: false,
                            signer: true,
                            optional: false,
                            address: None,
                            pda: None,
                            relations: ::alloc::vec::Vec::new(),
                        }),
                        anchor_lang::idl::types::IdlInstructionAccountItem::Single(anchor_lang::idl::types::IdlInstructionAccount {
                            name: "authority".into(),
                            docs: ::alloc::vec::Vec::new(),
                            writable: false,
                            signer: false,
                            optional: false,
                            address: None,
                            pda: None,
                            relations: ::alloc::vec::Vec::new(),
                        }),
                        anchor_lang::idl::types::IdlInstructionAccountItem::Single(anchor_lang::idl::types::IdlInstructionAccount {
                            name: "amm_config".into(),
                            docs: <[_]>::into_vec(
                                ::alloc::boxed::box_new([
                                    "The factory state to read protocol fees".into(),
                                ]),
                            ),
                            writable: false,
                            signer: false,
                            optional: false,
                            address: None,
                            pda: None,
                            relations: ::alloc::vec::Vec::new(),
                        }),
                        anchor_lang::idl::types::IdlInstructionAccountItem::Single(anchor_lang::idl::types::IdlInstructionAccount {
                            name: "pool_state".into(),
                            docs: <[_]>::into_vec(
                                ::alloc::boxed::box_new([
                                    "The program account of the pool in which the swap will be performed"
                                        .into(),
                                ]),
                            ),
                            writable: true,
                            signer: false,
                            optional: false,
                            address: None,
                            pda: None,
                            relations: ::alloc::vec::Vec::new(),
                        }),
                        anchor_lang::idl::types::IdlInstructionAccountItem::Single(anchor_lang::idl::types::IdlInstructionAccount {
                            name: "input_token_account".into(),
                            docs: <[_]>::into_vec(
                                ::alloc::boxed::box_new([
                                    "The user token account for input token".into(),
                                ]),
                            ),
                            writable: true,
                            signer: false,
                            optional: false,
                            address: None,
                            pda: None,
                            relations: ::alloc::vec::Vec::new(),
                        }),
                        anchor_lang::idl::types::IdlInstructionAccountItem::Single(anchor_lang::idl::types::IdlInstructionAccount {
                            name: "output_token_account".into(),
                            docs: <[_]>::into_vec(
                                ::alloc::boxed::box_new([
                                    "The user token account for output token".into(),
                                ]),
                            ),
                            writable: true,
                            signer: false,
                            optional: false,
                            address: None,
                            pda: None,
                            relations: ::alloc::vec::Vec::new(),
                        }),
                        anchor_lang::idl::types::IdlInstructionAccountItem::Single(anchor_lang::idl::types::IdlInstructionAccount {
                            name: "input_vault".into(),
                            docs: {
                                let mut v = <[_]>::into_vec(
                                    ::alloc::boxed::box_new([
                                        "The vault token account for input token".into(),
                                    ]),
                                );
                                v.push("cctoken".into());
                                v
                            },
                            writable: true,
                            signer: false,
                            optional: false,
                            address: None,
                            pda: None,
                            relations: ::alloc::vec::Vec::new(),
                        }),
                        anchor_lang::idl::types::IdlInstructionAccountItem::Single(anchor_lang::idl::types::IdlInstructionAccount {
                            name: "output_vault".into(),
                            docs: {
                                let mut v = <[_]>::into_vec(
                                    ::alloc::boxed::box_new([
                                        "The vault token account for output token".into(),
                                    ]),
                                );
                                v.push("cctoken".into());
                                v
                            },
                            writable: true,
                            signer: false,
                            optional: false,
                            address: None,
                            pda: None,
                            relations: ::alloc::vec::Vec::new(),
                        }),
                        anchor_lang::idl::types::IdlInstructionAccountItem::Single(anchor_lang::idl::types::IdlInstructionAccount {
                            name: "input_token_program".into(),
                            docs: <[_]>::into_vec(
                                ::alloc::boxed::box_new([
                                    "SPL program for input token transfers".into(),
                                ]),
                            ),
                            writable: false,
                            signer: false,
                            optional: false,
                            address: None,
                            pda: None,
                            relations: ::alloc::vec::Vec::new(),
                        }),
                        anchor_lang::idl::types::IdlInstructionAccountItem::Single(anchor_lang::idl::types::IdlInstructionAccount {
                            name: "output_token_program".into(),
                            docs: <[_]>::into_vec(
                                ::alloc::boxed::box_new([
                                    "SPL program for output token transfers".into(),
                                ]),
                            ),
                            writable: false,
                            signer: false,
                            optional: false,
                            address: None,
                            pda: None,
                            relations: ::alloc::vec::Vec::new(),
                        }),
                        anchor_lang::idl::types::IdlInstructionAccountItem::Single(anchor_lang::idl::types::IdlInstructionAccount {
                            name: "input_token_mint".into(),
                            docs: <[_]>::into_vec(
                                ::alloc::boxed::box_new(["The mint of input token".into()]),
                            ),
                            writable: false,
                            signer: false,
                            optional: false,
                            address: None,
                            pda: None,
                            relations: ::alloc::vec::Vec::new(),
                        }),
                        anchor_lang::idl::types::IdlInstructionAccountItem::Single(anchor_lang::idl::types::IdlInstructionAccount {
                            name: "output_token_mint".into(),
                            docs: <[_]>::into_vec(
                                ::alloc::boxed::box_new(["The mint of output token".into()]),
                            ),
                            writable: false,
                            signer: false,
                            optional: false,
                            address: None,
                            pda: None,
                            relations: ::alloc::vec::Vec::new(),
                        }),
                        anchor_lang::idl::types::IdlInstructionAccountItem::Single(anchor_lang::idl::types::IdlInstructionAccount {
                            name: "observation_state".into(),
                            docs: <[_]>::into_vec(
                                ::alloc::boxed::box_new([
                                    "The program account for the most recent oracle observation"
                                        .into(),
                                ]),
                            ),
                            writable: true,
                            signer: false,
                            optional: false,
                            address: None,
                            pda: None,
                            relations: ::alloc::vec::Vec::new(),
                        }),
                        anchor_lang::idl::types::IdlInstructionAccountItem::Single(anchor_lang::idl::types::IdlInstructionAccount {
                            name: "compressed_token_program_cpi_authority".into(),
                            docs: ::alloc::vec::Vec::new(),
                            writable: false,
                            signer: false,
                            optional: false,
                            address: None,
                            pda: None,
                            relations: ::alloc::vec::Vec::new(),
                        }),
                        anchor_lang::idl::types::IdlInstructionAccountItem::Single(anchor_lang::idl::types::IdlInstructionAccount {
                            name: "compressed_token_program".into(),
                            docs: ::alloc::vec::Vec::new(),
                            writable: false,
                            signer: false,
                            optional: false,
                            address: None,
                            pda: None,
                            relations: ::alloc::vec::Vec::new(),
                        }),
                        anchor_lang::idl::types::IdlInstructionAccountItem::Single(anchor_lang::idl::types::IdlInstructionAccount {
                            name: "compressed_token_0_pool_pda".into(),
                            docs: <[_]>::into_vec(
                                ::alloc::boxed::box_new([
                                    "".into(),
                                    "Every mint must be registered in the compression protocol via a"
                                        .into(),
                                    "compression_token_pool_pda.".into(),
                                ]),
                            ),
                            writable: true,
                            signer: false,
                            optional: false,
                            address: None,
                            pda: None,
                            relations: ::alloc::vec::Vec::new(),
                        }),
                        anchor_lang::idl::types::IdlInstructionAccountItem::Single(anchor_lang::idl::types::IdlInstructionAccount {
                            name: "compressed_token_1_pool_pda".into(),
                            docs: ::alloc::vec::Vec::new(),
                            writable: true,
                            signer: false,
                            optional: false,
                            address: None,
                            pda: None,
                            relations: ::alloc::vec::Vec::new(),
                        }),
                    ]),
                )
            }
            pub fn __anchor_private_gen_light_metadata() -> Option<
                anchor_lang::idl::types::IdlLightInstructionMeta,
            > {
                Some(anchor_lang::idl::types::IdlLightInstructionMeta {
                    ctokens: Some(
                        <[_]>::into_vec(
                            ::alloc::boxed::box_new([
                                anchor_lang::idl::types::IdlLightCtokenUsage {
                                    account: "input_vault".to_string(),
                                    possible_variants: <[_]>::into_vec(
                                        ::alloc::boxed::box_new(["InputVault".to_string()]),
                                    ),
                                    seeds: ::alloc::vec::Vec::new(),
                                    authority: None,
                                    mint: None,
                                    seed_aliases: None,
                                },
                                anchor_lang::idl::types::IdlLightCtokenUsage {
                                    account: "output_vault".to_string(),
                                    possible_variants: <[_]>::into_vec(
                                        ::alloc::boxed::box_new(["OutputVault".to_string()]),
                                    ),
                                    seeds: ::alloc::vec::Vec::new(),
                                    authority: None,
                                    mint: None,
                                    seed_aliases: None,
                                },
                            ]),
                        ),
                    ),
                    cpdas: Some(
                        <[_]>::into_vec(
                            ::alloc::boxed::box_new([
                                anchor_lang::idl::types::IdlLightCpdaUsage {
                                    account: "pool_state".to_string(),
                                    ty: "PoolState".to_string(),
                                },
                                anchor_lang::idl::types::IdlLightCpdaUsage {
                                    account: "observation_state".to_string(),
                                    ty: "ObservationState".to_string(),
                                },
                            ]),
                        ),
                    ),
                })
            }
        }
        pub fn swap_base_input(
            ctx: Context<Swap>,
            amount_in: u64,
            minimum_amount_out: u64,
        ) -> Result<()> {
            let block_timestamp = solana_program::clock::Clock::get()?.unix_timestamp
                as u64;
            let pool_id = ctx.accounts.pool_state.key();
            let pool_state = &mut ctx.accounts.pool_state;
            if !pool_state.get_status_by_bit(PoolStatusBitIndex::Swap)
                || block_timestamp < pool_state.open_time
            {
                return Err(
                    anchor_lang::error::Error::from(anchor_lang::error::AnchorError {
                        error_name: ErrorCode::NotApproved.name(),
                        error_code_number: ErrorCode::NotApproved.into(),
                        error_msg: ErrorCode::NotApproved.to_string(),
                        error_origin: Some(
                            anchor_lang::error::ErrorOrigin::Source(anchor_lang::error::Source {
                                filename: "programs/cp-swap/src/instructions/swap_base_input.rs",
                                line: 115u32,
                            }),
                        ),
                        compared_values: None,
                    }),
                );
            }
            let transfer_fee = get_transfer_fee(
                &ctx.accounts.input_token_mint.to_account_info(),
                amount_in,
            )?;
            let actual_amount_in = amount_in.saturating_sub(transfer_fee);
            if actual_amount_in <= 0 {
                return Err(
                    anchor_lang::error::Error::from(anchor_lang::error::AnchorError {
                            error_name: anchor_lang::error::ErrorCode::RequireGtViolated
                                .name(),
                            error_code_number: anchor_lang::error::ErrorCode::RequireGtViolated
                                .into(),
                            error_msg: anchor_lang::error::ErrorCode::RequireGtViolated
                                .to_string(),
                            error_origin: Some(
                                anchor_lang::error::ErrorOrigin::Source(anchor_lang::error::Source {
                                    filename: "programs/cp-swap/src/instructions/swap_base_input.rs",
                                    line: 122u32,
                                }),
                            ),
                            compared_values: None,
                        })
                        .with_values((actual_amount_in, 0)),
                );
            }
            let (
                trade_direction,
                total_input_token_amount,
                total_output_token_amount,
                token_0_price_x64,
                token_1_price_x64,
            ) = if ctx.accounts.input_vault.key() == pool_state.token_0_vault
                && ctx.accounts.output_vault.key() == pool_state.token_1_vault
            {
                let (total_input_token_amount, total_output_token_amount) = pool_state
                    .vault_amount_without_fee(
                        ctx.accounts.input_vault.amount,
                        ctx.accounts.output_vault.amount,
                    );
                let (token_0_price_x64, token_1_price_x64) = pool_state
                    .token_price_x32(
                        ctx.accounts.input_vault.amount,
                        ctx.accounts.output_vault.amount,
                    );
                (
                    TradeDirection::ZeroForOne,
                    total_input_token_amount,
                    total_output_token_amount,
                    token_0_price_x64,
                    token_1_price_x64,
                )
            } else if ctx.accounts.input_vault.key() == pool_state.token_1_vault
                && ctx.accounts.output_vault.key() == pool_state.token_0_vault
            {
                let (total_output_token_amount, total_input_token_amount) = pool_state
                    .vault_amount_without_fee(
                        ctx.accounts.output_vault.amount,
                        ctx.accounts.input_vault.amount,
                    );
                let (token_0_price_x64, token_1_price_x64) = pool_state
                    .token_price_x32(
                        ctx.accounts.output_vault.amount,
                        ctx.accounts.input_vault.amount,
                    );
                (
                    TradeDirection::OneForZero,
                    total_input_token_amount,
                    total_output_token_amount,
                    token_0_price_x64,
                    token_1_price_x64,
                )
            } else {
                return Err(
                    anchor_lang::error::Error::from(anchor_lang::error::AnchorError {
                        error_name: ErrorCode::InvalidVault.name(),
                        error_code_number: ErrorCode::InvalidVault.into(),
                        error_msg: ErrorCode::InvalidVault.to_string(),
                        error_origin: Some(
                            anchor_lang::error::ErrorOrigin::Source(anchor_lang::error::Source {
                                filename: "programs/cp-swap/src/instructions/swap_base_input.rs",
                                line: 172u32,
                            }),
                        ),
                        compared_values: None,
                    }),
                );
            };
            let constant_before = u128::from(total_input_token_amount)
                .checked_mul(u128::from(total_output_token_amount))
                .unwrap();
            let result = CurveCalculator::swap_base_input(
                    u128::from(actual_amount_in),
                    u128::from(total_input_token_amount),
                    u128::from(total_output_token_amount),
                    ctx.accounts.amm_config.trade_fee_rate,
                    ctx.accounts.amm_config.protocol_fee_rate,
                    ctx.accounts.amm_config.fund_fee_rate,
                )
                .ok_or(ErrorCode::ZeroTradingTokens)?;
            let constant_after = u128::from(
                    result.new_swap_source_amount.checked_sub(result.trade_fee).unwrap(),
                )
                .checked_mul(u128::from(result.new_swap_destination_amount))
                .unwrap();
            if u64::try_from(result.source_amount_swapped).unwrap() != actual_amount_in {
                return Err(
                    anchor_lang::error::Error::from(anchor_lang::error::AnchorError {
                            error_name: anchor_lang::error::ErrorCode::RequireEqViolated
                                .name(),
                            error_code_number: anchor_lang::error::ErrorCode::RequireEqViolated
                                .into(),
                            error_msg: anchor_lang::error::ErrorCode::RequireEqViolated
                                .to_string(),
                            error_origin: Some(
                                anchor_lang::error::ErrorOrigin::Source(anchor_lang::error::Source {
                                    filename: "programs/cp-swap/src/instructions/swap_base_input.rs",
                                    line: 205u32,
                                }),
                            ),
                            compared_values: None,
                        })
                        .with_values((
                            u64::try_from(result.source_amount_swapped).unwrap(),
                            actual_amount_in,
                        )),
                );
            }
            let (input_transfer_amount, input_transfer_fee) = (amount_in, transfer_fee);
            let (output_transfer_amount, output_transfer_fee) = {
                let amount_out = u64::try_from(result.destination_amount_swapped)
                    .unwrap();
                let transfer_fee = get_transfer_fee(
                    &ctx.accounts.output_token_mint.to_account_info(),
                    amount_out,
                )?;
                let amount_received = amount_out.checked_sub(transfer_fee).unwrap();
                if amount_received <= 0 {
                    return Err(
                        anchor_lang::error::Error::from(anchor_lang::error::AnchorError {
                                error_name: anchor_lang::error::ErrorCode::RequireGtViolated
                                    .name(),
                                error_code_number: anchor_lang::error::ErrorCode::RequireGtViolated
                                    .into(),
                                error_msg: anchor_lang::error::ErrorCode::RequireGtViolated
                                    .to_string(),
                                error_origin: Some(
                                    anchor_lang::error::ErrorOrigin::Source(anchor_lang::error::Source {
                                        filename: "programs/cp-swap/src/instructions/swap_base_input.rs",
                                        line: 217u32,
                                    }),
                                ),
                                compared_values: None,
                            })
                            .with_values((amount_received, 0)),
                    );
                }
                if amount_received < minimum_amount_out {
                    return Err(
                        anchor_lang::error::Error::from(anchor_lang::error::AnchorError {
                                error_name: ErrorCode::ExceededSlippage.name(),
                                error_code_number: ErrorCode::ExceededSlippage.into(),
                                error_msg: ErrorCode::ExceededSlippage.to_string(),
                                error_origin: Some(
                                    anchor_lang::error::ErrorOrigin::Source(anchor_lang::error::Source {
                                        filename: "programs/cp-swap/src/instructions/swap_base_input.rs",
                                        line: 218u32,
                                    }),
                                ),
                                compared_values: None,
                            })
                            .with_values((amount_received, minimum_amount_out)),
                    );
                }
                (amount_out, transfer_fee)
            };
            let protocol_fee = u64::try_from(result.protocol_fee).unwrap();
            let fund_fee = u64::try_from(result.fund_fee).unwrap();
            match trade_direction {
                TradeDirection::ZeroForOne => {
                    pool_state.protocol_fees_token_0 = pool_state
                        .protocol_fees_token_0
                        .checked_add(protocol_fee)
                        .unwrap();
                    pool_state.fund_fees_token_0 = pool_state
                        .fund_fees_token_0
                        .checked_add(fund_fee)
                        .unwrap();
                }
                TradeDirection::OneForZero => {
                    pool_state.protocol_fees_token_1 = pool_state
                        .protocol_fees_token_1
                        .checked_add(protocol_fee)
                        .unwrap();
                    pool_state.fund_fees_token_1 = pool_state
                        .fund_fees_token_1
                        .checked_add(fund_fee)
                        .unwrap();
                }
            };
            {
                anchor_lang::solana_program::log::sol_log_data(
                    &[
                        &anchor_lang::Event::data(
                            &SwapEvent {
                                pool_id,
                                input_vault_before: total_input_token_amount,
                                output_vault_before: total_output_token_amount,
                                input_amount: u64::try_from(result.source_amount_swapped)
                                    .unwrap(),
                                output_amount: u64::try_from(
                                        result.destination_amount_swapped,
                                    )
                                    .unwrap(),
                                input_transfer_fee,
                                output_transfer_fee,
                                base_input: true,
                            },
                        ),
                    ],
                );
            };
            if constant_after < constant_before {
                return Err(
                    anchor_lang::error::Error::from(anchor_lang::error::AnchorError {
                            error_name: anchor_lang::error::ErrorCode::RequireGteViolated
                                .name(),
                            error_code_number: anchor_lang::error::ErrorCode::RequireGteViolated
                                .into(),
                            error_msg: anchor_lang::error::ErrorCode::RequireGteViolated
                                .to_string(),
                            error_origin: Some(
                                anchor_lang::error::ErrorOrigin::Source(anchor_lang::error::Source {
                                    filename: "programs/cp-swap/src/instructions/swap_base_input.rs",
                                    line: 258u32,
                                }),
                            ),
                            compared_values: None,
                        })
                        .with_values((constant_after, constant_before)),
                );
            }
            let (compressed_token_0_pool_bump, compressed_token_1_pool_bump) = get_bumps(
                ctx.accounts.input_token_mint.key(),
                ctx.accounts.output_token_mint.key(),
                ctx.accounts.compressed_token_program.key(),
            );
            transfer_from_user_to_pool_vault(
                ctx.accounts.payer.to_account_info(),
                ctx.accounts.input_token_account.to_account_info(),
                ctx.accounts.input_vault.to_account_info(),
                Some(ctx.accounts.input_token_mint.to_account_info()),
                Some(ctx.accounts.input_token_program.to_account_info()),
                Some(ctx.accounts.compressed_token_0_pool_pda.to_account_info()),
                Some(compressed_token_0_pool_bump),
                ctx.accounts.compressed_token_program_cpi_authority.to_account_info(),
                input_transfer_amount,
            )?;
            transfer_from_pool_vault_to_user(
                ctx.accounts.payer.to_account_info(),
                ctx.accounts.authority.to_account_info(),
                ctx.accounts.output_vault.to_account_info(),
                ctx.accounts.output_token_account.to_account_info(),
                Some(ctx.accounts.output_token_mint.to_account_info()),
                Some(ctx.accounts.output_token_program.to_account_info()),
                Some(ctx.accounts.compressed_token_1_pool_pda.to_account_info()),
                Some(compressed_token_1_pool_bump),
                ctx.accounts.compressed_token_program_cpi_authority.to_account_info(),
                output_transfer_amount,
                &[&[crate::AUTH_SEED.as_bytes(), &[pool_state.auth_bump]]],
            )?;
            ctx.accounts
                .observation_state
                .update(oracle::block_timestamp(), token_0_price_x64, token_1_price_x64);
            pool_state.recent_epoch = Clock::get()?.epoch;
            pool_state.compression_info_mut().bump_last_written_slot()?;
            Ok(())
        }
    }
    pub mod withdraw {
        use crate::curve::CurveCalculator;
        use crate::curve::RoundDirection;
        use crate::error::ErrorCode;
        use crate::utils::ctoken::get_bumps;
        use crate::states::*;
        use crate::utils::token::*;
        use crate::utils::transfer_ctoken_from_user_to_pool_vault;
        use anchor_lang::prelude::*;
        use anchor_spl::{
            memo::spl_memo, token::Token,
            token_interface::{Mint, Token2022, TokenAccount},
        };
        use light_sdk::compressible::HasCompressionInfo;
        pub struct Withdraw<'info> {
            /// Pays to mint the position
            pub owner: Signer<'info>,
            /// CHECK: pool vault and lp mint authority
            #[account(seeds = [crate::AUTH_SEED.as_bytes()], bump)]
            pub authority: UncheckedAccount<'info>,
            /// Pool state account
            #[account(mut)]
            pub pool_state: Box<Account<'info, PoolState>>,
            #[account(mut, token::authority = owner)]
            pub owner_lp_token: Box<InterfaceAccount<'info, TokenAccount>>,
            /// The token account for receive token_0,
            #[account(mut, token::mint = token_0_vault.mint)]
            pub token_0_account: Box<InterfaceAccount<'info, TokenAccount>>,
            /// The token account for receive token_1
            #[account(mut, token::mint = token_1_vault.mint)]
            pub token_1_account: Box<InterfaceAccount<'info, TokenAccount>>,
            /// The address that holds pool tokens for token_0
            #[account(mut, constraint = token_0_vault.key()= = pool_state.token_0_vault)]
            pub token_0_vault: Box<InterfaceAccount<'info, TokenAccount>>,
            /// The address that holds pool tokens for token_1
            #[account(mut, constraint = token_1_vault.key()= = pool_state.token_1_vault)]
            pub token_1_vault: Box<InterfaceAccount<'info, TokenAccount>>,
            /// token Program
            pub token_program: Program<'info, Token>,
            /// Token program 2022
            pub token_program_2022: Program<'info, Token2022>,
            /// The mint of token_0 vault
            #[account(
                address = token_0_vault.mint,
                mint::token_program = pool_state.token_0_program,
            )]
            pub vault_0_mint: Box<InterfaceAccount<'info, Mint>>,
            /// The mint of token_1 vault
            #[account(
                address = token_1_vault.mint,
                mint::token_program = pool_state.token_1_program,
            )]
            pub vault_1_mint: Box<InterfaceAccount<'info, Mint>>,
            /// Program lp token vault
            #[account(
                mut,
                seeds = [POOL_VAULT_SEED.as_bytes(),
                pool_state.lp_mint.as_ref()],
                bump,
                token::mint = lp_vault.mint,
                token::authority = authority
            )]
            pub lp_vault: InterfaceAccount<'info, TokenAccount>,
            /// CHECK: checked by protocol.
            pub compressed_token_program_cpi_authority: AccountInfo<'info>,
            /// CHECK: checked by protocol.
            pub compressed_token_program: AccountInfo<'info>,
            /// CHECK: checked by protocol.
            ///
            /// Every mint must be registered in the compression protocol via a
            /// compression_token_pool_pda.
            #[account(mut)]
            pub compressed_token_0_pool_pda: AccountInfo<'info>,
            /// CHECK: checked by protocol.
            #[account(mut)]
            pub compressed_token_1_pool_pda: AccountInfo<'info>,
            /// memo program
            /// CHECK:
            #[account(address = spl_memo::id())]
            pub memo_program: UncheckedAccount<'info>,
        }
        #[automatically_derived]
        impl<'info> anchor_lang::Accounts<'info, WithdrawBumps> for Withdraw<'info>
        where
            'info: 'info,
        {
            #[inline(never)]
            fn try_accounts(
                __program_id: &anchor_lang::solana_program::pubkey::Pubkey,
                __accounts: &mut &'info [anchor_lang::solana_program::account_info::AccountInfo<
                    'info,
                >],
                __ix_data: &[u8],
                __bumps: &mut WithdrawBumps,
                __reallocs: &mut std::collections::BTreeSet<
                    anchor_lang::solana_program::pubkey::Pubkey,
                >,
            ) -> anchor_lang::Result<Self> {
                let owner: Signer = anchor_lang::Accounts::try_accounts(
                        __program_id,
                        __accounts,
                        __ix_data,
                        __bumps,
                        __reallocs,
                    )
                    .map_err(|e| e.with_account_name("owner"))?;
                let authority: UncheckedAccount = anchor_lang::Accounts::try_accounts(
                        __program_id,
                        __accounts,
                        __ix_data,
                        __bumps,
                        __reallocs,
                    )
                    .map_err(|e| e.with_account_name("authority"))?;
                let pool_state: Box<
                    anchor_lang::accounts::account::Account<PoolState>,
                > = anchor_lang::Accounts::try_accounts(
                        __program_id,
                        __accounts,
                        __ix_data,
                        __bumps,
                        __reallocs,
                    )
                    .map_err(|e| e.with_account_name("pool_state"))?;
                let owner_lp_token: Box<
                    anchor_lang::accounts::interface_account::InterfaceAccount<
                        TokenAccount,
                    >,
                > = anchor_lang::Accounts::try_accounts(
                        __program_id,
                        __accounts,
                        __ix_data,
                        __bumps,
                        __reallocs,
                    )
                    .map_err(|e| e.with_account_name("owner_lp_token"))?;
                let token_0_account: Box<
                    anchor_lang::accounts::interface_account::InterfaceAccount<
                        TokenAccount,
                    >,
                > = anchor_lang::Accounts::try_accounts(
                        __program_id,
                        __accounts,
                        __ix_data,
                        __bumps,
                        __reallocs,
                    )
                    .map_err(|e| e.with_account_name("token_0_account"))?;
                let token_1_account: Box<
                    anchor_lang::accounts::interface_account::InterfaceAccount<
                        TokenAccount,
                    >,
                > = anchor_lang::Accounts::try_accounts(
                        __program_id,
                        __accounts,
                        __ix_data,
                        __bumps,
                        __reallocs,
                    )
                    .map_err(|e| e.with_account_name("token_1_account"))?;
                let token_0_vault: Box<
                    anchor_lang::accounts::interface_account::InterfaceAccount<
                        TokenAccount,
                    >,
                > = anchor_lang::Accounts::try_accounts(
                        __program_id,
                        __accounts,
                        __ix_data,
                        __bumps,
                        __reallocs,
                    )
                    .map_err(|e| e.with_account_name("token_0_vault"))?;
                let token_1_vault: Box<
                    anchor_lang::accounts::interface_account::InterfaceAccount<
                        TokenAccount,
                    >,
                > = anchor_lang::Accounts::try_accounts(
                        __program_id,
                        __accounts,
                        __ix_data,
                        __bumps,
                        __reallocs,
                    )
                    .map_err(|e| e.with_account_name("token_1_vault"))?;
                let token_program: anchor_lang::accounts::program::Program<Token> = anchor_lang::Accounts::try_accounts(
                        __program_id,
                        __accounts,
                        __ix_data,
                        __bumps,
                        __reallocs,
                    )
                    .map_err(|e| e.with_account_name("token_program"))?;
                let token_program_2022: anchor_lang::accounts::program::Program<
                    Token2022,
                > = anchor_lang::Accounts::try_accounts(
                        __program_id,
                        __accounts,
                        __ix_data,
                        __bumps,
                        __reallocs,
                    )
                    .map_err(|e| e.with_account_name("token_program_2022"))?;
                let vault_0_mint: Box<
                    anchor_lang::accounts::interface_account::InterfaceAccount<Mint>,
                > = Box::new({
                    if __accounts.is_empty() {
                        return Err(
                            anchor_lang::error::ErrorCode::AccountNotEnoughKeys.into(),
                        );
                    }
                    let __acc = &__accounts[0];
                    *__accounts = &__accounts[1..];
                    anchor_lang::accounts::interface_account::InterfaceAccount::try_from_with_token_program(
                            __acc,
                            &pool_state.token_0_program,
                        )
                        .map_err(|e| e.with_account_name("vault_0_mint"))?
                });
                let vault_1_mint: Box<
                    anchor_lang::accounts::interface_account::InterfaceAccount<Mint>,
                > = Box::new({
                    if __accounts.is_empty() {
                        return Err(
                            anchor_lang::error::ErrorCode::AccountNotEnoughKeys.into(),
                        );
                    }
                    let __acc = &__accounts[0];
                    *__accounts = &__accounts[1..];
                    anchor_lang::accounts::interface_account::InterfaceAccount::try_from_with_token_program(
                            __acc,
                            &pool_state.token_1_program,
                        )
                        .map_err(|e| e.with_account_name("vault_1_mint"))?
                });
                let lp_vault: anchor_lang::accounts::interface_account::InterfaceAccount<
                    TokenAccount,
                > = anchor_lang::Accounts::try_accounts(
                        __program_id,
                        __accounts,
                        __ix_data,
                        __bumps,
                        __reallocs,
                    )
                    .map_err(|e| e.with_account_name("lp_vault"))?;
                let compressed_token_program_cpi_authority: AccountInfo = anchor_lang::Accounts::try_accounts(
                        __program_id,
                        __accounts,
                        __ix_data,
                        __bumps,
                        __reallocs,
                    )
                    .map_err(|e| {
                        e.with_account_name("compressed_token_program_cpi_authority")
                    })?;
                let compressed_token_program: AccountInfo = anchor_lang::Accounts::try_accounts(
                        __program_id,
                        __accounts,
                        __ix_data,
                        __bumps,
                        __reallocs,
                    )
                    .map_err(|e| e.with_account_name("compressed_token_program"))?;
                let compressed_token_0_pool_pda: AccountInfo = anchor_lang::Accounts::try_accounts(
                        __program_id,
                        __accounts,
                        __ix_data,
                        __bumps,
                        __reallocs,
                    )
                    .map_err(|e| e.with_account_name("compressed_token_0_pool_pda"))?;
                let compressed_token_1_pool_pda: AccountInfo = anchor_lang::Accounts::try_accounts(
                        __program_id,
                        __accounts,
                        __ix_data,
                        __bumps,
                        __reallocs,
                    )
                    .map_err(|e| e.with_account_name("compressed_token_1_pool_pda"))?;
                let memo_program: UncheckedAccount = anchor_lang::Accounts::try_accounts(
                        __program_id,
                        __accounts,
                        __ix_data,
                        __bumps,
                        __reallocs,
                    )
                    .map_err(|e| e.with_account_name("memo_program"))?;
                let (__pda_address, __bump) = Pubkey::find_program_address(
                    &[crate::AUTH_SEED.as_bytes()],
                    &__program_id,
                );
                __bumps.authority = __bump;
                if authority.key() != __pda_address {
                    return Err(
                        anchor_lang::error::Error::from(
                                anchor_lang::error::ErrorCode::ConstraintSeeds,
                            )
                            .with_account_name("authority")
                            .with_pubkeys((authority.key(), __pda_address)),
                    );
                }
                if !AsRef::<AccountInfo>::as_ref(pool_state.as_ref()).is_writable {
                    return Err(
                        anchor_lang::error::Error::from(
                                anchor_lang::error::ErrorCode::ConstraintMut,
                            )
                            .with_account_name("pool_state"),
                    );
                }
                if !AsRef::<AccountInfo>::as_ref(owner_lp_token.as_ref()).is_writable {
                    return Err(
                        anchor_lang::error::Error::from(
                                anchor_lang::error::ErrorCode::ConstraintMut,
                            )
                            .with_account_name("owner_lp_token"),
                    );
                }
                {
                    if owner_lp_token.owner != owner.key() {
                        return Err(
                            anchor_lang::error::ErrorCode::ConstraintTokenOwner.into(),
                        );
                    }
                }
                if !AsRef::<AccountInfo>::as_ref(token_0_account.as_ref()).is_writable {
                    return Err(
                        anchor_lang::error::Error::from(
                                anchor_lang::error::ErrorCode::ConstraintMut,
                            )
                            .with_account_name("token_0_account"),
                    );
                }
                {
                    if token_0_account.mint != token_0_vault.mint.key() {
                        return Err(
                            anchor_lang::error::ErrorCode::ConstraintTokenMint.into(),
                        );
                    }
                }
                if !AsRef::<AccountInfo>::as_ref(token_1_account.as_ref()).is_writable {
                    return Err(
                        anchor_lang::error::Error::from(
                                anchor_lang::error::ErrorCode::ConstraintMut,
                            )
                            .with_account_name("token_1_account"),
                    );
                }
                {
                    if token_1_account.mint != token_1_vault.mint.key() {
                        return Err(
                            anchor_lang::error::ErrorCode::ConstraintTokenMint.into(),
                        );
                    }
                }
                if !AsRef::<AccountInfo>::as_ref(token_0_vault.as_ref()).is_writable {
                    return Err(
                        anchor_lang::error::Error::from(
                                anchor_lang::error::ErrorCode::ConstraintMut,
                            )
                            .with_account_name("token_0_vault"),
                    );
                }
                if !(token_0_vault.key() == pool_state.token_0_vault) {
                    return Err(
                        anchor_lang::error::Error::from(
                                anchor_lang::error::ErrorCode::ConstraintRaw,
                            )
                            .with_account_name("token_0_vault"),
                    );
                }
                if !AsRef::<AccountInfo>::as_ref(token_1_vault.as_ref()).is_writable {
                    return Err(
                        anchor_lang::error::Error::from(
                                anchor_lang::error::ErrorCode::ConstraintMut,
                            )
                            .with_account_name("token_1_vault"),
                    );
                }
                if !(token_1_vault.key() == pool_state.token_1_vault) {
                    return Err(
                        anchor_lang::error::Error::from(
                                anchor_lang::error::ErrorCode::ConstraintRaw,
                            )
                            .with_account_name("token_1_vault"),
                    );
                }
                {
                    let actual = vault_0_mint.key();
                    let expected = token_0_vault.mint;
                    if actual != expected {
                        return Err(
                            anchor_lang::error::Error::from(
                                    anchor_lang::error::ErrorCode::ConstraintAddress,
                                )
                                .with_account_name("vault_0_mint")
                                .with_pubkeys((actual, expected)),
                        );
                    }
                }
                {
                    let __is_ctoken = pool_state.token_0_program
                        == anchor_lang::CTOKEN_ID;
                    if __is_ctoken {
                        if AsRef::<AccountInfo>::as_ref(vault_0_mint.as_ref()).owner
                            != &anchor_lang::solana_program::system_program::ID
                        {
                            return Err(
                                anchor_lang::error::ErrorCode::ConstraintMintTokenProgram
                                    .into(),
                            );
                        }
                    } else {
                        if AsRef::<AccountInfo>::as_ref(vault_0_mint.as_ref()).owner
                            != &pool_state.token_0_program
                        {
                            return Err(
                                anchor_lang::error::ErrorCode::ConstraintMintTokenProgram
                                    .into(),
                            );
                        }
                    }
                    if !__is_ctoken {}
                }
                {
                    let actual = vault_1_mint.key();
                    let expected = token_1_vault.mint;
                    if actual != expected {
                        return Err(
                            anchor_lang::error::Error::from(
                                    anchor_lang::error::ErrorCode::ConstraintAddress,
                                )
                                .with_account_name("vault_1_mint")
                                .with_pubkeys((actual, expected)),
                        );
                    }
                }
                {
                    let __is_ctoken = pool_state.token_1_program
                        == anchor_lang::CTOKEN_ID;
                    if __is_ctoken {
                        if AsRef::<AccountInfo>::as_ref(vault_1_mint.as_ref()).owner
                            != &anchor_lang::solana_program::system_program::ID
                        {
                            return Err(
                                anchor_lang::error::ErrorCode::ConstraintMintTokenProgram
                                    .into(),
                            );
                        }
                    } else {
                        if AsRef::<AccountInfo>::as_ref(vault_1_mint.as_ref()).owner
                            != &pool_state.token_1_program
                        {
                            return Err(
                                anchor_lang::error::ErrorCode::ConstraintMintTokenProgram
                                    .into(),
                            );
                        }
                    }
                    if !__is_ctoken {}
                }
                let (__pda_address, __bump) = Pubkey::find_program_address(
                    &[POOL_VAULT_SEED.as_bytes(), pool_state.lp_mint.as_ref()],
                    &__program_id,
                );
                __bumps.lp_vault = __bump;
                if lp_vault.key() != __pda_address {
                    return Err(
                        anchor_lang::error::Error::from(
                                anchor_lang::error::ErrorCode::ConstraintSeeds,
                            )
                            .with_account_name("lp_vault")
                            .with_pubkeys((lp_vault.key(), __pda_address)),
                    );
                }
                if !AsRef::<AccountInfo>::as_ref(&lp_vault).is_writable {
                    return Err(
                        anchor_lang::error::Error::from(
                                anchor_lang::error::ErrorCode::ConstraintMut,
                            )
                            .with_account_name("lp_vault"),
                    );
                }
                {
                    if lp_vault.owner != authority.key() {
                        return Err(
                            anchor_lang::error::ErrorCode::ConstraintTokenOwner.into(),
                        );
                    }
                    if lp_vault.mint != lp_vault.mint.key() {
                        return Err(
                            anchor_lang::error::ErrorCode::ConstraintTokenMint.into(),
                        );
                    }
                }
                if !&compressed_token_0_pool_pda.is_writable {
                    return Err(
                        anchor_lang::error::Error::from(
                                anchor_lang::error::ErrorCode::ConstraintMut,
                            )
                            .with_account_name("compressed_token_0_pool_pda"),
                    );
                }
                if !&compressed_token_1_pool_pda.is_writable {
                    return Err(
                        anchor_lang::error::Error::from(
                                anchor_lang::error::ErrorCode::ConstraintMut,
                            )
                            .with_account_name("compressed_token_1_pool_pda"),
                    );
                }
                {
                    let actual = memo_program.key();
                    let expected = spl_memo::id();
                    if actual != expected {
                        return Err(
                            anchor_lang::error::Error::from(
                                    anchor_lang::error::ErrorCode::ConstraintAddress,
                                )
                                .with_account_name("memo_program")
                                .with_pubkeys((actual, expected)),
                        );
                    }
                }
                Ok(Withdraw {
                    owner,
                    authority,
                    pool_state,
                    owner_lp_token,
                    token_0_account,
                    token_1_account,
                    token_0_vault,
                    token_1_vault,
                    token_program,
                    token_program_2022,
                    vault_0_mint,
                    vault_1_mint,
                    lp_vault,
                    compressed_token_program_cpi_authority,
                    compressed_token_program,
                    compressed_token_0_pool_pda,
                    compressed_token_1_pool_pda,
                    memo_program,
                })
            }
        }
        #[automatically_derived]
        impl<'info> anchor_lang::ToAccountInfos<'info> for Withdraw<'info>
        where
            'info: 'info,
        {
            fn to_account_infos(
                &self,
            ) -> Vec<anchor_lang::solana_program::account_info::AccountInfo<'info>> {
                let mut account_infos = ::alloc::vec::Vec::new();
                account_infos.extend(self.owner.to_account_infos());
                account_infos.extend(self.authority.to_account_infos());
                account_infos.extend(self.pool_state.to_account_infos());
                account_infos.extend(self.owner_lp_token.to_account_infos());
                account_infos.extend(self.token_0_account.to_account_infos());
                account_infos.extend(self.token_1_account.to_account_infos());
                account_infos.extend(self.token_0_vault.to_account_infos());
                account_infos.extend(self.token_1_vault.to_account_infos());
                account_infos.extend(self.token_program.to_account_infos());
                account_infos.extend(self.token_program_2022.to_account_infos());
                account_infos.extend(self.vault_0_mint.to_account_infos());
                account_infos.extend(self.vault_1_mint.to_account_infos());
                account_infos.extend(self.lp_vault.to_account_infos());
                account_infos
                    .extend(
                        self.compressed_token_program_cpi_authority.to_account_infos(),
                    );
                account_infos.extend(self.compressed_token_program.to_account_infos());
                account_infos
                    .extend(self.compressed_token_0_pool_pda.to_account_infos());
                account_infos
                    .extend(self.compressed_token_1_pool_pda.to_account_infos());
                account_infos.extend(self.memo_program.to_account_infos());
                account_infos
            }
        }
        #[automatically_derived]
        impl<'info> anchor_lang::ToAccountMetas for Withdraw<'info> {
            fn to_account_metas(
                &self,
                is_signer: Option<bool>,
            ) -> Vec<anchor_lang::solana_program::instruction::AccountMeta> {
                let mut account_metas = ::alloc::vec::Vec::new();
                account_metas.extend(self.owner.to_account_metas(None));
                account_metas.extend(self.authority.to_account_metas(None));
                account_metas.extend(self.pool_state.to_account_metas(None));
                account_metas.extend(self.owner_lp_token.to_account_metas(None));
                account_metas.extend(self.token_0_account.to_account_metas(None));
                account_metas.extend(self.token_1_account.to_account_metas(None));
                account_metas.extend(self.token_0_vault.to_account_metas(None));
                account_metas.extend(self.token_1_vault.to_account_metas(None));
                account_metas.extend(self.token_program.to_account_metas(None));
                account_metas.extend(self.token_program_2022.to_account_metas(None));
                account_metas.extend(self.vault_0_mint.to_account_metas(None));
                account_metas.extend(self.vault_1_mint.to_account_metas(None));
                account_metas.extend(self.lp_vault.to_account_metas(None));
                account_metas
                    .extend(
                        self
                            .compressed_token_program_cpi_authority
                            .to_account_metas(None),
                    );
                account_metas
                    .extend(self.compressed_token_program.to_account_metas(None));
                account_metas
                    .extend(self.compressed_token_0_pool_pda.to_account_metas(None));
                account_metas
                    .extend(self.compressed_token_1_pool_pda.to_account_metas(None));
                account_metas.extend(self.memo_program.to_account_metas(None));
                account_metas
            }
        }
        #[automatically_derived]
        impl<'info> anchor_lang::AccountsFinalize<'info, WithdrawBumps>
        for Withdraw<'info>
        where
            'info: 'info,
        {
            fn finalize(
                &mut self,
                program_id: &anchor_lang::solana_program::pubkey::Pubkey,
                _remaining: &[anchor_lang::solana_program::account_info::AccountInfo<
                    'info,
                >],
                _ix_data: &[u8],
                _bumps: &WithdrawBumps,
            ) -> anchor_lang::Result<()> {
                anchor_lang::AccountsFinalize::finalize(
                        &mut self.pool_state,
                        program_id,
                        _remaining,
                        _ix_data,
                        _bumps,
                    )
                    .map_err(|e| e.with_account_name("pool_state"))?;
                anchor_lang::AccountsFinalize::finalize(
                        &mut self.owner_lp_token,
                        program_id,
                        _remaining,
                        _ix_data,
                        _bumps,
                    )
                    .map_err(|e| e.with_account_name("owner_lp_token"))?;
                anchor_lang::AccountsFinalize::finalize(
                        &mut self.token_0_account,
                        program_id,
                        _remaining,
                        _ix_data,
                        _bumps,
                    )
                    .map_err(|e| e.with_account_name("token_0_account"))?;
                anchor_lang::AccountsFinalize::finalize(
                        &mut self.token_1_account,
                        program_id,
                        _remaining,
                        _ix_data,
                        _bumps,
                    )
                    .map_err(|e| e.with_account_name("token_1_account"))?;
                anchor_lang::AccountsFinalize::finalize(
                        &mut self.token_0_vault,
                        program_id,
                        _remaining,
                        _ix_data,
                        _bumps,
                    )
                    .map_err(|e| e.with_account_name("token_0_vault"))?;
                anchor_lang::AccountsFinalize::finalize(
                        &mut self.token_1_vault,
                        program_id,
                        _remaining,
                        _ix_data,
                        _bumps,
                    )
                    .map_err(|e| e.with_account_name("token_1_vault"))?;
                anchor_lang::AccountsFinalize::finalize(
                        &mut self.token_program,
                        program_id,
                        _remaining,
                        _ix_data,
                        _bumps,
                    )
                    .map_err(|e| e.with_account_name("token_program"))?;
                anchor_lang::AccountsFinalize::finalize(
                        &mut self.token_program_2022,
                        program_id,
                        _remaining,
                        _ix_data,
                        _bumps,
                    )
                    .map_err(|e| e.with_account_name("token_program_2022"))?;
                anchor_lang::AccountsFinalize::finalize(
                        &mut self.vault_0_mint,
                        program_id,
                        _remaining,
                        _ix_data,
                        _bumps,
                    )
                    .map_err(|e| e.with_account_name("vault_0_mint"))?;
                anchor_lang::AccountsFinalize::finalize(
                        &mut self.vault_1_mint,
                        program_id,
                        _remaining,
                        _ix_data,
                        _bumps,
                    )
                    .map_err(|e| e.with_account_name("vault_1_mint"))?;
                anchor_lang::AccountsFinalize::finalize(
                        &mut self.lp_vault,
                        program_id,
                        _remaining,
                        _ix_data,
                        _bumps,
                    )
                    .map_err(|e| e.with_account_name("lp_vault"))?;
                Ok(())
            }
        }
        #[automatically_derived]
        impl<'info> anchor_lang::AccountsExit<'info> for Withdraw<'info>
        where
            'info: 'info,
        {
            fn exit(
                &self,
                program_id: &anchor_lang::solana_program::pubkey::Pubkey,
            ) -> anchor_lang::Result<()> {
                anchor_lang::AccountsExit::exit(&self.pool_state, program_id)
                    .map_err(|e| e.with_account_name("pool_state"))?;
                anchor_lang::AccountsExit::exit(&self.owner_lp_token, program_id)
                    .map_err(|e| e.with_account_name("owner_lp_token"))?;
                anchor_lang::AccountsExit::exit(&self.token_0_account, program_id)
                    .map_err(|e| e.with_account_name("token_0_account"))?;
                anchor_lang::AccountsExit::exit(&self.token_1_account, program_id)
                    .map_err(|e| e.with_account_name("token_1_account"))?;
                anchor_lang::AccountsExit::exit(&self.token_0_vault, program_id)
                    .map_err(|e| e.with_account_name("token_0_vault"))?;
                anchor_lang::AccountsExit::exit(&self.token_1_vault, program_id)
                    .map_err(|e| e.with_account_name("token_1_vault"))?;
                anchor_lang::AccountsExit::exit(&self.lp_vault, program_id)
                    .map_err(|e| e.with_account_name("lp_vault"))?;
                anchor_lang::AccountsExit::exit(
                        &self.compressed_token_0_pool_pda,
                        program_id,
                    )
                    .map_err(|e| e.with_account_name("compressed_token_0_pool_pda"))?;
                anchor_lang::AccountsExit::exit(
                        &self.compressed_token_1_pool_pda,
                        program_id,
                    )
                    .map_err(|e| e.with_account_name("compressed_token_1_pool_pda"))?;
                Ok(())
            }
        }
        pub struct WithdrawBumps {
            pub authority: u8,
            pub lp_vault: u8,
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for WithdrawBumps {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field2_finish(
                    f,
                    "WithdrawBumps",
                    "authority",
                    &self.authority,
                    "lp_vault",
                    &&self.lp_vault,
                )
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for WithdrawBumps {
            #[inline]
            fn clone(&self) -> WithdrawBumps {
                WithdrawBumps {
                    authority: ::core::clone::Clone::clone(&self.authority),
                    lp_vault: ::core::clone::Clone::clone(&self.lp_vault),
                }
            }
        }
        impl Default for WithdrawBumps {
            fn default() -> Self {
                WithdrawBumps {
                    authority: u8::MAX,
                    lp_vault: u8::MAX,
                }
            }
        }
        impl<'info> anchor_lang::Bumps for Withdraw<'info>
        where
            'info: 'info,
        {
            type Bumps = WithdrawBumps;
        }
        /// An internal, Anchor generated module. This is used (as an
        /// implementation detail), to generate a struct for a given
        /// `#[derive(Accounts)]` implementation, where each field is a Pubkey,
        /// instead of an `AccountInfo`. This is useful for clients that want
        /// to generate a list of accounts, without explicitly knowing the
        /// order all the fields should be in.
        ///
        /// To access the struct in this module, one should use the sibling
        /// `accounts` module (also generated), which re-exports this.
        pub(crate) mod __client_accounts_withdraw {
            use super::*;
            use anchor_lang::prelude::borsh;
            /// Generated client accounts for [`Withdraw`].
            pub struct Withdraw {
                ///Pays to mint the position
                pub owner: Pubkey,
                pub authority: Pubkey,
                ///Pool state account
                pub pool_state: Pubkey,
                pub owner_lp_token: Pubkey,
                ///The token account for receive token_0,
                pub token_0_account: Pubkey,
                ///The token account for receive token_1
                pub token_1_account: Pubkey,
                ///The address that holds pool tokens for token_0
                pub token_0_vault: Pubkey,
                ///The address that holds pool tokens for token_1
                pub token_1_vault: Pubkey,
                ///token Program
                pub token_program: Pubkey,
                ///Token program 2022
                pub token_program_2022: Pubkey,
                ///The mint of token_0 vault
                pub vault_0_mint: Pubkey,
                ///The mint of token_1 vault
                pub vault_1_mint: Pubkey,
                ///Program lp token vault
                pub lp_vault: Pubkey,
                pub compressed_token_program_cpi_authority: Pubkey,
                pub compressed_token_program: Pubkey,
                ///
                ///Every mint must be registered in the compression protocol via a
                ///compression_token_pool_pda.
                pub compressed_token_0_pool_pda: Pubkey,
                pub compressed_token_1_pool_pda: Pubkey,
                ///memo program
                pub memo_program: Pubkey,
            }
            impl borsh::ser::BorshSerialize for Withdraw
            where
                Pubkey: borsh::ser::BorshSerialize,
                Pubkey: borsh::ser::BorshSerialize,
                Pubkey: borsh::ser::BorshSerialize,
                Pubkey: borsh::ser::BorshSerialize,
                Pubkey: borsh::ser::BorshSerialize,
                Pubkey: borsh::ser::BorshSerialize,
                Pubkey: borsh::ser::BorshSerialize,
                Pubkey: borsh::ser::BorshSerialize,
                Pubkey: borsh::ser::BorshSerialize,
                Pubkey: borsh::ser::BorshSerialize,
                Pubkey: borsh::ser::BorshSerialize,
                Pubkey: borsh::ser::BorshSerialize,
                Pubkey: borsh::ser::BorshSerialize,
                Pubkey: borsh::ser::BorshSerialize,
                Pubkey: borsh::ser::BorshSerialize,
                Pubkey: borsh::ser::BorshSerialize,
                Pubkey: borsh::ser::BorshSerialize,
                Pubkey: borsh::ser::BorshSerialize,
            {
                fn serialize<W: borsh::maybestd::io::Write>(
                    &self,
                    writer: &mut W,
                ) -> ::core::result::Result<(), borsh::maybestd::io::Error> {
                    borsh::BorshSerialize::serialize(&self.owner, writer)?;
                    borsh::BorshSerialize::serialize(&self.authority, writer)?;
                    borsh::BorshSerialize::serialize(&self.pool_state, writer)?;
                    borsh::BorshSerialize::serialize(&self.owner_lp_token, writer)?;
                    borsh::BorshSerialize::serialize(&self.token_0_account, writer)?;
                    borsh::BorshSerialize::serialize(&self.token_1_account, writer)?;
                    borsh::BorshSerialize::serialize(&self.token_0_vault, writer)?;
                    borsh::BorshSerialize::serialize(&self.token_1_vault, writer)?;
                    borsh::BorshSerialize::serialize(&self.token_program, writer)?;
                    borsh::BorshSerialize::serialize(&self.token_program_2022, writer)?;
                    borsh::BorshSerialize::serialize(&self.vault_0_mint, writer)?;
                    borsh::BorshSerialize::serialize(&self.vault_1_mint, writer)?;
                    borsh::BorshSerialize::serialize(&self.lp_vault, writer)?;
                    borsh::BorshSerialize::serialize(
                        &self.compressed_token_program_cpi_authority,
                        writer,
                    )?;
                    borsh::BorshSerialize::serialize(
                        &self.compressed_token_program,
                        writer,
                    )?;
                    borsh::BorshSerialize::serialize(
                        &self.compressed_token_0_pool_pda,
                        writer,
                    )?;
                    borsh::BorshSerialize::serialize(
                        &self.compressed_token_1_pool_pda,
                        writer,
                    )?;
                    borsh::BorshSerialize::serialize(&self.memo_program, writer)?;
                    Ok(())
                }
            }
            impl anchor_lang::idl::build::IdlBuild for Withdraw {
                fn create_type() -> Option<anchor_lang::idl::types::IdlTypeDef> {
                    Some(anchor_lang::idl::types::IdlTypeDef {
                        name: Self::get_full_path(),
                        docs: <[_]>::into_vec(
                            ::alloc::boxed::box_new([
                                "Generated client accounts for [`Withdraw`].".into(),
                            ]),
                        ),
                        serialization: anchor_lang::idl::types::IdlSerialization::default(),
                        repr: None,
                        generics: ::alloc::vec::Vec::new(),
                        ty: anchor_lang::idl::types::IdlTypeDefTy::Struct {
                            fields: Some(
                                anchor_lang::idl::types::IdlDefinedFields::Named(
                                    <[_]>::into_vec(
                                        ::alloc::boxed::box_new([
                                            anchor_lang::idl::types::IdlField {
                                                name: "owner".into(),
                                                docs: <[_]>::into_vec(
                                                    ::alloc::boxed::box_new([
                                                        "Pays to mint the position".into(),
                                                    ]),
                                                ),
                                                ty: anchor_lang::idl::types::IdlType::Pubkey,
                                            },
                                            anchor_lang::idl::types::IdlField {
                                                name: "authority".into(),
                                                docs: ::alloc::vec::Vec::new(),
                                                ty: anchor_lang::idl::types::IdlType::Pubkey,
                                            },
                                            anchor_lang::idl::types::IdlField {
                                                name: "pool_state".into(),
                                                docs: <[_]>::into_vec(
                                                    ::alloc::boxed::box_new(["Pool state account".into()]),
                                                ),
                                                ty: anchor_lang::idl::types::IdlType::Pubkey,
                                            },
                                            anchor_lang::idl::types::IdlField {
                                                name: "owner_lp_token".into(),
                                                docs: ::alloc::vec::Vec::new(),
                                                ty: anchor_lang::idl::types::IdlType::Pubkey,
                                            },
                                            anchor_lang::idl::types::IdlField {
                                                name: "token_0_account".into(),
                                                docs: <[_]>::into_vec(
                                                    ::alloc::boxed::box_new([
                                                        "The token account for receive token_0,".into(),
                                                    ]),
                                                ),
                                                ty: anchor_lang::idl::types::IdlType::Pubkey,
                                            },
                                            anchor_lang::idl::types::IdlField {
                                                name: "token_1_account".into(),
                                                docs: <[_]>::into_vec(
                                                    ::alloc::boxed::box_new([
                                                        "The token account for receive token_1".into(),
                                                    ]),
                                                ),
                                                ty: anchor_lang::idl::types::IdlType::Pubkey,
                                            },
                                            anchor_lang::idl::types::IdlField {
                                                name: "token_0_vault".into(),
                                                docs: <[_]>::into_vec(
                                                    ::alloc::boxed::box_new([
                                                        "The address that holds pool tokens for token_0".into(),
                                                    ]),
                                                ),
                                                ty: anchor_lang::idl::types::IdlType::Pubkey,
                                            },
                                            anchor_lang::idl::types::IdlField {
                                                name: "token_1_vault".into(),
                                                docs: <[_]>::into_vec(
                                                    ::alloc::boxed::box_new([
                                                        "The address that holds pool tokens for token_1".into(),
                                                    ]),
                                                ),
                                                ty: anchor_lang::idl::types::IdlType::Pubkey,
                                            },
                                            anchor_lang::idl::types::IdlField {
                                                name: "token_program".into(),
                                                docs: <[_]>::into_vec(
                                                    ::alloc::boxed::box_new(["token Program".into()]),
                                                ),
                                                ty: anchor_lang::idl::types::IdlType::Pubkey,
                                            },
                                            anchor_lang::idl::types::IdlField {
                                                name: "token_program_2022".into(),
                                                docs: <[_]>::into_vec(
                                                    ::alloc::boxed::box_new(["Token program 2022".into()]),
                                                ),
                                                ty: anchor_lang::idl::types::IdlType::Pubkey,
                                            },
                                            anchor_lang::idl::types::IdlField {
                                                name: "vault_0_mint".into(),
                                                docs: <[_]>::into_vec(
                                                    ::alloc::boxed::box_new([
                                                        "The mint of token_0 vault".into(),
                                                    ]),
                                                ),
                                                ty: anchor_lang::idl::types::IdlType::Pubkey,
                                            },
                                            anchor_lang::idl::types::IdlField {
                                                name: "vault_1_mint".into(),
                                                docs: <[_]>::into_vec(
                                                    ::alloc::boxed::box_new([
                                                        "The mint of token_1 vault".into(),
                                                    ]),
                                                ),
                                                ty: anchor_lang::idl::types::IdlType::Pubkey,
                                            },
                                            anchor_lang::idl::types::IdlField {
                                                name: "lp_vault".into(),
                                                docs: <[_]>::into_vec(
                                                    ::alloc::boxed::box_new(["Program lp token vault".into()]),
                                                ),
                                                ty: anchor_lang::idl::types::IdlType::Pubkey,
                                            },
                                            anchor_lang::idl::types::IdlField {
                                                name: "compressed_token_program_cpi_authority".into(),
                                                docs: ::alloc::vec::Vec::new(),
                                                ty: anchor_lang::idl::types::IdlType::Pubkey,
                                            },
                                            anchor_lang::idl::types::IdlField {
                                                name: "compressed_token_program".into(),
                                                docs: ::alloc::vec::Vec::new(),
                                                ty: anchor_lang::idl::types::IdlType::Pubkey,
                                            },
                                            anchor_lang::idl::types::IdlField {
                                                name: "compressed_token_0_pool_pda".into(),
                                                docs: <[_]>::into_vec(
                                                    ::alloc::boxed::box_new([
                                                        "".into(),
                                                        "Every mint must be registered in the compression protocol via a"
                                                            .into(),
                                                        "compression_token_pool_pda.".into(),
                                                    ]),
                                                ),
                                                ty: anchor_lang::idl::types::IdlType::Pubkey,
                                            },
                                            anchor_lang::idl::types::IdlField {
                                                name: "compressed_token_1_pool_pda".into(),
                                                docs: ::alloc::vec::Vec::new(),
                                                ty: anchor_lang::idl::types::IdlType::Pubkey,
                                            },
                                            anchor_lang::idl::types::IdlField {
                                                name: "memo_program".into(),
                                                docs: <[_]>::into_vec(
                                                    ::alloc::boxed::box_new(["memo program".into()]),
                                                ),
                                                ty: anchor_lang::idl::types::IdlType::Pubkey,
                                            },
                                        ]),
                                    ),
                                ),
                            ),
                        },
                    })
                }
                fn insert_types(
                    types: &mut std::collections::BTreeMap<
                        String,
                        anchor_lang::idl::types::IdlTypeDef,
                    >,
                ) {}
                fn get_full_path() -> String {
                    ::alloc::__export::must_use({
                        ::alloc::fmt::format(
                            format_args!(
                                "{0}::{1}",
                                "raydium_cp_swap::instructions::withdraw::__client_accounts_withdraw",
                                "Withdraw",
                            ),
                        )
                    })
                }
            }
            #[automatically_derived]
            impl anchor_lang::ToAccountMetas for Withdraw {
                fn to_account_metas(
                    &self,
                    is_signer: Option<bool>,
                ) -> Vec<anchor_lang::solana_program::instruction::AccountMeta> {
                    let mut account_metas = ::alloc::vec::Vec::new();
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                                self.owner,
                                true,
                            ),
                        );
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                                self.authority,
                                false,
                            ),
                        );
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new(
                                self.pool_state,
                                false,
                            ),
                        );
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new(
                                self.owner_lp_token,
                                false,
                            ),
                        );
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new(
                                self.token_0_account,
                                false,
                            ),
                        );
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new(
                                self.token_1_account,
                                false,
                            ),
                        );
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new(
                                self.token_0_vault,
                                false,
                            ),
                        );
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new(
                                self.token_1_vault,
                                false,
                            ),
                        );
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                                self.token_program,
                                false,
                            ),
                        );
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                                self.token_program_2022,
                                false,
                            ),
                        );
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                                self.vault_0_mint,
                                false,
                            ),
                        );
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                                self.vault_1_mint,
                                false,
                            ),
                        );
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new(
                                self.lp_vault,
                                false,
                            ),
                        );
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                                self.compressed_token_program_cpi_authority,
                                false,
                            ),
                        );
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                                self.compressed_token_program,
                                false,
                            ),
                        );
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new(
                                self.compressed_token_0_pool_pda,
                                false,
                            ),
                        );
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new(
                                self.compressed_token_1_pool_pda,
                                false,
                            ),
                        );
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                                self.memo_program,
                                false,
                            ),
                        );
                    account_metas
                }
            }
        }
        /// An internal, Anchor generated module. This is used (as an
        /// implementation detail), to generate a CPI struct for a given
        /// `#[derive(Accounts)]` implementation, where each field is an
        /// AccountInfo.
        ///
        /// To access the struct in this module, one should use the sibling
        /// [`cpi::accounts`] module (also generated), which re-exports this.
        pub(crate) mod __cpi_client_accounts_withdraw {
            use super::*;
            /// Generated CPI struct of the accounts for [`Withdraw`].
            pub struct Withdraw<'info> {
                ///Pays to mint the position
                pub owner: anchor_lang::solana_program::account_info::AccountInfo<'info>,
                pub authority: anchor_lang::solana_program::account_info::AccountInfo<
                    'info,
                >,
                ///Pool state account
                pub pool_state: anchor_lang::solana_program::account_info::AccountInfo<
                    'info,
                >,
                pub owner_lp_token: anchor_lang::solana_program::account_info::AccountInfo<
                    'info,
                >,
                ///The token account for receive token_0,
                pub token_0_account: anchor_lang::solana_program::account_info::AccountInfo<
                    'info,
                >,
                ///The token account for receive token_1
                pub token_1_account: anchor_lang::solana_program::account_info::AccountInfo<
                    'info,
                >,
                ///The address that holds pool tokens for token_0
                pub token_0_vault: anchor_lang::solana_program::account_info::AccountInfo<
                    'info,
                >,
                ///The address that holds pool tokens for token_1
                pub token_1_vault: anchor_lang::solana_program::account_info::AccountInfo<
                    'info,
                >,
                ///token Program
                pub token_program: anchor_lang::solana_program::account_info::AccountInfo<
                    'info,
                >,
                ///Token program 2022
                pub token_program_2022: anchor_lang::solana_program::account_info::AccountInfo<
                    'info,
                >,
                ///The mint of token_0 vault
                pub vault_0_mint: anchor_lang::solana_program::account_info::AccountInfo<
                    'info,
                >,
                ///The mint of token_1 vault
                pub vault_1_mint: anchor_lang::solana_program::account_info::AccountInfo<
                    'info,
                >,
                ///Program lp token vault
                pub lp_vault: anchor_lang::solana_program::account_info::AccountInfo<
                    'info,
                >,
                pub compressed_token_program_cpi_authority: anchor_lang::solana_program::account_info::AccountInfo<
                    'info,
                >,
                pub compressed_token_program: anchor_lang::solana_program::account_info::AccountInfo<
                    'info,
                >,
                ///
                ///Every mint must be registered in the compression protocol via a
                ///compression_token_pool_pda.
                pub compressed_token_0_pool_pda: anchor_lang::solana_program::account_info::AccountInfo<
                    'info,
                >,
                pub compressed_token_1_pool_pda: anchor_lang::solana_program::account_info::AccountInfo<
                    'info,
                >,
                ///memo program
                pub memo_program: anchor_lang::solana_program::account_info::AccountInfo<
                    'info,
                >,
            }
            #[automatically_derived]
            impl<'info> anchor_lang::ToAccountMetas for Withdraw<'info> {
                fn to_account_metas(
                    &self,
                    is_signer: Option<bool>,
                ) -> Vec<anchor_lang::solana_program::instruction::AccountMeta> {
                    let mut account_metas = ::alloc::vec::Vec::new();
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                                anchor_lang::Key::key(&self.owner),
                                true,
                            ),
                        );
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                                anchor_lang::Key::key(&self.authority),
                                false,
                            ),
                        );
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new(
                                anchor_lang::Key::key(&self.pool_state),
                                false,
                            ),
                        );
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new(
                                anchor_lang::Key::key(&self.owner_lp_token),
                                false,
                            ),
                        );
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new(
                                anchor_lang::Key::key(&self.token_0_account),
                                false,
                            ),
                        );
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new(
                                anchor_lang::Key::key(&self.token_1_account),
                                false,
                            ),
                        );
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new(
                                anchor_lang::Key::key(&self.token_0_vault),
                                false,
                            ),
                        );
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new(
                                anchor_lang::Key::key(&self.token_1_vault),
                                false,
                            ),
                        );
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                                anchor_lang::Key::key(&self.token_program),
                                false,
                            ),
                        );
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                                anchor_lang::Key::key(&self.token_program_2022),
                                false,
                            ),
                        );
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                                anchor_lang::Key::key(&self.vault_0_mint),
                                false,
                            ),
                        );
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                                anchor_lang::Key::key(&self.vault_1_mint),
                                false,
                            ),
                        );
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new(
                                anchor_lang::Key::key(&self.lp_vault),
                                false,
                            ),
                        );
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                                anchor_lang::Key::key(
                                    &self.compressed_token_program_cpi_authority,
                                ),
                                false,
                            ),
                        );
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                                anchor_lang::Key::key(&self.compressed_token_program),
                                false,
                            ),
                        );
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new(
                                anchor_lang::Key::key(&self.compressed_token_0_pool_pda),
                                false,
                            ),
                        );
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new(
                                anchor_lang::Key::key(&self.compressed_token_1_pool_pda),
                                false,
                            ),
                        );
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                                anchor_lang::Key::key(&self.memo_program),
                                false,
                            ),
                        );
                    account_metas
                }
            }
            #[automatically_derived]
            impl<'info> anchor_lang::ToAccountInfos<'info> for Withdraw<'info> {
                fn to_account_infos(
                    &self,
                ) -> Vec<anchor_lang::solana_program::account_info::AccountInfo<'info>> {
                    let mut account_infos = ::alloc::vec::Vec::new();
                    account_infos
                        .extend(
                            anchor_lang::ToAccountInfos::to_account_infos(&self.owner),
                        );
                    account_infos
                        .extend(
                            anchor_lang::ToAccountInfos::to_account_infos(
                                &self.authority,
                            ),
                        );
                    account_infos
                        .extend(
                            anchor_lang::ToAccountInfos::to_account_infos(
                                &self.pool_state,
                            ),
                        );
                    account_infos
                        .extend(
                            anchor_lang::ToAccountInfos::to_account_infos(
                                &self.owner_lp_token,
                            ),
                        );
                    account_infos
                        .extend(
                            anchor_lang::ToAccountInfos::to_account_infos(
                                &self.token_0_account,
                            ),
                        );
                    account_infos
                        .extend(
                            anchor_lang::ToAccountInfos::to_account_infos(
                                &self.token_1_account,
                            ),
                        );
                    account_infos
                        .extend(
                            anchor_lang::ToAccountInfos::to_account_infos(
                                &self.token_0_vault,
                            ),
                        );
                    account_infos
                        .extend(
                            anchor_lang::ToAccountInfos::to_account_infos(
                                &self.token_1_vault,
                            ),
                        );
                    account_infos
                        .extend(
                            anchor_lang::ToAccountInfos::to_account_infos(
                                &self.token_program,
                            ),
                        );
                    account_infos
                        .extend(
                            anchor_lang::ToAccountInfos::to_account_infos(
                                &self.token_program_2022,
                            ),
                        );
                    account_infos
                        .extend(
                            anchor_lang::ToAccountInfos::to_account_infos(
                                &self.vault_0_mint,
                            ),
                        );
                    account_infos
                        .extend(
                            anchor_lang::ToAccountInfos::to_account_infos(
                                &self.vault_1_mint,
                            ),
                        );
                    account_infos
                        .extend(
                            anchor_lang::ToAccountInfos::to_account_infos(&self.lp_vault),
                        );
                    account_infos
                        .extend(
                            anchor_lang::ToAccountInfos::to_account_infos(
                                &self.compressed_token_program_cpi_authority,
                            ),
                        );
                    account_infos
                        .extend(
                            anchor_lang::ToAccountInfos::to_account_infos(
                                &self.compressed_token_program,
                            ),
                        );
                    account_infos
                        .extend(
                            anchor_lang::ToAccountInfos::to_account_infos(
                                &self.compressed_token_0_pool_pda,
                            ),
                        );
                    account_infos
                        .extend(
                            anchor_lang::ToAccountInfos::to_account_infos(
                                &self.compressed_token_1_pool_pda,
                            ),
                        );
                    account_infos
                        .extend(
                            anchor_lang::ToAccountInfos::to_account_infos(
                                &self.memo_program,
                            ),
                        );
                    account_infos
                }
            }
        }
        impl<'info> Withdraw<'info> {
            pub fn __anchor_private_gen_idl_accounts(
                accounts: &mut std::collections::BTreeMap<
                    String,
                    anchor_lang::idl::types::IdlAccount,
                >,
                types: &mut std::collections::BTreeMap<
                    String,
                    anchor_lang::idl::types::IdlTypeDef,
                >,
            ) -> Vec<anchor_lang::idl::types::IdlInstructionAccountItem> {
                if let Some(ty) = <PoolState>::create_type() {
                    let account = anchor_lang::idl::types::IdlAccount {
                        name: ty.name.clone(),
                        discriminator: PoolState::DISCRIMINATOR.into(),
                    };
                    accounts.insert(account.name.clone(), account);
                    types.insert(ty.name.clone(), ty);
                    <PoolState>::insert_types(types);
                }
                if let Some(ty) = <TokenAccount>::create_type() {
                    let account = anchor_lang::idl::types::IdlAccount {
                        name: ty.name.clone(),
                        discriminator: TokenAccount::DISCRIMINATOR.into(),
                    };
                    accounts.insert(account.name.clone(), account);
                    types.insert(ty.name.clone(), ty);
                    <TokenAccount>::insert_types(types);
                }
                if let Some(ty) = <TokenAccount>::create_type() {
                    let account = anchor_lang::idl::types::IdlAccount {
                        name: ty.name.clone(),
                        discriminator: TokenAccount::DISCRIMINATOR.into(),
                    };
                    accounts.insert(account.name.clone(), account);
                    types.insert(ty.name.clone(), ty);
                    <TokenAccount>::insert_types(types);
                }
                if let Some(ty) = <TokenAccount>::create_type() {
                    let account = anchor_lang::idl::types::IdlAccount {
                        name: ty.name.clone(),
                        discriminator: TokenAccount::DISCRIMINATOR.into(),
                    };
                    accounts.insert(account.name.clone(), account);
                    types.insert(ty.name.clone(), ty);
                    <TokenAccount>::insert_types(types);
                }
                if let Some(ty) = <TokenAccount>::create_type() {
                    let account = anchor_lang::idl::types::IdlAccount {
                        name: ty.name.clone(),
                        discriminator: TokenAccount::DISCRIMINATOR.into(),
                    };
                    accounts.insert(account.name.clone(), account);
                    types.insert(ty.name.clone(), ty);
                    <TokenAccount>::insert_types(types);
                }
                if let Some(ty) = <TokenAccount>::create_type() {
                    let account = anchor_lang::idl::types::IdlAccount {
                        name: ty.name.clone(),
                        discriminator: TokenAccount::DISCRIMINATOR.into(),
                    };
                    accounts.insert(account.name.clone(), account);
                    types.insert(ty.name.clone(), ty);
                    <TokenAccount>::insert_types(types);
                }
                if let Some(ty) = <Mint>::create_type() {
                    let account = anchor_lang::idl::types::IdlAccount {
                        name: ty.name.clone(),
                        discriminator: Mint::DISCRIMINATOR.into(),
                    };
                    accounts.insert(account.name.clone(), account);
                    types.insert(ty.name.clone(), ty);
                    <Mint>::insert_types(types);
                }
                if let Some(ty) = <Mint>::create_type() {
                    let account = anchor_lang::idl::types::IdlAccount {
                        name: ty.name.clone(),
                        discriminator: Mint::DISCRIMINATOR.into(),
                    };
                    accounts.insert(account.name.clone(), account);
                    types.insert(ty.name.clone(), ty);
                    <Mint>::insert_types(types);
                }
                if let Some(ty) = <TokenAccount>::create_type() {
                    let account = anchor_lang::idl::types::IdlAccount {
                        name: ty.name.clone(),
                        discriminator: TokenAccount::DISCRIMINATOR.into(),
                    };
                    accounts.insert(account.name.clone(), account);
                    types.insert(ty.name.clone(), ty);
                    <TokenAccount>::insert_types(types);
                }
                <[_]>::into_vec(
                    ::alloc::boxed::box_new([
                        anchor_lang::idl::types::IdlInstructionAccountItem::Single(anchor_lang::idl::types::IdlInstructionAccount {
                            name: "owner".into(),
                            docs: <[_]>::into_vec(
                                ::alloc::boxed::box_new([
                                    "Pays to mint the position".into(),
                                ]),
                            ),
                            writable: false,
                            signer: true,
                            optional: false,
                            address: None,
                            pda: None,
                            relations: ::alloc::vec::Vec::new(),
                        }),
                        anchor_lang::idl::types::IdlInstructionAccountItem::Single(anchor_lang::idl::types::IdlInstructionAccount {
                            name: "authority".into(),
                            docs: ::alloc::vec::Vec::new(),
                            writable: false,
                            signer: false,
                            optional: false,
                            address: None,
                            pda: None,
                            relations: ::alloc::vec::Vec::new(),
                        }),
                        anchor_lang::idl::types::IdlInstructionAccountItem::Single(anchor_lang::idl::types::IdlInstructionAccount {
                            name: "pool_state".into(),
                            docs: <[_]>::into_vec(
                                ::alloc::boxed::box_new(["Pool state account".into()]),
                            ),
                            writable: true,
                            signer: false,
                            optional: false,
                            address: None,
                            pda: None,
                            relations: ::alloc::vec::Vec::new(),
                        }),
                        anchor_lang::idl::types::IdlInstructionAccountItem::Single(anchor_lang::idl::types::IdlInstructionAccount {
                            name: "owner_lp_token".into(),
                            docs: ::alloc::vec::Vec::new(),
                            writable: true,
                            signer: false,
                            optional: false,
                            address: None,
                            pda: None,
                            relations: ::alloc::vec::Vec::new(),
                        }),
                        anchor_lang::idl::types::IdlInstructionAccountItem::Single(anchor_lang::idl::types::IdlInstructionAccount {
                            name: "token_0_account".into(),
                            docs: <[_]>::into_vec(
                                ::alloc::boxed::box_new([
                                    "The token account for receive token_0,".into(),
                                ]),
                            ),
                            writable: true,
                            signer: false,
                            optional: false,
                            address: None,
                            pda: None,
                            relations: ::alloc::vec::Vec::new(),
                        }),
                        anchor_lang::idl::types::IdlInstructionAccountItem::Single(anchor_lang::idl::types::IdlInstructionAccount {
                            name: "token_1_account".into(),
                            docs: <[_]>::into_vec(
                                ::alloc::boxed::box_new([
                                    "The token account for receive token_1".into(),
                                ]),
                            ),
                            writable: true,
                            signer: false,
                            optional: false,
                            address: None,
                            pda: None,
                            relations: ::alloc::vec::Vec::new(),
                        }),
                        anchor_lang::idl::types::IdlInstructionAccountItem::Single(anchor_lang::idl::types::IdlInstructionAccount {
                            name: "token_0_vault".into(),
                            docs: <[_]>::into_vec(
                                ::alloc::boxed::box_new([
                                    "The address that holds pool tokens for token_0".into(),
                                ]),
                            ),
                            writable: true,
                            signer: false,
                            optional: false,
                            address: None,
                            pda: None,
                            relations: ::alloc::vec::Vec::new(),
                        }),
                        anchor_lang::idl::types::IdlInstructionAccountItem::Single(anchor_lang::idl::types::IdlInstructionAccount {
                            name: "token_1_vault".into(),
                            docs: <[_]>::into_vec(
                                ::alloc::boxed::box_new([
                                    "The address that holds pool tokens for token_1".into(),
                                ]),
                            ),
                            writable: true,
                            signer: false,
                            optional: false,
                            address: None,
                            pda: None,
                            relations: ::alloc::vec::Vec::new(),
                        }),
                        anchor_lang::idl::types::IdlInstructionAccountItem::Single(anchor_lang::idl::types::IdlInstructionAccount {
                            name: "token_program".into(),
                            docs: <[_]>::into_vec(
                                ::alloc::boxed::box_new(["token Program".into()]),
                            ),
                            writable: false,
                            signer: false,
                            optional: false,
                            address: None,
                            pda: None,
                            relations: ::alloc::vec::Vec::new(),
                        }),
                        anchor_lang::idl::types::IdlInstructionAccountItem::Single(anchor_lang::idl::types::IdlInstructionAccount {
                            name: "token_program_2022".into(),
                            docs: <[_]>::into_vec(
                                ::alloc::boxed::box_new(["Token program 2022".into()]),
                            ),
                            writable: false,
                            signer: false,
                            optional: false,
                            address: None,
                            pda: None,
                            relations: ::alloc::vec::Vec::new(),
                        }),
                        anchor_lang::idl::types::IdlInstructionAccountItem::Single(anchor_lang::idl::types::IdlInstructionAccount {
                            name: "vault_0_mint".into(),
                            docs: <[_]>::into_vec(
                                ::alloc::boxed::box_new([
                                    "The mint of token_0 vault".into(),
                                ]),
                            ),
                            writable: false,
                            signer: false,
                            optional: false,
                            address: None,
                            pda: None,
                            relations: ::alloc::vec::Vec::new(),
                        }),
                        anchor_lang::idl::types::IdlInstructionAccountItem::Single(anchor_lang::idl::types::IdlInstructionAccount {
                            name: "vault_1_mint".into(),
                            docs: <[_]>::into_vec(
                                ::alloc::boxed::box_new([
                                    "The mint of token_1 vault".into(),
                                ]),
                            ),
                            writable: false,
                            signer: false,
                            optional: false,
                            address: None,
                            pda: None,
                            relations: ::alloc::vec::Vec::new(),
                        }),
                        anchor_lang::idl::types::IdlInstructionAccountItem::Single(anchor_lang::idl::types::IdlInstructionAccount {
                            name: "lp_vault".into(),
                            docs: <[_]>::into_vec(
                                ::alloc::boxed::box_new(["Program lp token vault".into()]),
                            ),
                            writable: true,
                            signer: false,
                            optional: false,
                            address: None,
                            pda: None,
                            relations: ::alloc::vec::Vec::new(),
                        }),
                        anchor_lang::idl::types::IdlInstructionAccountItem::Single(anchor_lang::idl::types::IdlInstructionAccount {
                            name: "compressed_token_program_cpi_authority".into(),
                            docs: ::alloc::vec::Vec::new(),
                            writable: false,
                            signer: false,
                            optional: false,
                            address: None,
                            pda: None,
                            relations: ::alloc::vec::Vec::new(),
                        }),
                        anchor_lang::idl::types::IdlInstructionAccountItem::Single(anchor_lang::idl::types::IdlInstructionAccount {
                            name: "compressed_token_program".into(),
                            docs: ::alloc::vec::Vec::new(),
                            writable: false,
                            signer: false,
                            optional: false,
                            address: None,
                            pda: None,
                            relations: ::alloc::vec::Vec::new(),
                        }),
                        anchor_lang::idl::types::IdlInstructionAccountItem::Single(anchor_lang::idl::types::IdlInstructionAccount {
                            name: "compressed_token_0_pool_pda".into(),
                            docs: <[_]>::into_vec(
                                ::alloc::boxed::box_new([
                                    "".into(),
                                    "Every mint must be registered in the compression protocol via a"
                                        .into(),
                                    "compression_token_pool_pda.".into(),
                                ]),
                            ),
                            writable: true,
                            signer: false,
                            optional: false,
                            address: None,
                            pda: None,
                            relations: ::alloc::vec::Vec::new(),
                        }),
                        anchor_lang::idl::types::IdlInstructionAccountItem::Single(anchor_lang::idl::types::IdlInstructionAccount {
                            name: "compressed_token_1_pool_pda".into(),
                            docs: ::alloc::vec::Vec::new(),
                            writable: true,
                            signer: false,
                            optional: false,
                            address: None,
                            pda: None,
                            relations: ::alloc::vec::Vec::new(),
                        }),
                        anchor_lang::idl::types::IdlInstructionAccountItem::Single(anchor_lang::idl::types::IdlInstructionAccount {
                            name: "memo_program".into(),
                            docs: <[_]>::into_vec(
                                ::alloc::boxed::box_new(["memo program".into()]),
                            ),
                            writable: false,
                            signer: false,
                            optional: false,
                            address: None,
                            pda: None,
                            relations: ::alloc::vec::Vec::new(),
                        }),
                    ]),
                )
            }
            pub fn __anchor_private_gen_light_metadata() -> Option<
                anchor_lang::idl::types::IdlLightInstructionMeta,
            > {
                Some(anchor_lang::idl::types::IdlLightInstructionMeta {
                    ctokens: None,
                    cpdas: Some(
                        <[_]>::into_vec(
                            ::alloc::boxed::box_new([
                                anchor_lang::idl::types::IdlLightCpdaUsage {
                                    account: "pool_state".to_string(),
                                    ty: "PoolState".to_string(),
                                },
                            ]),
                        ),
                    ),
                })
            }
        }
        pub fn withdraw(
            ctx: Context<Withdraw>,
            lp_token_amount: u64,
            minimum_token_0_amount: u64,
            minimum_token_1_amount: u64,
        ) -> Result<()> {
            if lp_token_amount <= 0 {
                return Err(
                    anchor_lang::error::Error::from(anchor_lang::error::AnchorError {
                            error_name: anchor_lang::error::ErrorCode::RequireGtViolated
                                .name(),
                            error_code_number: anchor_lang::error::ErrorCode::RequireGtViolated
                                .into(),
                            error_msg: anchor_lang::error::ErrorCode::RequireGtViolated
                                .to_string(),
                            error_origin: Some(
                                anchor_lang::error::ErrorOrigin::Source(anchor_lang::error::Source {
                                    filename: "programs/cp-swap/src/instructions/withdraw.rs",
                                    line: 129u32,
                                }),
                            ),
                            compared_values: None,
                        })
                        .with_values((lp_token_amount, 0)),
                );
            }
            if ctx.accounts.lp_vault.amount <= 0 {
                return Err(
                    anchor_lang::error::Error::from(anchor_lang::error::AnchorError {
                            error_name: anchor_lang::error::ErrorCode::RequireGtViolated
                                .name(),
                            error_code_number: anchor_lang::error::ErrorCode::RequireGtViolated
                                .into(),
                            error_msg: anchor_lang::error::ErrorCode::RequireGtViolated
                                .to_string(),
                            error_origin: Some(
                                anchor_lang::error::ErrorOrigin::Source(anchor_lang::error::Source {
                                    filename: "programs/cp-swap/src/instructions/withdraw.rs",
                                    line: 130u32,
                                }),
                            ),
                            compared_values: None,
                        })
                        .with_values((ctx.accounts.lp_vault.amount, 0)),
                );
            }
            let pool_id = ctx.accounts.pool_state.key();
            let pool_state = &mut ctx.accounts.pool_state;
            if !pool_state.get_status_by_bit(PoolStatusBitIndex::Withdraw) {
                return Err(
                    anchor_lang::error::Error::from(anchor_lang::error::AnchorError {
                        error_name: ErrorCode::NotApproved.name(),
                        error_code_number: ErrorCode::NotApproved.into(),
                        error_msg: ErrorCode::NotApproved.to_string(),
                        error_origin: Some(
                            anchor_lang::error::ErrorOrigin::Source(anchor_lang::error::Source {
                                filename: "programs/cp-swap/src/instructions/withdraw.rs",
                                line: 134u32,
                            }),
                        ),
                        compared_values: None,
                    }),
                );
            }
            let (total_token_0_amount, total_token_1_amount) = pool_state
                .vault_amount_without_fee(
                    ctx.accounts.token_0_vault.amount,
                    ctx.accounts.token_1_vault.amount,
                );
            let results = CurveCalculator::lp_tokens_to_trading_tokens(
                    u128::from(lp_token_amount),
                    u128::from(pool_state.lp_supply),
                    u128::from(total_token_0_amount),
                    u128::from(total_token_1_amount),
                    RoundDirection::Floor,
                )
                .ok_or(ErrorCode::ZeroTradingTokens)?;
            if results.token_0_amount == 0 || results.token_1_amount == 0 {
                return Err(
                    anchor_lang::error::Error::from(anchor_lang::error::AnchorError {
                        error_name: ErrorCode::ZeroTradingTokens.name(),
                        error_code_number: ErrorCode::ZeroTradingTokens.into(),
                        error_msg: ErrorCode::ZeroTradingTokens.to_string(),
                        error_origin: Some(
                            anchor_lang::error::ErrorOrigin::Source(anchor_lang::error::Source {
                                filename: "programs/cp-swap/src/instructions/withdraw.rs",
                                line: 149u32,
                            }),
                        ),
                        compared_values: None,
                    }),
                );
            }
            let token_0_amount = u64::try_from(results.token_0_amount).unwrap();
            let token_0_amount = std::cmp::min(total_token_0_amount, token_0_amount);
            let (receive_token_0_amount, token_0_transfer_fee) = {
                let transfer_fee = get_transfer_fee(
                    &ctx.accounts.vault_0_mint.to_account_info(),
                    token_0_amount,
                )?;
                (token_0_amount.checked_sub(transfer_fee).unwrap(), transfer_fee)
            };
            let token_1_amount = u64::try_from(results.token_1_amount).unwrap();
            let token_1_amount = std::cmp::min(total_token_1_amount, token_1_amount);
            let (receive_token_1_amount, token_1_transfer_fee) = {
                let transfer_fee = get_transfer_fee(
                    &ctx.accounts.vault_1_mint.to_account_info(),
                    token_1_amount,
                )?;
                (token_1_amount.checked_sub(transfer_fee).unwrap(), transfer_fee)
            };
            {
                anchor_lang::solana_program::log::sol_log_data(
                    &[
                        &anchor_lang::Event::data(
                            &LpChangeEvent {
                                pool_id,
                                lp_amount_before: pool_state.lp_supply,
                                token_0_vault_before: total_token_0_amount,
                                token_1_vault_before: total_token_1_amount,
                                token_0_amount: receive_token_0_amount,
                                token_1_amount: receive_token_1_amount,
                                token_0_transfer_fee,
                                token_1_transfer_fee,
                                change_type: 1,
                            },
                        ),
                    ],
                );
            };
            if receive_token_0_amount < minimum_token_0_amount
                || receive_token_1_amount < minimum_token_1_amount
            {
                return Err(ErrorCode::ExceededSlippage.into());
            }
            transfer_ctoken_from_user_to_pool_vault(
                ctx.accounts.owner.to_account_info(),
                ctx.accounts.owner_lp_token.to_account_info(),
                ctx.accounts.lp_vault.to_account_info(),
                lp_token_amount,
            )?;
            pool_state.lp_supply = pool_state
                .lp_supply
                .checked_sub(lp_token_amount)
                .unwrap();
            let (compressed_token_0_pool_bump, compressed_token_1_pool_bump) = get_bumps(
                ctx.accounts.vault_0_mint.key(),
                ctx.accounts.vault_1_mint.key(),
                ctx.accounts.compressed_token_program.key(),
            );
            transfer_from_pool_vault_to_user(
                ctx.accounts.owner.to_account_info(),
                ctx.accounts.authority.to_account_info(),
                ctx.accounts.token_0_vault.to_account_info(),
                ctx.accounts.token_0_account.to_account_info(),
                Some(ctx.accounts.vault_0_mint.to_account_info()),
                Some(
                    if ctx.accounts.vault_0_mint.to_account_info().owner
                        == ctx.accounts.token_program.key
                    {
                        ctx.accounts.token_program.to_account_info()
                    } else {
                        ctx.accounts.token_program_2022.to_account_info()
                    },
                ),
                Some(ctx.accounts.compressed_token_0_pool_pda.to_account_info()),
                Some(compressed_token_0_pool_bump),
                ctx.accounts.compressed_token_program_cpi_authority.to_account_info(),
                token_0_amount,
                &[&[crate::AUTH_SEED.as_bytes(), &[pool_state.auth_bump]]],
            )?;
            transfer_from_pool_vault_to_user(
                ctx.accounts.owner.to_account_info(),
                ctx.accounts.authority.to_account_info(),
                ctx.accounts.token_1_vault.to_account_info(),
                ctx.accounts.token_1_account.to_account_info(),
                Some(ctx.accounts.vault_1_mint.to_account_info()),
                Some(
                    if ctx.accounts.vault_1_mint.to_account_info().owner
                        == ctx.accounts.token_program.key
                    {
                        ctx.accounts.token_program.to_account_info()
                    } else {
                        ctx.accounts.token_program_2022.to_account_info()
                    },
                ),
                Some(ctx.accounts.compressed_token_1_pool_pda.to_account_info()),
                Some(compressed_token_1_pool_bump),
                ctx.accounts.compressed_token_program_cpi_authority.to_account_info(),
                token_1_amount,
                &[&[crate::AUTH_SEED.as_bytes(), &[pool_state.auth_bump]]],
            )?;
            pool_state.recent_epoch = Clock::get()?.epoch;
            pool_state.compression_info_mut().bump_last_written_slot().unwrap();
            Ok(())
        }
    }
    pub use deposit::*;
    pub use initialize::*;
    pub use swap_base_input::*;
    pub use withdraw::*;
    pub mod admin {
        pub mod create_config {
            use crate::error::ErrorCode;
            use crate::states::*;
            use anchor_lang::prelude::*;
            use std::ops::DerefMut;
            #[instruction(index:u16)]
            pub struct CreateAmmConfig<'info> {
                /// Address to be set as protocol owner.
                #[account(mut, address = crate::admin::ID@ErrorCode::InvalidOwner)]
                pub owner: Signer<'info>,
                /// Initialize config state account to store protocol owner address and fee rates.
                #[account(
                    init,
                    seeds = [AMM_CONFIG_SEED.as_bytes(),
                    &index.to_be_bytes()],
                    bump,
                    payer = owner,
                    space = AmmConfig::LEN
                )]
                pub amm_config: Account<'info, AmmConfig>,
                pub system_program: Program<'info, System>,
            }
            #[automatically_derived]
            impl<'info> anchor_lang::Accounts<'info, CreateAmmConfigBumps>
            for CreateAmmConfig<'info>
            where
                'info: 'info,
            {
                #[inline(never)]
                fn try_accounts(
                    __program_id: &anchor_lang::solana_program::pubkey::Pubkey,
                    __accounts: &mut &'info [anchor_lang::solana_program::account_info::AccountInfo<
                        'info,
                    >],
                    __ix_data: &[u8],
                    __bumps: &mut CreateAmmConfigBumps,
                    __reallocs: &mut std::collections::BTreeSet<
                        anchor_lang::solana_program::pubkey::Pubkey,
                    >,
                ) -> anchor_lang::Result<Self> {
                    let mut __ix_data = __ix_data;
                    struct __Args {
                        index: u16,
                    }
                    impl borsh::ser::BorshSerialize for __Args
                    where
                        u16: borsh::ser::BorshSerialize,
                    {
                        fn serialize<W: borsh::maybestd::io::Write>(
                            &self,
                            writer: &mut W,
                        ) -> ::core::result::Result<(), borsh::maybestd::io::Error> {
                            borsh::BorshSerialize::serialize(&self.index, writer)?;
                            Ok(())
                        }
                    }
                    impl anchor_lang::idl::build::IdlBuild for __Args {
                        fn create_type() -> Option<anchor_lang::idl::types::IdlTypeDef> {
                            Some(anchor_lang::idl::types::IdlTypeDef {
                                name: Self::get_full_path(),
                                docs: ::alloc::vec::Vec::new(),
                                serialization: anchor_lang::idl::types::IdlSerialization::default(),
                                repr: None,
                                generics: ::alloc::vec::Vec::new(),
                                ty: anchor_lang::idl::types::IdlTypeDefTy::Struct {
                                    fields: Some(
                                        anchor_lang::idl::types::IdlDefinedFields::Named(
                                            <[_]>::into_vec(
                                                ::alloc::boxed::box_new([
                                                    anchor_lang::idl::types::IdlField {
                                                        name: "index".into(),
                                                        docs: ::alloc::vec::Vec::new(),
                                                        ty: anchor_lang::idl::types::IdlType::U16,
                                                    },
                                                ]),
                                            ),
                                        ),
                                    ),
                                },
                            })
                        }
                        fn insert_types(
                            types: &mut std::collections::BTreeMap<
                                String,
                                anchor_lang::idl::types::IdlTypeDef,
                            >,
                        ) {}
                        fn get_full_path() -> String {
                            ::alloc::__export::must_use({
                                ::alloc::fmt::format(
                                    format_args!(
                                        "{0}::{1}",
                                        "raydium_cp_swap::instructions::admin::create_config",
                                        "__Args",
                                    ),
                                )
                            })
                        }
                    }
                    impl borsh::de::BorshDeserialize for __Args
                    where
                        u16: borsh::BorshDeserialize,
                    {
                        fn deserialize_reader<R: borsh::maybestd::io::Read>(
                            reader: &mut R,
                        ) -> ::core::result::Result<Self, borsh::maybestd::io::Error> {
                            Ok(Self {
                                index: borsh::BorshDeserialize::deserialize_reader(reader)?,
                            })
                        }
                    }
                    let __args: __Args = __Args::deserialize(&mut __ix_data)
                        .map_err(|_| {
                            anchor_lang::error::ErrorCode::InstructionDidNotDeserialize
                        })?;
                    let index = __args.index;
                    let _ = __args;
                    let owner: Signer = anchor_lang::Accounts::try_accounts(
                            __program_id,
                            __accounts,
                            __ix_data,
                            __bumps,
                            __reallocs,
                        )
                        .map_err(|e| e.with_account_name("owner"))?;
                    if __accounts.is_empty() {
                        return Err(
                            anchor_lang::error::ErrorCode::AccountNotEnoughKeys.into(),
                        );
                    }
                    let amm_config = &__accounts[0];
                    *__accounts = &__accounts[1..];
                    let system_program: anchor_lang::accounts::program::Program<
                        System,
                    > = anchor_lang::Accounts::try_accounts(
                            __program_id,
                            __accounts,
                            __ix_data,
                            __bumps,
                            __reallocs,
                        )
                        .map_err(|e| e.with_account_name("system_program"))?;
                    let __anchor_rent = Rent::get()?;
                    let (__pda_address, __bump) = Pubkey::find_program_address(
                        &[AMM_CONFIG_SEED.as_bytes(), &index.to_be_bytes()],
                        __program_id,
                    );
                    __bumps.amm_config = __bump;
                    if amm_config.key() != __pda_address {
                        return Err(
                            anchor_lang::error::Error::from(
                                    anchor_lang::error::ErrorCode::ConstraintSeeds,
                                )
                                .with_account_name("amm_config")
                                .with_pubkeys((amm_config.key(), __pda_address)),
                        );
                    }
                    let amm_config = ({
                        #[inline(never)]
                        || {
                            let actual_field = AsRef::<AccountInfo>::as_ref(&amm_config);
                            let actual_owner = actual_field.owner;
                            let space = AmmConfig::LEN;
                            let pa: anchor_lang::accounts::account::Account<AmmConfig> = if !false
                                || actual_owner
                                    == &anchor_lang::solana_program::system_program::ID
                            {
                                let __current_lamports = amm_config.lamports();
                                if __current_lamports == 0 {
                                    let space = space;
                                    let lamports = __anchor_rent.minimum_balance(space);
                                    let cpi_accounts = anchor_lang::system_program::CreateAccount {
                                        from: owner.to_account_info(),
                                        to: amm_config.to_account_info(),
                                    };
                                    let cpi_context = anchor_lang::context::CpiContext::new(
                                        system_program.to_account_info(),
                                        cpi_accounts,
                                    );
                                    anchor_lang::system_program::create_account(
                                        cpi_context
                                            .with_signer(
                                                &[
                                                    &[
                                                        AMM_CONFIG_SEED.as_bytes(),
                                                        &index.to_be_bytes(),
                                                        &[__bump][..],
                                                    ][..],
                                                ],
                                            ),
                                        lamports,
                                        space as u64,
                                        __program_id,
                                    )?;
                                } else {
                                    if owner.key() == amm_config.key() {
                                        return Err(
                                            anchor_lang::error::Error::from(anchor_lang::error::AnchorError {
                                                    error_name: anchor_lang::error::ErrorCode::TryingToInitPayerAsProgramAccount
                                                        .name(),
                                                    error_code_number: anchor_lang::error::ErrorCode::TryingToInitPayerAsProgramAccount
                                                        .into(),
                                                    error_msg: anchor_lang::error::ErrorCode::TryingToInitPayerAsProgramAccount
                                                        .to_string(),
                                                    error_origin: Some(
                                                        anchor_lang::error::ErrorOrigin::Source(anchor_lang::error::Source {
                                                            filename: "programs/cp-swap/src/instructions/admin/create_config.rs",
                                                            line: 6u32,
                                                        }),
                                                    ),
                                                    compared_values: None,
                                                })
                                                .with_pubkeys((owner.key(), amm_config.key())),
                                        );
                                    }
                                    let required_lamports = __anchor_rent
                                        .minimum_balance(space)
                                        .max(1)
                                        .saturating_sub(__current_lamports);
                                    if required_lamports > 0 {
                                        let cpi_accounts = anchor_lang::system_program::Transfer {
                                            from: owner.to_account_info(),
                                            to: amm_config.to_account_info(),
                                        };
                                        let cpi_context = anchor_lang::context::CpiContext::new(
                                            system_program.to_account_info(),
                                            cpi_accounts,
                                        );
                                        anchor_lang::system_program::transfer(
                                            cpi_context,
                                            required_lamports,
                                        )?;
                                    }
                                    let cpi_accounts = anchor_lang::system_program::Allocate {
                                        account_to_allocate: amm_config.to_account_info(),
                                    };
                                    let cpi_context = anchor_lang::context::CpiContext::new(
                                        system_program.to_account_info(),
                                        cpi_accounts,
                                    );
                                    anchor_lang::system_program::allocate(
                                        cpi_context
                                            .with_signer(
                                                &[
                                                    &[
                                                        AMM_CONFIG_SEED.as_bytes(),
                                                        &index.to_be_bytes(),
                                                        &[__bump][..],
                                                    ][..],
                                                ],
                                            ),
                                        space as u64,
                                    )?;
                                    let cpi_accounts = anchor_lang::system_program::Assign {
                                        account_to_assign: amm_config.to_account_info(),
                                    };
                                    let cpi_context = anchor_lang::context::CpiContext::new(
                                        system_program.to_account_info(),
                                        cpi_accounts,
                                    );
                                    anchor_lang::system_program::assign(
                                        cpi_context
                                            .with_signer(
                                                &[
                                                    &[
                                                        AMM_CONFIG_SEED.as_bytes(),
                                                        &index.to_be_bytes(),
                                                        &[__bump][..],
                                                    ][..],
                                                ],
                                            ),
                                        __program_id,
                                    )?;
                                }
                                match anchor_lang::accounts::account::Account::try_from_unchecked(
                                    &amm_config,
                                ) {
                                    Ok(val) => val,
                                    Err(e) => return Err(e.with_account_name("amm_config")),
                                }
                            } else {
                                match anchor_lang::accounts::account::Account::try_from(
                                    &amm_config,
                                ) {
                                    Ok(val) => val,
                                    Err(e) => return Err(e.with_account_name("amm_config")),
                                }
                            };
                            if false {
                                if space != actual_field.data_len() {
                                    return Err(
                                        anchor_lang::error::Error::from(
                                                anchor_lang::error::ErrorCode::ConstraintSpace,
                                            )
                                            .with_account_name("amm_config")
                                            .with_values((space, actual_field.data_len())),
                                    );
                                }
                                if actual_owner != __program_id {
                                    return Err(
                                        anchor_lang::error::Error::from(
                                                anchor_lang::error::ErrorCode::ConstraintOwner,
                                            )
                                            .with_account_name("amm_config")
                                            .with_pubkeys((*actual_owner, *__program_id)),
                                    );
                                }
                                {
                                    let required_lamports = __anchor_rent
                                        .minimum_balance(space);
                                    if pa.to_account_info().lamports() < required_lamports {
                                        return Err(
                                            anchor_lang::error::Error::from(
                                                    anchor_lang::error::ErrorCode::ConstraintRentExempt,
                                                )
                                                .with_account_name("amm_config"),
                                        );
                                    }
                                }
                            }
                            Ok(pa)
                        }
                    })()?;
                    if !AsRef::<AccountInfo>::as_ref(&amm_config).is_writable {
                        return Err(
                            anchor_lang::error::Error::from(
                                    anchor_lang::error::ErrorCode::ConstraintMut,
                                )
                                .with_account_name("amm_config"),
                        );
                    }
                    if !__anchor_rent
                        .is_exempt(
                            amm_config.to_account_info().lamports(),
                            amm_config.to_account_info().try_data_len()?,
                        )
                    {
                        return Err(
                            anchor_lang::error::Error::from(
                                    anchor_lang::error::ErrorCode::ConstraintRentExempt,
                                )
                                .with_account_name("amm_config"),
                        );
                    }
                    if !AsRef::<AccountInfo>::as_ref(&owner).is_writable {
                        return Err(
                            anchor_lang::error::Error::from(
                                    anchor_lang::error::ErrorCode::ConstraintMut,
                                )
                                .with_account_name("owner"),
                        );
                    }
                    {
                        let actual = owner.key();
                        let expected = crate::admin::ID;
                        if actual != expected {
                            return Err(
                                anchor_lang::error::Error::from(ErrorCode::InvalidOwner)
                                    .with_account_name("owner")
                                    .with_pubkeys((actual, expected)),
                            );
                        }
                    }
                    Ok(CreateAmmConfig {
                        owner,
                        amm_config,
                        system_program,
                    })
                }
            }
            #[automatically_derived]
            impl<'info> anchor_lang::ToAccountInfos<'info> for CreateAmmConfig<'info>
            where
                'info: 'info,
            {
                fn to_account_infos(
                    &self,
                ) -> Vec<anchor_lang::solana_program::account_info::AccountInfo<'info>> {
                    let mut account_infos = ::alloc::vec::Vec::new();
                    account_infos.extend(self.owner.to_account_infos());
                    account_infos.extend(self.amm_config.to_account_infos());
                    account_infos.extend(self.system_program.to_account_infos());
                    account_infos
                }
            }
            #[automatically_derived]
            impl<'info> anchor_lang::ToAccountMetas for CreateAmmConfig<'info> {
                fn to_account_metas(
                    &self,
                    is_signer: Option<bool>,
                ) -> Vec<anchor_lang::solana_program::instruction::AccountMeta> {
                    let mut account_metas = ::alloc::vec::Vec::new();
                    account_metas.extend(self.owner.to_account_metas(None));
                    account_metas.extend(self.amm_config.to_account_metas(None));
                    account_metas.extend(self.system_program.to_account_metas(None));
                    account_metas
                }
            }
            #[automatically_derived]
            impl<'info> anchor_lang::AccountsFinalize<'info, CreateAmmConfigBumps>
            for CreateAmmConfig<'info>
            where
                'info: 'info,
            {
                fn finalize(
                    &mut self,
                    program_id: &anchor_lang::solana_program::pubkey::Pubkey,
                    _remaining: &[anchor_lang::solana_program::account_info::AccountInfo<
                        'info,
                    >],
                    _ix_data: &[u8],
                    _bumps: &CreateAmmConfigBumps,
                ) -> anchor_lang::Result<()> {
                    anchor_lang::AccountsFinalize::finalize(
                            &mut self.amm_config,
                            program_id,
                            _remaining,
                            _ix_data,
                            _bumps,
                        )
                        .map_err(|e| e.with_account_name("amm_config"))?;
                    anchor_lang::AccountsFinalize::finalize(
                            &mut self.system_program,
                            program_id,
                            _remaining,
                            _ix_data,
                            _bumps,
                        )
                        .map_err(|e| e.with_account_name("system_program"))?;
                    Ok(())
                }
            }
            #[automatically_derived]
            impl<'info> anchor_lang::AccountsExit<'info> for CreateAmmConfig<'info>
            where
                'info: 'info,
            {
                fn exit(
                    &self,
                    program_id: &anchor_lang::solana_program::pubkey::Pubkey,
                ) -> anchor_lang::Result<()> {
                    anchor_lang::AccountsExit::exit(&self.owner, program_id)
                        .map_err(|e| e.with_account_name("owner"))?;
                    anchor_lang::AccountsExit::exit(&self.amm_config, program_id)
                        .map_err(|e| e.with_account_name("amm_config"))?;
                    Ok(())
                }
            }
            pub struct CreateAmmConfigBumps {
                pub amm_config: u8,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for CreateAmmConfigBumps {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field1_finish(
                        f,
                        "CreateAmmConfigBumps",
                        "amm_config",
                        &&self.amm_config,
                    )
                }
            }
            #[automatically_derived]
            impl ::core::clone::Clone for CreateAmmConfigBumps {
                #[inline]
                fn clone(&self) -> CreateAmmConfigBumps {
                    CreateAmmConfigBumps {
                        amm_config: ::core::clone::Clone::clone(&self.amm_config),
                    }
                }
            }
            impl Default for CreateAmmConfigBumps {
                fn default() -> Self {
                    CreateAmmConfigBumps {
                        amm_config: u8::MAX,
                    }
                }
            }
            impl<'info> anchor_lang::Bumps for CreateAmmConfig<'info>
            where
                'info: 'info,
            {
                type Bumps = CreateAmmConfigBumps;
            }
            /// An internal, Anchor generated module. This is used (as an
            /// implementation detail), to generate a struct for a given
            /// `#[derive(Accounts)]` implementation, where each field is a Pubkey,
            /// instead of an `AccountInfo`. This is useful for clients that want
            /// to generate a list of accounts, without explicitly knowing the
            /// order all the fields should be in.
            ///
            /// To access the struct in this module, one should use the sibling
            /// `accounts` module (also generated), which re-exports this.
            pub(crate) mod __client_accounts_create_amm_config {
                use super::*;
                use anchor_lang::prelude::borsh;
                /// Generated client accounts for [`CreateAmmConfig`].
                pub struct CreateAmmConfig {
                    ///Address to be set as protocol owner.
                    pub owner: Pubkey,
                    ///Initialize config state account to store protocol owner address and fee rates.
                    pub amm_config: Pubkey,
                    pub system_program: Pubkey,
                }
                impl borsh::ser::BorshSerialize for CreateAmmConfig
                where
                    Pubkey: borsh::ser::BorshSerialize,
                    Pubkey: borsh::ser::BorshSerialize,
                    Pubkey: borsh::ser::BorshSerialize,
                {
                    fn serialize<W: borsh::maybestd::io::Write>(
                        &self,
                        writer: &mut W,
                    ) -> ::core::result::Result<(), borsh::maybestd::io::Error> {
                        borsh::BorshSerialize::serialize(&self.owner, writer)?;
                        borsh::BorshSerialize::serialize(&self.amm_config, writer)?;
                        borsh::BorshSerialize::serialize(&self.system_program, writer)?;
                        Ok(())
                    }
                }
                impl anchor_lang::idl::build::IdlBuild for CreateAmmConfig {
                    fn create_type() -> Option<anchor_lang::idl::types::IdlTypeDef> {
                        Some(anchor_lang::idl::types::IdlTypeDef {
                            name: Self::get_full_path(),
                            docs: <[_]>::into_vec(
                                ::alloc::boxed::box_new([
                                    "Generated client accounts for [`CreateAmmConfig`].".into(),
                                ]),
                            ),
                            serialization: anchor_lang::idl::types::IdlSerialization::default(),
                            repr: None,
                            generics: ::alloc::vec::Vec::new(),
                            ty: anchor_lang::idl::types::IdlTypeDefTy::Struct {
                                fields: Some(
                                    anchor_lang::idl::types::IdlDefinedFields::Named(
                                        <[_]>::into_vec(
                                            ::alloc::boxed::box_new([
                                                anchor_lang::idl::types::IdlField {
                                                    name: "owner".into(),
                                                    docs: <[_]>::into_vec(
                                                        ::alloc::boxed::box_new([
                                                            "Address to be set as protocol owner.".into(),
                                                        ]),
                                                    ),
                                                    ty: anchor_lang::idl::types::IdlType::Pubkey,
                                                },
                                                anchor_lang::idl::types::IdlField {
                                                    name: "amm_config".into(),
                                                    docs: <[_]>::into_vec(
                                                        ::alloc::boxed::box_new([
                                                            "Initialize config state account to store protocol owner address and fee rates."
                                                                .into(),
                                                        ]),
                                                    ),
                                                    ty: anchor_lang::idl::types::IdlType::Pubkey,
                                                },
                                                anchor_lang::idl::types::IdlField {
                                                    name: "system_program".into(),
                                                    docs: ::alloc::vec::Vec::new(),
                                                    ty: anchor_lang::idl::types::IdlType::Pubkey,
                                                },
                                            ]),
                                        ),
                                    ),
                                ),
                            },
                        })
                    }
                    fn insert_types(
                        types: &mut std::collections::BTreeMap<
                            String,
                            anchor_lang::idl::types::IdlTypeDef,
                        >,
                    ) {}
                    fn get_full_path() -> String {
                        ::alloc::__export::must_use({
                            ::alloc::fmt::format(
                                format_args!(
                                    "{0}::{1}",
                                    "raydium_cp_swap::instructions::admin::create_config::__client_accounts_create_amm_config",
                                    "CreateAmmConfig",
                                ),
                            )
                        })
                    }
                }
                #[automatically_derived]
                impl anchor_lang::ToAccountMetas for CreateAmmConfig {
                    fn to_account_metas(
                        &self,
                        is_signer: Option<bool>,
                    ) -> Vec<anchor_lang::solana_program::instruction::AccountMeta> {
                        let mut account_metas = ::alloc::vec::Vec::new();
                        account_metas
                            .push(
                                anchor_lang::solana_program::instruction::AccountMeta::new(
                                    self.owner,
                                    true,
                                ),
                            );
                        account_metas
                            .push(
                                anchor_lang::solana_program::instruction::AccountMeta::new(
                                    self.amm_config,
                                    false,
                                ),
                            );
                        account_metas
                            .push(
                                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                                    self.system_program,
                                    false,
                                ),
                            );
                        account_metas
                    }
                }
            }
            /// An internal, Anchor generated module. This is used (as an
            /// implementation detail), to generate a CPI struct for a given
            /// `#[derive(Accounts)]` implementation, where each field is an
            /// AccountInfo.
            ///
            /// To access the struct in this module, one should use the sibling
            /// [`cpi::accounts`] module (also generated), which re-exports this.
            pub(crate) mod __cpi_client_accounts_create_amm_config {
                use super::*;
                /// Generated CPI struct of the accounts for [`CreateAmmConfig`].
                pub struct CreateAmmConfig<'info> {
                    ///Address to be set as protocol owner.
                    pub owner: anchor_lang::solana_program::account_info::AccountInfo<
                        'info,
                    >,
                    ///Initialize config state account to store protocol owner address and fee rates.
                    pub amm_config: anchor_lang::solana_program::account_info::AccountInfo<
                        'info,
                    >,
                    pub system_program: anchor_lang::solana_program::account_info::AccountInfo<
                        'info,
                    >,
                }
                #[automatically_derived]
                impl<'info> anchor_lang::ToAccountMetas for CreateAmmConfig<'info> {
                    fn to_account_metas(
                        &self,
                        is_signer: Option<bool>,
                    ) -> Vec<anchor_lang::solana_program::instruction::AccountMeta> {
                        let mut account_metas = ::alloc::vec::Vec::new();
                        account_metas
                            .push(
                                anchor_lang::solana_program::instruction::AccountMeta::new(
                                    anchor_lang::Key::key(&self.owner),
                                    true,
                                ),
                            );
                        account_metas
                            .push(
                                anchor_lang::solana_program::instruction::AccountMeta::new(
                                    anchor_lang::Key::key(&self.amm_config),
                                    false,
                                ),
                            );
                        account_metas
                            .push(
                                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                                    anchor_lang::Key::key(&self.system_program),
                                    false,
                                ),
                            );
                        account_metas
                    }
                }
                #[automatically_derived]
                impl<'info> anchor_lang::ToAccountInfos<'info>
                for CreateAmmConfig<'info> {
                    fn to_account_infos(
                        &self,
                    ) -> Vec<
                        anchor_lang::solana_program::account_info::AccountInfo<'info>,
                    > {
                        let mut account_infos = ::alloc::vec::Vec::new();
                        account_infos
                            .extend(
                                anchor_lang::ToAccountInfos::to_account_infos(&self.owner),
                            );
                        account_infos
                            .extend(
                                anchor_lang::ToAccountInfos::to_account_infos(
                                    &self.amm_config,
                                ),
                            );
                        account_infos
                            .extend(
                                anchor_lang::ToAccountInfos::to_account_infos(
                                    &self.system_program,
                                ),
                            );
                        account_infos
                    }
                }
            }
            impl<'info> CreateAmmConfig<'info> {
                pub fn __anchor_private_gen_idl_accounts(
                    accounts: &mut std::collections::BTreeMap<
                        String,
                        anchor_lang::idl::types::IdlAccount,
                    >,
                    types: &mut std::collections::BTreeMap<
                        String,
                        anchor_lang::idl::types::IdlTypeDef,
                    >,
                ) -> Vec<anchor_lang::idl::types::IdlInstructionAccountItem> {
                    if let Some(ty) = <AmmConfig>::create_type() {
                        let account = anchor_lang::idl::types::IdlAccount {
                            name: ty.name.clone(),
                            discriminator: AmmConfig::DISCRIMINATOR.into(),
                        };
                        accounts.insert(account.name.clone(), account);
                        types.insert(ty.name.clone(), ty);
                        <AmmConfig>::insert_types(types);
                    }
                    <[_]>::into_vec(
                        ::alloc::boxed::box_new([
                            anchor_lang::idl::types::IdlInstructionAccountItem::Single(anchor_lang::idl::types::IdlInstructionAccount {
                                name: "owner".into(),
                                docs: <[_]>::into_vec(
                                    ::alloc::boxed::box_new([
                                        "Address to be set as protocol owner.".into(),
                                    ]),
                                ),
                                writable: true,
                                signer: true,
                                optional: false,
                                address: None,
                                pda: None,
                                relations: ::alloc::vec::Vec::new(),
                            }),
                            anchor_lang::idl::types::IdlInstructionAccountItem::Single(anchor_lang::idl::types::IdlInstructionAccount {
                                name: "amm_config".into(),
                                docs: <[_]>::into_vec(
                                    ::alloc::boxed::box_new([
                                        "Initialize config state account to store protocol owner address and fee rates."
                                            .into(),
                                    ]),
                                ),
                                writable: true,
                                signer: false,
                                optional: false,
                                address: None,
                                pda: None,
                                relations: ::alloc::vec::Vec::new(),
                            }),
                            anchor_lang::idl::types::IdlInstructionAccountItem::Single(anchor_lang::idl::types::IdlInstructionAccount {
                                name: "system_program".into(),
                                docs: ::alloc::vec::Vec::new(),
                                writable: false,
                                signer: false,
                                optional: false,
                                address: None,
                                pda: None,
                                relations: ::alloc::vec::Vec::new(),
                            }),
                        ]),
                    )
                }
                pub fn __anchor_private_gen_light_metadata() -> Option<
                    anchor_lang::idl::types::IdlLightInstructionMeta,
                > {
                    None
                }
            }
            pub fn create_amm_config(
                ctx: Context<CreateAmmConfig>,
                index: u16,
                trade_fee_rate: u64,
                protocol_fee_rate: u64,
                fund_fee_rate: u64,
                create_pool_fee: u64,
            ) -> Result<()> {
                let amm_config = ctx.accounts.amm_config.deref_mut();
                amm_config.protocol_owner = ctx.accounts.owner.key();
                amm_config.bump = ctx.bumps.amm_config;
                amm_config.disable_create_pool = false;
                amm_config.index = index;
                amm_config.trade_fee_rate = trade_fee_rate;
                amm_config.protocol_fee_rate = protocol_fee_rate;
                amm_config.fund_fee_rate = fund_fee_rate;
                amm_config.create_pool_fee = create_pool_fee;
                amm_config.fund_owner = ctx.accounts.owner.key();
                Ok(())
            }
        }
        pub use create_config::*;
        pub mod update_config {
            use crate::curve::fees::FEE_RATE_DENOMINATOR_VALUE;
            use crate::error::ErrorCode;
            use crate::states::*;
            use anchor_lang::prelude::*;
            pub struct UpdateAmmConfig<'info> {
                /// The amm config owner or admin
                #[account(address = crate::admin::ID@ErrorCode::InvalidOwner)]
                pub owner: Signer<'info>,
                /// Amm config account to be changed
                #[account(mut)]
                pub amm_config: Account<'info, AmmConfig>,
            }
            #[automatically_derived]
            impl<'info> anchor_lang::Accounts<'info, UpdateAmmConfigBumps>
            for UpdateAmmConfig<'info>
            where
                'info: 'info,
            {
                #[inline(never)]
                fn try_accounts(
                    __program_id: &anchor_lang::solana_program::pubkey::Pubkey,
                    __accounts: &mut &'info [anchor_lang::solana_program::account_info::AccountInfo<
                        'info,
                    >],
                    __ix_data: &[u8],
                    __bumps: &mut UpdateAmmConfigBumps,
                    __reallocs: &mut std::collections::BTreeSet<
                        anchor_lang::solana_program::pubkey::Pubkey,
                    >,
                ) -> anchor_lang::Result<Self> {
                    let owner: Signer = anchor_lang::Accounts::try_accounts(
                            __program_id,
                            __accounts,
                            __ix_data,
                            __bumps,
                            __reallocs,
                        )
                        .map_err(|e| e.with_account_name("owner"))?;
                    let amm_config: anchor_lang::accounts::account::Account<AmmConfig> = anchor_lang::Accounts::try_accounts(
                            __program_id,
                            __accounts,
                            __ix_data,
                            __bumps,
                            __reallocs,
                        )
                        .map_err(|e| e.with_account_name("amm_config"))?;
                    {
                        let actual = owner.key();
                        let expected = crate::admin::ID;
                        if actual != expected {
                            return Err(
                                anchor_lang::error::Error::from(ErrorCode::InvalidOwner)
                                    .with_account_name("owner")
                                    .with_pubkeys((actual, expected)),
                            );
                        }
                    }
                    if !AsRef::<AccountInfo>::as_ref(&amm_config).is_writable {
                        return Err(
                            anchor_lang::error::Error::from(
                                    anchor_lang::error::ErrorCode::ConstraintMut,
                                )
                                .with_account_name("amm_config"),
                        );
                    }
                    Ok(UpdateAmmConfig {
                        owner,
                        amm_config,
                    })
                }
            }
            #[automatically_derived]
            impl<'info> anchor_lang::ToAccountInfos<'info> for UpdateAmmConfig<'info>
            where
                'info: 'info,
            {
                fn to_account_infos(
                    &self,
                ) -> Vec<anchor_lang::solana_program::account_info::AccountInfo<'info>> {
                    let mut account_infos = ::alloc::vec::Vec::new();
                    account_infos.extend(self.owner.to_account_infos());
                    account_infos.extend(self.amm_config.to_account_infos());
                    account_infos
                }
            }
            #[automatically_derived]
            impl<'info> anchor_lang::ToAccountMetas for UpdateAmmConfig<'info> {
                fn to_account_metas(
                    &self,
                    is_signer: Option<bool>,
                ) -> Vec<anchor_lang::solana_program::instruction::AccountMeta> {
                    let mut account_metas = ::alloc::vec::Vec::new();
                    account_metas.extend(self.owner.to_account_metas(None));
                    account_metas.extend(self.amm_config.to_account_metas(None));
                    account_metas
                }
            }
            #[automatically_derived]
            impl<'info> anchor_lang::AccountsFinalize<'info, UpdateAmmConfigBumps>
            for UpdateAmmConfig<'info>
            where
                'info: 'info,
            {
                fn finalize(
                    &mut self,
                    program_id: &anchor_lang::solana_program::pubkey::Pubkey,
                    _remaining: &[anchor_lang::solana_program::account_info::AccountInfo<
                        'info,
                    >],
                    _ix_data: &[u8],
                    _bumps: &UpdateAmmConfigBumps,
                ) -> anchor_lang::Result<()> {
                    anchor_lang::AccountsFinalize::finalize(
                            &mut self.amm_config,
                            program_id,
                            _remaining,
                            _ix_data,
                            _bumps,
                        )
                        .map_err(|e| e.with_account_name("amm_config"))?;
                    Ok(())
                }
            }
            #[automatically_derived]
            impl<'info> anchor_lang::AccountsExit<'info> for UpdateAmmConfig<'info>
            where
                'info: 'info,
            {
                fn exit(
                    &self,
                    program_id: &anchor_lang::solana_program::pubkey::Pubkey,
                ) -> anchor_lang::Result<()> {
                    anchor_lang::AccountsExit::exit(&self.amm_config, program_id)
                        .map_err(|e| e.with_account_name("amm_config"))?;
                    Ok(())
                }
            }
            pub struct UpdateAmmConfigBumps {}
            #[automatically_derived]
            impl ::core::fmt::Debug for UpdateAmmConfigBumps {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::write_str(f, "UpdateAmmConfigBumps")
                }
            }
            #[automatically_derived]
            impl ::core::clone::Clone for UpdateAmmConfigBumps {
                #[inline]
                fn clone(&self) -> UpdateAmmConfigBumps {
                    UpdateAmmConfigBumps {}
                }
            }
            impl Default for UpdateAmmConfigBumps {
                fn default() -> Self {
                    UpdateAmmConfigBumps {}
                }
            }
            impl<'info> anchor_lang::Bumps for UpdateAmmConfig<'info>
            where
                'info: 'info,
            {
                type Bumps = UpdateAmmConfigBumps;
            }
            /// An internal, Anchor generated module. This is used (as an
            /// implementation detail), to generate a struct for a given
            /// `#[derive(Accounts)]` implementation, where each field is a Pubkey,
            /// instead of an `AccountInfo`. This is useful for clients that want
            /// to generate a list of accounts, without explicitly knowing the
            /// order all the fields should be in.
            ///
            /// To access the struct in this module, one should use the sibling
            /// `accounts` module (also generated), which re-exports this.
            pub(crate) mod __client_accounts_update_amm_config {
                use super::*;
                use anchor_lang::prelude::borsh;
                /// Generated client accounts for [`UpdateAmmConfig`].
                pub struct UpdateAmmConfig {
                    ///The amm config owner or admin
                    pub owner: Pubkey,
                    ///Amm config account to be changed
                    pub amm_config: Pubkey,
                }
                impl borsh::ser::BorshSerialize for UpdateAmmConfig
                where
                    Pubkey: borsh::ser::BorshSerialize,
                    Pubkey: borsh::ser::BorshSerialize,
                {
                    fn serialize<W: borsh::maybestd::io::Write>(
                        &self,
                        writer: &mut W,
                    ) -> ::core::result::Result<(), borsh::maybestd::io::Error> {
                        borsh::BorshSerialize::serialize(&self.owner, writer)?;
                        borsh::BorshSerialize::serialize(&self.amm_config, writer)?;
                        Ok(())
                    }
                }
                impl anchor_lang::idl::build::IdlBuild for UpdateAmmConfig {
                    fn create_type() -> Option<anchor_lang::idl::types::IdlTypeDef> {
                        Some(anchor_lang::idl::types::IdlTypeDef {
                            name: Self::get_full_path(),
                            docs: <[_]>::into_vec(
                                ::alloc::boxed::box_new([
                                    "Generated client accounts for [`UpdateAmmConfig`].".into(),
                                ]),
                            ),
                            serialization: anchor_lang::idl::types::IdlSerialization::default(),
                            repr: None,
                            generics: ::alloc::vec::Vec::new(),
                            ty: anchor_lang::idl::types::IdlTypeDefTy::Struct {
                                fields: Some(
                                    anchor_lang::idl::types::IdlDefinedFields::Named(
                                        <[_]>::into_vec(
                                            ::alloc::boxed::box_new([
                                                anchor_lang::idl::types::IdlField {
                                                    name: "owner".into(),
                                                    docs: <[_]>::into_vec(
                                                        ::alloc::boxed::box_new([
                                                            "The amm config owner or admin".into(),
                                                        ]),
                                                    ),
                                                    ty: anchor_lang::idl::types::IdlType::Pubkey,
                                                },
                                                anchor_lang::idl::types::IdlField {
                                                    name: "amm_config".into(),
                                                    docs: <[_]>::into_vec(
                                                        ::alloc::boxed::box_new([
                                                            "Amm config account to be changed".into(),
                                                        ]),
                                                    ),
                                                    ty: anchor_lang::idl::types::IdlType::Pubkey,
                                                },
                                            ]),
                                        ),
                                    ),
                                ),
                            },
                        })
                    }
                    fn insert_types(
                        types: &mut std::collections::BTreeMap<
                            String,
                            anchor_lang::idl::types::IdlTypeDef,
                        >,
                    ) {}
                    fn get_full_path() -> String {
                        ::alloc::__export::must_use({
                            ::alloc::fmt::format(
                                format_args!(
                                    "{0}::{1}",
                                    "raydium_cp_swap::instructions::admin::update_config::__client_accounts_update_amm_config",
                                    "UpdateAmmConfig",
                                ),
                            )
                        })
                    }
                }
                #[automatically_derived]
                impl anchor_lang::ToAccountMetas for UpdateAmmConfig {
                    fn to_account_metas(
                        &self,
                        is_signer: Option<bool>,
                    ) -> Vec<anchor_lang::solana_program::instruction::AccountMeta> {
                        let mut account_metas = ::alloc::vec::Vec::new();
                        account_metas
                            .push(
                                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                                    self.owner,
                                    true,
                                ),
                            );
                        account_metas
                            .push(
                                anchor_lang::solana_program::instruction::AccountMeta::new(
                                    self.amm_config,
                                    false,
                                ),
                            );
                        account_metas
                    }
                }
            }
            /// An internal, Anchor generated module. This is used (as an
            /// implementation detail), to generate a CPI struct for a given
            /// `#[derive(Accounts)]` implementation, where each field is an
            /// AccountInfo.
            ///
            /// To access the struct in this module, one should use the sibling
            /// [`cpi::accounts`] module (also generated), which re-exports this.
            pub(crate) mod __cpi_client_accounts_update_amm_config {
                use super::*;
                /// Generated CPI struct of the accounts for [`UpdateAmmConfig`].
                pub struct UpdateAmmConfig<'info> {
                    ///The amm config owner or admin
                    pub owner: anchor_lang::solana_program::account_info::AccountInfo<
                        'info,
                    >,
                    ///Amm config account to be changed
                    pub amm_config: anchor_lang::solana_program::account_info::AccountInfo<
                        'info,
                    >,
                }
                #[automatically_derived]
                impl<'info> anchor_lang::ToAccountMetas for UpdateAmmConfig<'info> {
                    fn to_account_metas(
                        &self,
                        is_signer: Option<bool>,
                    ) -> Vec<anchor_lang::solana_program::instruction::AccountMeta> {
                        let mut account_metas = ::alloc::vec::Vec::new();
                        account_metas
                            .push(
                                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                                    anchor_lang::Key::key(&self.owner),
                                    true,
                                ),
                            );
                        account_metas
                            .push(
                                anchor_lang::solana_program::instruction::AccountMeta::new(
                                    anchor_lang::Key::key(&self.amm_config),
                                    false,
                                ),
                            );
                        account_metas
                    }
                }
                #[automatically_derived]
                impl<'info> anchor_lang::ToAccountInfos<'info>
                for UpdateAmmConfig<'info> {
                    fn to_account_infos(
                        &self,
                    ) -> Vec<
                        anchor_lang::solana_program::account_info::AccountInfo<'info>,
                    > {
                        let mut account_infos = ::alloc::vec::Vec::new();
                        account_infos
                            .extend(
                                anchor_lang::ToAccountInfos::to_account_infos(&self.owner),
                            );
                        account_infos
                            .extend(
                                anchor_lang::ToAccountInfos::to_account_infos(
                                    &self.amm_config,
                                ),
                            );
                        account_infos
                    }
                }
            }
            impl<'info> UpdateAmmConfig<'info> {
                pub fn __anchor_private_gen_idl_accounts(
                    accounts: &mut std::collections::BTreeMap<
                        String,
                        anchor_lang::idl::types::IdlAccount,
                    >,
                    types: &mut std::collections::BTreeMap<
                        String,
                        anchor_lang::idl::types::IdlTypeDef,
                    >,
                ) -> Vec<anchor_lang::idl::types::IdlInstructionAccountItem> {
                    if let Some(ty) = <AmmConfig>::create_type() {
                        let account = anchor_lang::idl::types::IdlAccount {
                            name: ty.name.clone(),
                            discriminator: AmmConfig::DISCRIMINATOR.into(),
                        };
                        accounts.insert(account.name.clone(), account);
                        types.insert(ty.name.clone(), ty);
                        <AmmConfig>::insert_types(types);
                    }
                    <[_]>::into_vec(
                        ::alloc::boxed::box_new([
                            anchor_lang::idl::types::IdlInstructionAccountItem::Single(anchor_lang::idl::types::IdlInstructionAccount {
                                name: "owner".into(),
                                docs: <[_]>::into_vec(
                                    ::alloc::boxed::box_new([
                                        "The amm config owner or admin".into(),
                                    ]),
                                ),
                                writable: false,
                                signer: true,
                                optional: false,
                                address: None,
                                pda: None,
                                relations: ::alloc::vec::Vec::new(),
                            }),
                            anchor_lang::idl::types::IdlInstructionAccountItem::Single(anchor_lang::idl::types::IdlInstructionAccount {
                                name: "amm_config".into(),
                                docs: <[_]>::into_vec(
                                    ::alloc::boxed::box_new([
                                        "Amm config account to be changed".into(),
                                    ]),
                                ),
                                writable: true,
                                signer: false,
                                optional: false,
                                address: None,
                                pda: None,
                                relations: ::alloc::vec::Vec::new(),
                            }),
                        ]),
                    )
                }
                pub fn __anchor_private_gen_light_metadata() -> Option<
                    anchor_lang::idl::types::IdlLightInstructionMeta,
                > {
                    None
                }
            }
            pub fn update_amm_config(
                ctx: Context<UpdateAmmConfig>,
                param: u8,
                value: u64,
            ) -> Result<()> {
                let amm_config = &mut ctx.accounts.amm_config;
                let match_param = Some(param);
                match match_param {
                    Some(0) => update_trade_fee_rate(amm_config, value),
                    Some(1) => update_protocol_fee_rate(amm_config, value),
                    Some(2) => update_fund_fee_rate(amm_config, value),
                    Some(3) => {
                        let new_procotol_owner = *ctx
                            .remaining_accounts
                            .iter()
                            .next()
                            .unwrap()
                            .key;
                        set_new_protocol_owner(amm_config, new_procotol_owner)?;
                    }
                    Some(4) => {
                        let new_fund_owner = *ctx
                            .remaining_accounts
                            .iter()
                            .next()
                            .unwrap()
                            .key;
                        set_new_fund_owner(amm_config, new_fund_owner)?;
                    }
                    Some(5) => amm_config.create_pool_fee = value,
                    Some(6) => {
                        amm_config.disable_create_pool = if value == 0 {
                            false
                        } else {
                            true
                        };
                    }
                    _ => {
                        return Err(
                            anchor_lang::error::Error::from(anchor_lang::error::AnchorError {
                                error_name: ErrorCode::InvalidInput.name(),
                                error_code_number: ErrorCode::InvalidInput.into(),
                                error_msg: ErrorCode::InvalidInput.to_string(),
                                error_origin: Some(
                                    anchor_lang::error::ErrorOrigin::Source(anchor_lang::error::Source {
                                        filename: "programs/cp-swap/src/instructions/admin/update_config.rs",
                                        line: 34u32,
                                    }),
                                ),
                                compared_values: None,
                            }),
                        );
                    }
                }
                Ok(())
            }
            fn update_protocol_fee_rate(
                amm_config: &mut Account<AmmConfig>,
                protocol_fee_rate: u64,
            ) {
                {
                    match protocol_fee_rate <= FEE_RATE_DENOMINATOR_VALUE {
                        true => {}
                        _ => {
                            ::core::panicking::panic(
                                "assertion failed: protocol_fee_rate <= FEE_RATE_DENOMINATOR_VALUE",
                            )
                        }
                    }
                };
                {
                    match protocol_fee_rate + amm_config.fund_fee_rate
                        <= FEE_RATE_DENOMINATOR_VALUE
                    {
                        true => {}
                        _ => {
                            ::core::panicking::panic(
                                "assertion failed: protocol_fee_rate + amm_config.fund_fee_rate <= FEE_RATE_DENOMINATOR_VALUE",
                            )
                        }
                    }
                };
                amm_config.protocol_fee_rate = protocol_fee_rate;
            }
            fn update_trade_fee_rate(
                amm_config: &mut Account<AmmConfig>,
                trade_fee_rate: u64,
            ) {
                {
                    match trade_fee_rate < FEE_RATE_DENOMINATOR_VALUE {
                        true => {}
                        _ => {
                            ::core::panicking::panic(
                                "assertion failed: trade_fee_rate < FEE_RATE_DENOMINATOR_VALUE",
                            )
                        }
                    }
                };
                amm_config.trade_fee_rate = trade_fee_rate;
            }
            fn update_fund_fee_rate(
                amm_config: &mut Account<AmmConfig>,
                fund_fee_rate: u64,
            ) {
                {
                    match fund_fee_rate <= FEE_RATE_DENOMINATOR_VALUE {
                        true => {}
                        _ => {
                            ::core::panicking::panic(
                                "assertion failed: fund_fee_rate <= FEE_RATE_DENOMINATOR_VALUE",
                            )
                        }
                    }
                };
                {
                    match fund_fee_rate + amm_config.protocol_fee_rate
                        <= FEE_RATE_DENOMINATOR_VALUE
                    {
                        true => {}
                        _ => {
                            ::core::panicking::panic(
                                "assertion failed: fund_fee_rate + amm_config.protocol_fee_rate <= FEE_RATE_DENOMINATOR_VALUE",
                            )
                        }
                    }
                };
                amm_config.fund_fee_rate = fund_fee_rate;
            }
            fn set_new_protocol_owner(
                amm_config: &mut Account<AmmConfig>,
                new_owner: Pubkey,
            ) -> Result<()> {
                if new_owner == Pubkey::default() {
                    return Err(
                        anchor_lang::error::Error::from(anchor_lang::error::AnchorError {
                                error_name: anchor_lang::error::ErrorCode::RequireKeysNeqViolated
                                    .name(),
                                error_code_number: anchor_lang::error::ErrorCode::RequireKeysNeqViolated
                                    .into(),
                                error_msg: anchor_lang::error::ErrorCode::RequireKeysNeqViolated
                                    .to_string(),
                                error_origin: Some(
                                    anchor_lang::error::ErrorOrigin::Source(anchor_lang::error::Source {
                                        filename: "programs/cp-swap/src/instructions/admin/update_config.rs",
                                        line: 58u32,
                                    }),
                                ),
                                compared_values: None,
                            })
                            .with_pubkeys((new_owner, Pubkey::default())),
                    );
                }
                amm_config.protocol_owner = new_owner;
                Ok(())
            }
            fn set_new_fund_owner(
                amm_config: &mut Account<AmmConfig>,
                new_fund_owner: Pubkey,
            ) -> Result<()> {
                if new_fund_owner == Pubkey::default() {
                    return Err(
                        anchor_lang::error::Error::from(anchor_lang::error::AnchorError {
                                error_name: anchor_lang::error::ErrorCode::RequireKeysNeqViolated
                                    .name(),
                                error_code_number: anchor_lang::error::ErrorCode::RequireKeysNeqViolated
                                    .into(),
                                error_msg: anchor_lang::error::ErrorCode::RequireKeysNeqViolated
                                    .to_string(),
                                error_origin: Some(
                                    anchor_lang::error::ErrorOrigin::Source(anchor_lang::error::Source {
                                        filename: "programs/cp-swap/src/instructions/admin/update_config.rs",
                                        line: 70u32,
                                    }),
                                ),
                                compared_values: None,
                            })
                            .with_pubkeys((new_fund_owner, Pubkey::default())),
                    );
                }
                amm_config.fund_owner = new_fund_owner;
                Ok(())
            }
        }
        pub use update_config::*;
        pub mod update_pool_status {
            use crate::states::*;
            use anchor_lang::prelude::*;
            pub struct UpdatePoolStatus<'info> {
                #[account(address = crate::admin::ID)]
                pub authority: Signer<'info>,
                #[account(mut)]
                pub pool_state: Account<'info, PoolState>,
            }
            #[automatically_derived]
            impl<'info> anchor_lang::Accounts<'info, UpdatePoolStatusBumps>
            for UpdatePoolStatus<'info>
            where
                'info: 'info,
            {
                #[inline(never)]
                fn try_accounts(
                    __program_id: &anchor_lang::solana_program::pubkey::Pubkey,
                    __accounts: &mut &'info [anchor_lang::solana_program::account_info::AccountInfo<
                        'info,
                    >],
                    __ix_data: &[u8],
                    __bumps: &mut UpdatePoolStatusBumps,
                    __reallocs: &mut std::collections::BTreeSet<
                        anchor_lang::solana_program::pubkey::Pubkey,
                    >,
                ) -> anchor_lang::Result<Self> {
                    let authority: Signer = anchor_lang::Accounts::try_accounts(
                            __program_id,
                            __accounts,
                            __ix_data,
                            __bumps,
                            __reallocs,
                        )
                        .map_err(|e| e.with_account_name("authority"))?;
                    let pool_state: anchor_lang::accounts::account::Account<PoolState> = anchor_lang::Accounts::try_accounts(
                            __program_id,
                            __accounts,
                            __ix_data,
                            __bumps,
                            __reallocs,
                        )
                        .map_err(|e| e.with_account_name("pool_state"))?;
                    {
                        let actual = authority.key();
                        let expected = crate::admin::ID;
                        if actual != expected {
                            return Err(
                                anchor_lang::error::Error::from(
                                        anchor_lang::error::ErrorCode::ConstraintAddress,
                                    )
                                    .with_account_name("authority")
                                    .with_pubkeys((actual, expected)),
                            );
                        }
                    }
                    if !AsRef::<AccountInfo>::as_ref(&pool_state).is_writable {
                        return Err(
                            anchor_lang::error::Error::from(
                                    anchor_lang::error::ErrorCode::ConstraintMut,
                                )
                                .with_account_name("pool_state"),
                        );
                    }
                    Ok(UpdatePoolStatus {
                        authority,
                        pool_state,
                    })
                }
            }
            #[automatically_derived]
            impl<'info> anchor_lang::ToAccountInfos<'info> for UpdatePoolStatus<'info>
            where
                'info: 'info,
            {
                fn to_account_infos(
                    &self,
                ) -> Vec<anchor_lang::solana_program::account_info::AccountInfo<'info>> {
                    let mut account_infos = ::alloc::vec::Vec::new();
                    account_infos.extend(self.authority.to_account_infos());
                    account_infos.extend(self.pool_state.to_account_infos());
                    account_infos
                }
            }
            #[automatically_derived]
            impl<'info> anchor_lang::ToAccountMetas for UpdatePoolStatus<'info> {
                fn to_account_metas(
                    &self,
                    is_signer: Option<bool>,
                ) -> Vec<anchor_lang::solana_program::instruction::AccountMeta> {
                    let mut account_metas = ::alloc::vec::Vec::new();
                    account_metas.extend(self.authority.to_account_metas(None));
                    account_metas.extend(self.pool_state.to_account_metas(None));
                    account_metas
                }
            }
            #[automatically_derived]
            impl<'info> anchor_lang::AccountsFinalize<'info, UpdatePoolStatusBumps>
            for UpdatePoolStatus<'info>
            where
                'info: 'info,
            {
                fn finalize(
                    &mut self,
                    program_id: &anchor_lang::solana_program::pubkey::Pubkey,
                    _remaining: &[anchor_lang::solana_program::account_info::AccountInfo<
                        'info,
                    >],
                    _ix_data: &[u8],
                    _bumps: &UpdatePoolStatusBumps,
                ) -> anchor_lang::Result<()> {
                    anchor_lang::AccountsFinalize::finalize(
                            &mut self.pool_state,
                            program_id,
                            _remaining,
                            _ix_data,
                            _bumps,
                        )
                        .map_err(|e| e.with_account_name("pool_state"))?;
                    Ok(())
                }
            }
            #[automatically_derived]
            impl<'info> anchor_lang::AccountsExit<'info> for UpdatePoolStatus<'info>
            where
                'info: 'info,
            {
                fn exit(
                    &self,
                    program_id: &anchor_lang::solana_program::pubkey::Pubkey,
                ) -> anchor_lang::Result<()> {
                    anchor_lang::AccountsExit::exit(&self.pool_state, program_id)
                        .map_err(|e| e.with_account_name("pool_state"))?;
                    Ok(())
                }
            }
            pub struct UpdatePoolStatusBumps {}
            #[automatically_derived]
            impl ::core::fmt::Debug for UpdatePoolStatusBumps {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::write_str(f, "UpdatePoolStatusBumps")
                }
            }
            #[automatically_derived]
            impl ::core::clone::Clone for UpdatePoolStatusBumps {
                #[inline]
                fn clone(&self) -> UpdatePoolStatusBumps {
                    UpdatePoolStatusBumps {}
                }
            }
            impl Default for UpdatePoolStatusBumps {
                fn default() -> Self {
                    UpdatePoolStatusBumps {}
                }
            }
            impl<'info> anchor_lang::Bumps for UpdatePoolStatus<'info>
            where
                'info: 'info,
            {
                type Bumps = UpdatePoolStatusBumps;
            }
            /// An internal, Anchor generated module. This is used (as an
            /// implementation detail), to generate a struct for a given
            /// `#[derive(Accounts)]` implementation, where each field is a Pubkey,
            /// instead of an `AccountInfo`. This is useful for clients that want
            /// to generate a list of accounts, without explicitly knowing the
            /// order all the fields should be in.
            ///
            /// To access the struct in this module, one should use the sibling
            /// `accounts` module (also generated), which re-exports this.
            pub(crate) mod __client_accounts_update_pool_status {
                use super::*;
                use anchor_lang::prelude::borsh;
                /// Generated client accounts for [`UpdatePoolStatus`].
                pub struct UpdatePoolStatus {
                    pub authority: Pubkey,
                    pub pool_state: Pubkey,
                }
                impl borsh::ser::BorshSerialize for UpdatePoolStatus
                where
                    Pubkey: borsh::ser::BorshSerialize,
                    Pubkey: borsh::ser::BorshSerialize,
                {
                    fn serialize<W: borsh::maybestd::io::Write>(
                        &self,
                        writer: &mut W,
                    ) -> ::core::result::Result<(), borsh::maybestd::io::Error> {
                        borsh::BorshSerialize::serialize(&self.authority, writer)?;
                        borsh::BorshSerialize::serialize(&self.pool_state, writer)?;
                        Ok(())
                    }
                }
                impl anchor_lang::idl::build::IdlBuild for UpdatePoolStatus {
                    fn create_type() -> Option<anchor_lang::idl::types::IdlTypeDef> {
                        Some(anchor_lang::idl::types::IdlTypeDef {
                            name: Self::get_full_path(),
                            docs: <[_]>::into_vec(
                                ::alloc::boxed::box_new([
                                    "Generated client accounts for [`UpdatePoolStatus`].".into(),
                                ]),
                            ),
                            serialization: anchor_lang::idl::types::IdlSerialization::default(),
                            repr: None,
                            generics: ::alloc::vec::Vec::new(),
                            ty: anchor_lang::idl::types::IdlTypeDefTy::Struct {
                                fields: Some(
                                    anchor_lang::idl::types::IdlDefinedFields::Named(
                                        <[_]>::into_vec(
                                            ::alloc::boxed::box_new([
                                                anchor_lang::idl::types::IdlField {
                                                    name: "authority".into(),
                                                    docs: ::alloc::vec::Vec::new(),
                                                    ty: anchor_lang::idl::types::IdlType::Pubkey,
                                                },
                                                anchor_lang::idl::types::IdlField {
                                                    name: "pool_state".into(),
                                                    docs: ::alloc::vec::Vec::new(),
                                                    ty: anchor_lang::idl::types::IdlType::Pubkey,
                                                },
                                            ]),
                                        ),
                                    ),
                                ),
                            },
                        })
                    }
                    fn insert_types(
                        types: &mut std::collections::BTreeMap<
                            String,
                            anchor_lang::idl::types::IdlTypeDef,
                        >,
                    ) {}
                    fn get_full_path() -> String {
                        ::alloc::__export::must_use({
                            ::alloc::fmt::format(
                                format_args!(
                                    "{0}::{1}",
                                    "raydium_cp_swap::instructions::admin::update_pool_status::__client_accounts_update_pool_status",
                                    "UpdatePoolStatus",
                                ),
                            )
                        })
                    }
                }
                #[automatically_derived]
                impl anchor_lang::ToAccountMetas for UpdatePoolStatus {
                    fn to_account_metas(
                        &self,
                        is_signer: Option<bool>,
                    ) -> Vec<anchor_lang::solana_program::instruction::AccountMeta> {
                        let mut account_metas = ::alloc::vec::Vec::new();
                        account_metas
                            .push(
                                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                                    self.authority,
                                    true,
                                ),
                            );
                        account_metas
                            .push(
                                anchor_lang::solana_program::instruction::AccountMeta::new(
                                    self.pool_state,
                                    false,
                                ),
                            );
                        account_metas
                    }
                }
            }
            /// An internal, Anchor generated module. This is used (as an
            /// implementation detail), to generate a CPI struct for a given
            /// `#[derive(Accounts)]` implementation, where each field is an
            /// AccountInfo.
            ///
            /// To access the struct in this module, one should use the sibling
            /// [`cpi::accounts`] module (also generated), which re-exports this.
            pub(crate) mod __cpi_client_accounts_update_pool_status {
                use super::*;
                /// Generated CPI struct of the accounts for [`UpdatePoolStatus`].
                pub struct UpdatePoolStatus<'info> {
                    pub authority: anchor_lang::solana_program::account_info::AccountInfo<
                        'info,
                    >,
                    pub pool_state: anchor_lang::solana_program::account_info::AccountInfo<
                        'info,
                    >,
                }
                #[automatically_derived]
                impl<'info> anchor_lang::ToAccountMetas for UpdatePoolStatus<'info> {
                    fn to_account_metas(
                        &self,
                        is_signer: Option<bool>,
                    ) -> Vec<anchor_lang::solana_program::instruction::AccountMeta> {
                        let mut account_metas = ::alloc::vec::Vec::new();
                        account_metas
                            .push(
                                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                                    anchor_lang::Key::key(&self.authority),
                                    true,
                                ),
                            );
                        account_metas
                            .push(
                                anchor_lang::solana_program::instruction::AccountMeta::new(
                                    anchor_lang::Key::key(&self.pool_state),
                                    false,
                                ),
                            );
                        account_metas
                    }
                }
                #[automatically_derived]
                impl<'info> anchor_lang::ToAccountInfos<'info>
                for UpdatePoolStatus<'info> {
                    fn to_account_infos(
                        &self,
                    ) -> Vec<
                        anchor_lang::solana_program::account_info::AccountInfo<'info>,
                    > {
                        let mut account_infos = ::alloc::vec::Vec::new();
                        account_infos
                            .extend(
                                anchor_lang::ToAccountInfos::to_account_infos(
                                    &self.authority,
                                ),
                            );
                        account_infos
                            .extend(
                                anchor_lang::ToAccountInfos::to_account_infos(
                                    &self.pool_state,
                                ),
                            );
                        account_infos
                    }
                }
            }
            impl<'info> UpdatePoolStatus<'info> {
                pub fn __anchor_private_gen_idl_accounts(
                    accounts: &mut std::collections::BTreeMap<
                        String,
                        anchor_lang::idl::types::IdlAccount,
                    >,
                    types: &mut std::collections::BTreeMap<
                        String,
                        anchor_lang::idl::types::IdlTypeDef,
                    >,
                ) -> Vec<anchor_lang::idl::types::IdlInstructionAccountItem> {
                    if let Some(ty) = <PoolState>::create_type() {
                        let account = anchor_lang::idl::types::IdlAccount {
                            name: ty.name.clone(),
                            discriminator: PoolState::DISCRIMINATOR.into(),
                        };
                        accounts.insert(account.name.clone(), account);
                        types.insert(ty.name.clone(), ty);
                        <PoolState>::insert_types(types);
                    }
                    <[_]>::into_vec(
                        ::alloc::boxed::box_new([
                            anchor_lang::idl::types::IdlInstructionAccountItem::Single(anchor_lang::idl::types::IdlInstructionAccount {
                                name: "authority".into(),
                                docs: ::alloc::vec::Vec::new(),
                                writable: false,
                                signer: true,
                                optional: false,
                                address: None,
                                pda: None,
                                relations: ::alloc::vec::Vec::new(),
                            }),
                            anchor_lang::idl::types::IdlInstructionAccountItem::Single(anchor_lang::idl::types::IdlInstructionAccount {
                                name: "pool_state".into(),
                                docs: ::alloc::vec::Vec::new(),
                                writable: true,
                                signer: false,
                                optional: false,
                                address: None,
                                pda: None,
                                relations: ::alloc::vec::Vec::new(),
                            }),
                        ]),
                    )
                }
                pub fn __anchor_private_gen_light_metadata() -> Option<
                    anchor_lang::idl::types::IdlLightInstructionMeta,
                > {
                    Some(anchor_lang::idl::types::IdlLightInstructionMeta {
                        ctokens: None,
                        cpdas: Some(
                            <[_]>::into_vec(
                                ::alloc::boxed::box_new([
                                    anchor_lang::idl::types::IdlLightCpdaUsage {
                                        account: "pool_state".to_string(),
                                        ty: "PoolState".to_string(),
                                    },
                                ]),
                            ),
                        ),
                    })
                }
            }
            pub fn update_pool_status(
                ctx: Context<UpdatePoolStatus>,
                status: u8,
            ) -> Result<()> {
                if 255 < status {
                    return Err(
                        anchor_lang::error::Error::from(anchor_lang::error::AnchorError {
                                error_name: anchor_lang::error::ErrorCode::RequireGteViolated
                                    .name(),
                                error_code_number: anchor_lang::error::ErrorCode::RequireGteViolated
                                    .into(),
                                error_msg: anchor_lang::error::ErrorCode::RequireGteViolated
                                    .to_string(),
                                error_origin: Some(
                                    anchor_lang::error::ErrorOrigin::Source(anchor_lang::error::Source {
                                        filename: "programs/cp-swap/src/instructions/admin/update_pool_status.rs",
                                        line: 16u32,
                                    }),
                                ),
                                compared_values: None,
                            })
                            .with_values((255, status)),
                    );
                }
                let pool_state = &mut ctx.accounts.pool_state;
                pool_state.set_status(status);
                pool_state.recent_epoch = Clock::get()?.epoch;
                Ok(())
            }
        }
        pub use update_pool_status::*;
        pub mod collect_protocol_fee {
            use crate::error::ErrorCode;
            use crate::states::*;
            use crate::utils::ctoken::get_bumps;
            use crate::utils::*;
            use anchor_lang::prelude::*;
            use anchor_spl::token::Token;
            use anchor_spl::token_interface::Mint;
            use anchor_spl::token_interface::Token2022;
            use anchor_spl::token_interface::TokenAccount;
            pub struct CollectProtocolFee<'info> {
                /// Only admin or owner can collect fee now
                #[account(
                    constraint = (
                        owner.key(

                        )= = amm_config.protocol_owner||owner.key()= = crate::admin::ID
                    )@ErrorCode::InvalidOwner
                )]
                pub owner: Signer<'info>,
                /// CHECK: pool vault and lp mint authority
                #[account(seeds = [crate::AUTH_SEED.as_bytes()], bump)]
                pub authority: UncheckedAccount<'info>,
                /// Pool state stores accumulated protocol fee amount
                #[account(mut)]
                pub pool_state: Account<'info, PoolState>,
                /// Amm config account stores owner
                #[account(address = pool_state.amm_config)]
                pub amm_config: Account<'info, AmmConfig>,
                /// The address that holds pool tokens for token_0
                #[account(
                    mut,
                    constraint = token_0_vault.key()= = pool_state.token_0_vault
                )]
                pub token_0_vault: Box<InterfaceAccount<'info, TokenAccount>>,
                /// The address that holds pool tokens for token_1
                #[account(
                    mut,
                    constraint = token_1_vault.key()= = pool_state.token_1_vault
                )]
                pub token_1_vault: Box<InterfaceAccount<'info, TokenAccount>>,
                /// The mint of token_0 vault
                #[account(
                    address = token_0_vault.mint,
                    mint::token_program = pool_state.token_0_program,
                )]
                pub vault_0_mint: Box<InterfaceAccount<'info, Mint>>,
                /// The mint of token_1 vault
                #[account(
                    address = token_1_vault.mint,
                    mint::token_program = pool_state.token_1_program,
                )]
                pub vault_1_mint: Box<InterfaceAccount<'info, Mint>>,
                /// The address that receives the collected token_0 protocol fees
                #[account(mut)]
                pub recipient_token_0_account: Box<
                    InterfaceAccount<'info, TokenAccount>,
                >,
                /// The address that receives the collected token_1 protocol fees
                #[account(mut)]
                pub recipient_token_1_account: Box<
                    InterfaceAccount<'info, TokenAccount>,
                >,
                /// The SPL program to perform token transfers
                pub token_program: Program<'info, Token>,
                /// The SPL program 2022 to perform token transfers
                pub token_program_2022: Program<'info, Token2022>,
                /// CHECK: checked by protocol.
                pub compressed_token_program_cpi_authority: AccountInfo<'info>,
                /// CHECK: checked by protocol.
                pub compressed_token_program: AccountInfo<'info>,
                /// CHECK: checked by protocol.
                #[account(mut)]
                pub compressed_token_0_pool_pda: AccountInfo<'info>,
                /// CHECK: checked by protocol.
                #[account(mut)]
                pub compressed_token_1_pool_pda: AccountInfo<'info>,
            }
            #[automatically_derived]
            impl<'info> anchor_lang::Accounts<'info, CollectProtocolFeeBumps>
            for CollectProtocolFee<'info>
            where
                'info: 'info,
            {
                #[inline(never)]
                fn try_accounts(
                    __program_id: &anchor_lang::solana_program::pubkey::Pubkey,
                    __accounts: &mut &'info [anchor_lang::solana_program::account_info::AccountInfo<
                        'info,
                    >],
                    __ix_data: &[u8],
                    __bumps: &mut CollectProtocolFeeBumps,
                    __reallocs: &mut std::collections::BTreeSet<
                        anchor_lang::solana_program::pubkey::Pubkey,
                    >,
                ) -> anchor_lang::Result<Self> {
                    let owner: Signer = anchor_lang::Accounts::try_accounts(
                            __program_id,
                            __accounts,
                            __ix_data,
                            __bumps,
                            __reallocs,
                        )
                        .map_err(|e| e.with_account_name("owner"))?;
                    let authority: UncheckedAccount = anchor_lang::Accounts::try_accounts(
                            __program_id,
                            __accounts,
                            __ix_data,
                            __bumps,
                            __reallocs,
                        )
                        .map_err(|e| e.with_account_name("authority"))?;
                    let pool_state: anchor_lang::accounts::account::Account<PoolState> = anchor_lang::Accounts::try_accounts(
                            __program_id,
                            __accounts,
                            __ix_data,
                            __bumps,
                            __reallocs,
                        )
                        .map_err(|e| e.with_account_name("pool_state"))?;
                    let amm_config: anchor_lang::accounts::account::Account<AmmConfig> = anchor_lang::Accounts::try_accounts(
                            __program_id,
                            __accounts,
                            __ix_data,
                            __bumps,
                            __reallocs,
                        )
                        .map_err(|e| e.with_account_name("amm_config"))?;
                    let token_0_vault: Box<
                        anchor_lang::accounts::interface_account::InterfaceAccount<
                            TokenAccount,
                        >,
                    > = anchor_lang::Accounts::try_accounts(
                            __program_id,
                            __accounts,
                            __ix_data,
                            __bumps,
                            __reallocs,
                        )
                        .map_err(|e| e.with_account_name("token_0_vault"))?;
                    let token_1_vault: Box<
                        anchor_lang::accounts::interface_account::InterfaceAccount<
                            TokenAccount,
                        >,
                    > = anchor_lang::Accounts::try_accounts(
                            __program_id,
                            __accounts,
                            __ix_data,
                            __bumps,
                            __reallocs,
                        )
                        .map_err(|e| e.with_account_name("token_1_vault"))?;
                    let vault_0_mint: Box<
                        anchor_lang::accounts::interface_account::InterfaceAccount<Mint>,
                    > = Box::new({
                        if __accounts.is_empty() {
                            return Err(
                                anchor_lang::error::ErrorCode::AccountNotEnoughKeys.into(),
                            );
                        }
                        let __acc = &__accounts[0];
                        *__accounts = &__accounts[1..];
                        anchor_lang::accounts::interface_account::InterfaceAccount::try_from_with_token_program(
                                __acc,
                                &pool_state.token_0_program,
                            )
                            .map_err(|e| e.with_account_name("vault_0_mint"))?
                    });
                    let vault_1_mint: Box<
                        anchor_lang::accounts::interface_account::InterfaceAccount<Mint>,
                    > = Box::new({
                        if __accounts.is_empty() {
                            return Err(
                                anchor_lang::error::ErrorCode::AccountNotEnoughKeys.into(),
                            );
                        }
                        let __acc = &__accounts[0];
                        *__accounts = &__accounts[1..];
                        anchor_lang::accounts::interface_account::InterfaceAccount::try_from_with_token_program(
                                __acc,
                                &pool_state.token_1_program,
                            )
                            .map_err(|e| e.with_account_name("vault_1_mint"))?
                    });
                    let recipient_token_0_account: Box<
                        anchor_lang::accounts::interface_account::InterfaceAccount<
                            TokenAccount,
                        >,
                    > = anchor_lang::Accounts::try_accounts(
                            __program_id,
                            __accounts,
                            __ix_data,
                            __bumps,
                            __reallocs,
                        )
                        .map_err(|e| e.with_account_name("recipient_token_0_account"))?;
                    let recipient_token_1_account: Box<
                        anchor_lang::accounts::interface_account::InterfaceAccount<
                            TokenAccount,
                        >,
                    > = anchor_lang::Accounts::try_accounts(
                            __program_id,
                            __accounts,
                            __ix_data,
                            __bumps,
                            __reallocs,
                        )
                        .map_err(|e| e.with_account_name("recipient_token_1_account"))?;
                    let token_program: anchor_lang::accounts::program::Program<Token> = anchor_lang::Accounts::try_accounts(
                            __program_id,
                            __accounts,
                            __ix_data,
                            __bumps,
                            __reallocs,
                        )
                        .map_err(|e| e.with_account_name("token_program"))?;
                    let token_program_2022: anchor_lang::accounts::program::Program<
                        Token2022,
                    > = anchor_lang::Accounts::try_accounts(
                            __program_id,
                            __accounts,
                            __ix_data,
                            __bumps,
                            __reallocs,
                        )
                        .map_err(|e| e.with_account_name("token_program_2022"))?;
                    let compressed_token_program_cpi_authority: AccountInfo = anchor_lang::Accounts::try_accounts(
                            __program_id,
                            __accounts,
                            __ix_data,
                            __bumps,
                            __reallocs,
                        )
                        .map_err(|e| {
                            e.with_account_name("compressed_token_program_cpi_authority")
                        })?;
                    let compressed_token_program: AccountInfo = anchor_lang::Accounts::try_accounts(
                            __program_id,
                            __accounts,
                            __ix_data,
                            __bumps,
                            __reallocs,
                        )
                        .map_err(|e| e.with_account_name("compressed_token_program"))?;
                    let compressed_token_0_pool_pda: AccountInfo = anchor_lang::Accounts::try_accounts(
                            __program_id,
                            __accounts,
                            __ix_data,
                            __bumps,
                            __reallocs,
                        )
                        .map_err(|e| {
                            e.with_account_name("compressed_token_0_pool_pda")
                        })?;
                    let compressed_token_1_pool_pda: AccountInfo = anchor_lang::Accounts::try_accounts(
                            __program_id,
                            __accounts,
                            __ix_data,
                            __bumps,
                            __reallocs,
                        )
                        .map_err(|e| {
                            e.with_account_name("compressed_token_1_pool_pda")
                        })?;
                    if !((owner.key() == amm_config.protocol_owner
                        || owner.key() == crate::admin::ID))
                    {
                        return Err(
                            anchor_lang::error::Error::from(ErrorCode::InvalidOwner)
                                .with_account_name("owner"),
                        );
                    }
                    let (__pda_address, __bump) = Pubkey::find_program_address(
                        &[crate::AUTH_SEED.as_bytes()],
                        &__program_id,
                    );
                    __bumps.authority = __bump;
                    if authority.key() != __pda_address {
                        return Err(
                            anchor_lang::error::Error::from(
                                    anchor_lang::error::ErrorCode::ConstraintSeeds,
                                )
                                .with_account_name("authority")
                                .with_pubkeys((authority.key(), __pda_address)),
                        );
                    }
                    if !AsRef::<AccountInfo>::as_ref(&pool_state).is_writable {
                        return Err(
                            anchor_lang::error::Error::from(
                                    anchor_lang::error::ErrorCode::ConstraintMut,
                                )
                                .with_account_name("pool_state"),
                        );
                    }
                    {
                        let actual = amm_config.key();
                        let expected = pool_state.amm_config;
                        if actual != expected {
                            return Err(
                                anchor_lang::error::Error::from(
                                        anchor_lang::error::ErrorCode::ConstraintAddress,
                                    )
                                    .with_account_name("amm_config")
                                    .with_pubkeys((actual, expected)),
                            );
                        }
                    }
                    if !AsRef::<AccountInfo>::as_ref(token_0_vault.as_ref()).is_writable
                    {
                        return Err(
                            anchor_lang::error::Error::from(
                                    anchor_lang::error::ErrorCode::ConstraintMut,
                                )
                                .with_account_name("token_0_vault"),
                        );
                    }
                    if !(token_0_vault.key() == pool_state.token_0_vault) {
                        return Err(
                            anchor_lang::error::Error::from(
                                    anchor_lang::error::ErrorCode::ConstraintRaw,
                                )
                                .with_account_name("token_0_vault"),
                        );
                    }
                    if !AsRef::<AccountInfo>::as_ref(token_1_vault.as_ref()).is_writable
                    {
                        return Err(
                            anchor_lang::error::Error::from(
                                    anchor_lang::error::ErrorCode::ConstraintMut,
                                )
                                .with_account_name("token_1_vault"),
                        );
                    }
                    if !(token_1_vault.key() == pool_state.token_1_vault) {
                        return Err(
                            anchor_lang::error::Error::from(
                                    anchor_lang::error::ErrorCode::ConstraintRaw,
                                )
                                .with_account_name("token_1_vault"),
                        );
                    }
                    {
                        let actual = vault_0_mint.key();
                        let expected = token_0_vault.mint;
                        if actual != expected {
                            return Err(
                                anchor_lang::error::Error::from(
                                        anchor_lang::error::ErrorCode::ConstraintAddress,
                                    )
                                    .with_account_name("vault_0_mint")
                                    .with_pubkeys((actual, expected)),
                            );
                        }
                    }
                    {
                        let __is_ctoken = pool_state.token_0_program
                            == anchor_lang::CTOKEN_ID;
                        if __is_ctoken {
                            if AsRef::<AccountInfo>::as_ref(vault_0_mint.as_ref()).owner
                                != &anchor_lang::solana_program::system_program::ID
                            {
                                return Err(
                                    anchor_lang::error::ErrorCode::ConstraintMintTokenProgram
                                        .into(),
                                );
                            }
                        } else {
                            if AsRef::<AccountInfo>::as_ref(vault_0_mint.as_ref()).owner
                                != &pool_state.token_0_program
                            {
                                return Err(
                                    anchor_lang::error::ErrorCode::ConstraintMintTokenProgram
                                        .into(),
                                );
                            }
                        }
                        if !__is_ctoken {}
                    }
                    {
                        let actual = vault_1_mint.key();
                        let expected = token_1_vault.mint;
                        if actual != expected {
                            return Err(
                                anchor_lang::error::Error::from(
                                        anchor_lang::error::ErrorCode::ConstraintAddress,
                                    )
                                    .with_account_name("vault_1_mint")
                                    .with_pubkeys((actual, expected)),
                            );
                        }
                    }
                    {
                        let __is_ctoken = pool_state.token_1_program
                            == anchor_lang::CTOKEN_ID;
                        if __is_ctoken {
                            if AsRef::<AccountInfo>::as_ref(vault_1_mint.as_ref()).owner
                                != &anchor_lang::solana_program::system_program::ID
                            {
                                return Err(
                                    anchor_lang::error::ErrorCode::ConstraintMintTokenProgram
                                        .into(),
                                );
                            }
                        } else {
                            if AsRef::<AccountInfo>::as_ref(vault_1_mint.as_ref()).owner
                                != &pool_state.token_1_program
                            {
                                return Err(
                                    anchor_lang::error::ErrorCode::ConstraintMintTokenProgram
                                        .into(),
                                );
                            }
                        }
                        if !__is_ctoken {}
                    }
                    if !AsRef::<AccountInfo>::as_ref(recipient_token_0_account.as_ref())
                        .is_writable
                    {
                        return Err(
                            anchor_lang::error::Error::from(
                                    anchor_lang::error::ErrorCode::ConstraintMut,
                                )
                                .with_account_name("recipient_token_0_account"),
                        );
                    }
                    if !AsRef::<AccountInfo>::as_ref(recipient_token_1_account.as_ref())
                        .is_writable
                    {
                        return Err(
                            anchor_lang::error::Error::from(
                                    anchor_lang::error::ErrorCode::ConstraintMut,
                                )
                                .with_account_name("recipient_token_1_account"),
                        );
                    }
                    if !&compressed_token_0_pool_pda.is_writable {
                        return Err(
                            anchor_lang::error::Error::from(
                                    anchor_lang::error::ErrorCode::ConstraintMut,
                                )
                                .with_account_name("compressed_token_0_pool_pda"),
                        );
                    }
                    if !&compressed_token_1_pool_pda.is_writable {
                        return Err(
                            anchor_lang::error::Error::from(
                                    anchor_lang::error::ErrorCode::ConstraintMut,
                                )
                                .with_account_name("compressed_token_1_pool_pda"),
                        );
                    }
                    Ok(CollectProtocolFee {
                        owner,
                        authority,
                        pool_state,
                        amm_config,
                        token_0_vault,
                        token_1_vault,
                        vault_0_mint,
                        vault_1_mint,
                        recipient_token_0_account,
                        recipient_token_1_account,
                        token_program,
                        token_program_2022,
                        compressed_token_program_cpi_authority,
                        compressed_token_program,
                        compressed_token_0_pool_pda,
                        compressed_token_1_pool_pda,
                    })
                }
            }
            #[automatically_derived]
            impl<'info> anchor_lang::ToAccountInfos<'info> for CollectProtocolFee<'info>
            where
                'info: 'info,
            {
                fn to_account_infos(
                    &self,
                ) -> Vec<anchor_lang::solana_program::account_info::AccountInfo<'info>> {
                    let mut account_infos = ::alloc::vec::Vec::new();
                    account_infos.extend(self.owner.to_account_infos());
                    account_infos.extend(self.authority.to_account_infos());
                    account_infos.extend(self.pool_state.to_account_infos());
                    account_infos.extend(self.amm_config.to_account_infos());
                    account_infos.extend(self.token_0_vault.to_account_infos());
                    account_infos.extend(self.token_1_vault.to_account_infos());
                    account_infos.extend(self.vault_0_mint.to_account_infos());
                    account_infos.extend(self.vault_1_mint.to_account_infos());
                    account_infos
                        .extend(self.recipient_token_0_account.to_account_infos());
                    account_infos
                        .extend(self.recipient_token_1_account.to_account_infos());
                    account_infos.extend(self.token_program.to_account_infos());
                    account_infos.extend(self.token_program_2022.to_account_infos());
                    account_infos
                        .extend(
                            self
                                .compressed_token_program_cpi_authority
                                .to_account_infos(),
                        );
                    account_infos
                        .extend(self.compressed_token_program.to_account_infos());
                    account_infos
                        .extend(self.compressed_token_0_pool_pda.to_account_infos());
                    account_infos
                        .extend(self.compressed_token_1_pool_pda.to_account_infos());
                    account_infos
                }
            }
            #[automatically_derived]
            impl<'info> anchor_lang::ToAccountMetas for CollectProtocolFee<'info> {
                fn to_account_metas(
                    &self,
                    is_signer: Option<bool>,
                ) -> Vec<anchor_lang::solana_program::instruction::AccountMeta> {
                    let mut account_metas = ::alloc::vec::Vec::new();
                    account_metas.extend(self.owner.to_account_metas(None));
                    account_metas.extend(self.authority.to_account_metas(None));
                    account_metas.extend(self.pool_state.to_account_metas(None));
                    account_metas.extend(self.amm_config.to_account_metas(None));
                    account_metas.extend(self.token_0_vault.to_account_metas(None));
                    account_metas.extend(self.token_1_vault.to_account_metas(None));
                    account_metas.extend(self.vault_0_mint.to_account_metas(None));
                    account_metas.extend(self.vault_1_mint.to_account_metas(None));
                    account_metas
                        .extend(self.recipient_token_0_account.to_account_metas(None));
                    account_metas
                        .extend(self.recipient_token_1_account.to_account_metas(None));
                    account_metas.extend(self.token_program.to_account_metas(None));
                    account_metas.extend(self.token_program_2022.to_account_metas(None));
                    account_metas
                        .extend(
                            self
                                .compressed_token_program_cpi_authority
                                .to_account_metas(None),
                        );
                    account_metas
                        .extend(self.compressed_token_program.to_account_metas(None));
                    account_metas
                        .extend(self.compressed_token_0_pool_pda.to_account_metas(None));
                    account_metas
                        .extend(self.compressed_token_1_pool_pda.to_account_metas(None));
                    account_metas
                }
            }
            #[automatically_derived]
            impl<'info> anchor_lang::AccountsFinalize<'info, CollectProtocolFeeBumps>
            for CollectProtocolFee<'info>
            where
                'info: 'info,
            {
                fn finalize(
                    &mut self,
                    program_id: &anchor_lang::solana_program::pubkey::Pubkey,
                    _remaining: &[anchor_lang::solana_program::account_info::AccountInfo<
                        'info,
                    >],
                    _ix_data: &[u8],
                    _bumps: &CollectProtocolFeeBumps,
                ) -> anchor_lang::Result<()> {
                    anchor_lang::AccountsFinalize::finalize(
                            &mut self.pool_state,
                            program_id,
                            _remaining,
                            _ix_data,
                            _bumps,
                        )
                        .map_err(|e| e.with_account_name("pool_state"))?;
                    anchor_lang::AccountsFinalize::finalize(
                            &mut self.amm_config,
                            program_id,
                            _remaining,
                            _ix_data,
                            _bumps,
                        )
                        .map_err(|e| e.with_account_name("amm_config"))?;
                    anchor_lang::AccountsFinalize::finalize(
                            &mut self.token_0_vault,
                            program_id,
                            _remaining,
                            _ix_data,
                            _bumps,
                        )
                        .map_err(|e| e.with_account_name("token_0_vault"))?;
                    anchor_lang::AccountsFinalize::finalize(
                            &mut self.token_1_vault,
                            program_id,
                            _remaining,
                            _ix_data,
                            _bumps,
                        )
                        .map_err(|e| e.with_account_name("token_1_vault"))?;
                    anchor_lang::AccountsFinalize::finalize(
                            &mut self.vault_0_mint,
                            program_id,
                            _remaining,
                            _ix_data,
                            _bumps,
                        )
                        .map_err(|e| e.with_account_name("vault_0_mint"))?;
                    anchor_lang::AccountsFinalize::finalize(
                            &mut self.vault_1_mint,
                            program_id,
                            _remaining,
                            _ix_data,
                            _bumps,
                        )
                        .map_err(|e| e.with_account_name("vault_1_mint"))?;
                    anchor_lang::AccountsFinalize::finalize(
                            &mut self.recipient_token_0_account,
                            program_id,
                            _remaining,
                            _ix_data,
                            _bumps,
                        )
                        .map_err(|e| e.with_account_name("recipient_token_0_account"))?;
                    anchor_lang::AccountsFinalize::finalize(
                            &mut self.recipient_token_1_account,
                            program_id,
                            _remaining,
                            _ix_data,
                            _bumps,
                        )
                        .map_err(|e| e.with_account_name("recipient_token_1_account"))?;
                    anchor_lang::AccountsFinalize::finalize(
                            &mut self.token_program,
                            program_id,
                            _remaining,
                            _ix_data,
                            _bumps,
                        )
                        .map_err(|e| e.with_account_name("token_program"))?;
                    anchor_lang::AccountsFinalize::finalize(
                            &mut self.token_program_2022,
                            program_id,
                            _remaining,
                            _ix_data,
                            _bumps,
                        )
                        .map_err(|e| e.with_account_name("token_program_2022"))?;
                    Ok(())
                }
            }
            #[automatically_derived]
            impl<'info> anchor_lang::AccountsExit<'info> for CollectProtocolFee<'info>
            where
                'info: 'info,
            {
                fn exit(
                    &self,
                    program_id: &anchor_lang::solana_program::pubkey::Pubkey,
                ) -> anchor_lang::Result<()> {
                    anchor_lang::AccountsExit::exit(&self.pool_state, program_id)
                        .map_err(|e| e.with_account_name("pool_state"))?;
                    anchor_lang::AccountsExit::exit(&self.token_0_vault, program_id)
                        .map_err(|e| e.with_account_name("token_0_vault"))?;
                    anchor_lang::AccountsExit::exit(&self.token_1_vault, program_id)
                        .map_err(|e| e.with_account_name("token_1_vault"))?;
                    anchor_lang::AccountsExit::exit(
                            &self.recipient_token_0_account,
                            program_id,
                        )
                        .map_err(|e| e.with_account_name("recipient_token_0_account"))?;
                    anchor_lang::AccountsExit::exit(
                            &self.recipient_token_1_account,
                            program_id,
                        )
                        .map_err(|e| e.with_account_name("recipient_token_1_account"))?;
                    anchor_lang::AccountsExit::exit(
                            &self.compressed_token_0_pool_pda,
                            program_id,
                        )
                        .map_err(|e| {
                            e.with_account_name("compressed_token_0_pool_pda")
                        })?;
                    anchor_lang::AccountsExit::exit(
                            &self.compressed_token_1_pool_pda,
                            program_id,
                        )
                        .map_err(|e| {
                            e.with_account_name("compressed_token_1_pool_pda")
                        })?;
                    Ok(())
                }
            }
            pub struct CollectProtocolFeeBumps {
                pub authority: u8,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for CollectProtocolFeeBumps {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field1_finish(
                        f,
                        "CollectProtocolFeeBumps",
                        "authority",
                        &&self.authority,
                    )
                }
            }
            #[automatically_derived]
            impl ::core::clone::Clone for CollectProtocolFeeBumps {
                #[inline]
                fn clone(&self) -> CollectProtocolFeeBumps {
                    CollectProtocolFeeBumps {
                        authority: ::core::clone::Clone::clone(&self.authority),
                    }
                }
            }
            impl Default for CollectProtocolFeeBumps {
                fn default() -> Self {
                    CollectProtocolFeeBumps {
                        authority: u8::MAX,
                    }
                }
            }
            impl<'info> anchor_lang::Bumps for CollectProtocolFee<'info>
            where
                'info: 'info,
            {
                type Bumps = CollectProtocolFeeBumps;
            }
            /// An internal, Anchor generated module. This is used (as an
            /// implementation detail), to generate a struct for a given
            /// `#[derive(Accounts)]` implementation, where each field is a Pubkey,
            /// instead of an `AccountInfo`. This is useful for clients that want
            /// to generate a list of accounts, without explicitly knowing the
            /// order all the fields should be in.
            ///
            /// To access the struct in this module, one should use the sibling
            /// `accounts` module (also generated), which re-exports this.
            pub(crate) mod __client_accounts_collect_protocol_fee {
                use super::*;
                use anchor_lang::prelude::borsh;
                /// Generated client accounts for [`CollectProtocolFee`].
                pub struct CollectProtocolFee {
                    ///Only admin or owner can collect fee now
                    pub owner: Pubkey,
                    pub authority: Pubkey,
                    ///Pool state stores accumulated protocol fee amount
                    pub pool_state: Pubkey,
                    ///Amm config account stores owner
                    pub amm_config: Pubkey,
                    ///The address that holds pool tokens for token_0
                    pub token_0_vault: Pubkey,
                    ///The address that holds pool tokens for token_1
                    pub token_1_vault: Pubkey,
                    ///The mint of token_0 vault
                    pub vault_0_mint: Pubkey,
                    ///The mint of token_1 vault
                    pub vault_1_mint: Pubkey,
                    ///The address that receives the collected token_0 protocol fees
                    pub recipient_token_0_account: Pubkey,
                    ///The address that receives the collected token_1 protocol fees
                    pub recipient_token_1_account: Pubkey,
                    ///The SPL program to perform token transfers
                    pub token_program: Pubkey,
                    ///The SPL program 2022 to perform token transfers
                    pub token_program_2022: Pubkey,
                    pub compressed_token_program_cpi_authority: Pubkey,
                    pub compressed_token_program: Pubkey,
                    pub compressed_token_0_pool_pda: Pubkey,
                    pub compressed_token_1_pool_pda: Pubkey,
                }
                impl borsh::ser::BorshSerialize for CollectProtocolFee
                where
                    Pubkey: borsh::ser::BorshSerialize,
                    Pubkey: borsh::ser::BorshSerialize,
                    Pubkey: borsh::ser::BorshSerialize,
                    Pubkey: borsh::ser::BorshSerialize,
                    Pubkey: borsh::ser::BorshSerialize,
                    Pubkey: borsh::ser::BorshSerialize,
                    Pubkey: borsh::ser::BorshSerialize,
                    Pubkey: borsh::ser::BorshSerialize,
                    Pubkey: borsh::ser::BorshSerialize,
                    Pubkey: borsh::ser::BorshSerialize,
                    Pubkey: borsh::ser::BorshSerialize,
                    Pubkey: borsh::ser::BorshSerialize,
                    Pubkey: borsh::ser::BorshSerialize,
                    Pubkey: borsh::ser::BorshSerialize,
                    Pubkey: borsh::ser::BorshSerialize,
                    Pubkey: borsh::ser::BorshSerialize,
                {
                    fn serialize<W: borsh::maybestd::io::Write>(
                        &self,
                        writer: &mut W,
                    ) -> ::core::result::Result<(), borsh::maybestd::io::Error> {
                        borsh::BorshSerialize::serialize(&self.owner, writer)?;
                        borsh::BorshSerialize::serialize(&self.authority, writer)?;
                        borsh::BorshSerialize::serialize(&self.pool_state, writer)?;
                        borsh::BorshSerialize::serialize(&self.amm_config, writer)?;
                        borsh::BorshSerialize::serialize(&self.token_0_vault, writer)?;
                        borsh::BorshSerialize::serialize(&self.token_1_vault, writer)?;
                        borsh::BorshSerialize::serialize(&self.vault_0_mint, writer)?;
                        borsh::BorshSerialize::serialize(&self.vault_1_mint, writer)?;
                        borsh::BorshSerialize::serialize(
                            &self.recipient_token_0_account,
                            writer,
                        )?;
                        borsh::BorshSerialize::serialize(
                            &self.recipient_token_1_account,
                            writer,
                        )?;
                        borsh::BorshSerialize::serialize(&self.token_program, writer)?;
                        borsh::BorshSerialize::serialize(
                            &self.token_program_2022,
                            writer,
                        )?;
                        borsh::BorshSerialize::serialize(
                            &self.compressed_token_program_cpi_authority,
                            writer,
                        )?;
                        borsh::BorshSerialize::serialize(
                            &self.compressed_token_program,
                            writer,
                        )?;
                        borsh::BorshSerialize::serialize(
                            &self.compressed_token_0_pool_pda,
                            writer,
                        )?;
                        borsh::BorshSerialize::serialize(
                            &self.compressed_token_1_pool_pda,
                            writer,
                        )?;
                        Ok(())
                    }
                }
                impl anchor_lang::idl::build::IdlBuild for CollectProtocolFee {
                    fn create_type() -> Option<anchor_lang::idl::types::IdlTypeDef> {
                        Some(anchor_lang::idl::types::IdlTypeDef {
                            name: Self::get_full_path(),
                            docs: <[_]>::into_vec(
                                ::alloc::boxed::box_new([
                                    "Generated client accounts for [`CollectProtocolFee`]."
                                        .into(),
                                ]),
                            ),
                            serialization: anchor_lang::idl::types::IdlSerialization::default(),
                            repr: None,
                            generics: ::alloc::vec::Vec::new(),
                            ty: anchor_lang::idl::types::IdlTypeDefTy::Struct {
                                fields: Some(
                                    anchor_lang::idl::types::IdlDefinedFields::Named(
                                        <[_]>::into_vec(
                                            ::alloc::boxed::box_new([
                                                anchor_lang::idl::types::IdlField {
                                                    name: "owner".into(),
                                                    docs: <[_]>::into_vec(
                                                        ::alloc::boxed::box_new([
                                                            "Only admin or owner can collect fee now".into(),
                                                        ]),
                                                    ),
                                                    ty: anchor_lang::idl::types::IdlType::Pubkey,
                                                },
                                                anchor_lang::idl::types::IdlField {
                                                    name: "authority".into(),
                                                    docs: ::alloc::vec::Vec::new(),
                                                    ty: anchor_lang::idl::types::IdlType::Pubkey,
                                                },
                                                anchor_lang::idl::types::IdlField {
                                                    name: "pool_state".into(),
                                                    docs: <[_]>::into_vec(
                                                        ::alloc::boxed::box_new([
                                                            "Pool state stores accumulated protocol fee amount".into(),
                                                        ]),
                                                    ),
                                                    ty: anchor_lang::idl::types::IdlType::Pubkey,
                                                },
                                                anchor_lang::idl::types::IdlField {
                                                    name: "amm_config".into(),
                                                    docs: <[_]>::into_vec(
                                                        ::alloc::boxed::box_new([
                                                            "Amm config account stores owner".into(),
                                                        ]),
                                                    ),
                                                    ty: anchor_lang::idl::types::IdlType::Pubkey,
                                                },
                                                anchor_lang::idl::types::IdlField {
                                                    name: "token_0_vault".into(),
                                                    docs: <[_]>::into_vec(
                                                        ::alloc::boxed::box_new([
                                                            "The address that holds pool tokens for token_0".into(),
                                                        ]),
                                                    ),
                                                    ty: anchor_lang::idl::types::IdlType::Pubkey,
                                                },
                                                anchor_lang::idl::types::IdlField {
                                                    name: "token_1_vault".into(),
                                                    docs: <[_]>::into_vec(
                                                        ::alloc::boxed::box_new([
                                                            "The address that holds pool tokens for token_1".into(),
                                                        ]),
                                                    ),
                                                    ty: anchor_lang::idl::types::IdlType::Pubkey,
                                                },
                                                anchor_lang::idl::types::IdlField {
                                                    name: "vault_0_mint".into(),
                                                    docs: <[_]>::into_vec(
                                                        ::alloc::boxed::box_new([
                                                            "The mint of token_0 vault".into(),
                                                        ]),
                                                    ),
                                                    ty: anchor_lang::idl::types::IdlType::Pubkey,
                                                },
                                                anchor_lang::idl::types::IdlField {
                                                    name: "vault_1_mint".into(),
                                                    docs: <[_]>::into_vec(
                                                        ::alloc::boxed::box_new([
                                                            "The mint of token_1 vault".into(),
                                                        ]),
                                                    ),
                                                    ty: anchor_lang::idl::types::IdlType::Pubkey,
                                                },
                                                anchor_lang::idl::types::IdlField {
                                                    name: "recipient_token_0_account".into(),
                                                    docs: <[_]>::into_vec(
                                                        ::alloc::boxed::box_new([
                                                            "The address that receives the collected token_0 protocol fees"
                                                                .into(),
                                                        ]),
                                                    ),
                                                    ty: anchor_lang::idl::types::IdlType::Pubkey,
                                                },
                                                anchor_lang::idl::types::IdlField {
                                                    name: "recipient_token_1_account".into(),
                                                    docs: <[_]>::into_vec(
                                                        ::alloc::boxed::box_new([
                                                            "The address that receives the collected token_1 protocol fees"
                                                                .into(),
                                                        ]),
                                                    ),
                                                    ty: anchor_lang::idl::types::IdlType::Pubkey,
                                                },
                                                anchor_lang::idl::types::IdlField {
                                                    name: "token_program".into(),
                                                    docs: <[_]>::into_vec(
                                                        ::alloc::boxed::box_new([
                                                            "The SPL program to perform token transfers".into(),
                                                        ]),
                                                    ),
                                                    ty: anchor_lang::idl::types::IdlType::Pubkey,
                                                },
                                                anchor_lang::idl::types::IdlField {
                                                    name: "token_program_2022".into(),
                                                    docs: <[_]>::into_vec(
                                                        ::alloc::boxed::box_new([
                                                            "The SPL program 2022 to perform token transfers".into(),
                                                        ]),
                                                    ),
                                                    ty: anchor_lang::idl::types::IdlType::Pubkey,
                                                },
                                                anchor_lang::idl::types::IdlField {
                                                    name: "compressed_token_program_cpi_authority".into(),
                                                    docs: ::alloc::vec::Vec::new(),
                                                    ty: anchor_lang::idl::types::IdlType::Pubkey,
                                                },
                                                anchor_lang::idl::types::IdlField {
                                                    name: "compressed_token_program".into(),
                                                    docs: ::alloc::vec::Vec::new(),
                                                    ty: anchor_lang::idl::types::IdlType::Pubkey,
                                                },
                                                anchor_lang::idl::types::IdlField {
                                                    name: "compressed_token_0_pool_pda".into(),
                                                    docs: ::alloc::vec::Vec::new(),
                                                    ty: anchor_lang::idl::types::IdlType::Pubkey,
                                                },
                                                anchor_lang::idl::types::IdlField {
                                                    name: "compressed_token_1_pool_pda".into(),
                                                    docs: ::alloc::vec::Vec::new(),
                                                    ty: anchor_lang::idl::types::IdlType::Pubkey,
                                                },
                                            ]),
                                        ),
                                    ),
                                ),
                            },
                        })
                    }
                    fn insert_types(
                        types: &mut std::collections::BTreeMap<
                            String,
                            anchor_lang::idl::types::IdlTypeDef,
                        >,
                    ) {}
                    fn get_full_path() -> String {
                        ::alloc::__export::must_use({
                            ::alloc::fmt::format(
                                format_args!(
                                    "{0}::{1}",
                                    "raydium_cp_swap::instructions::admin::collect_protocol_fee::__client_accounts_collect_protocol_fee",
                                    "CollectProtocolFee",
                                ),
                            )
                        })
                    }
                }
                #[automatically_derived]
                impl anchor_lang::ToAccountMetas for CollectProtocolFee {
                    fn to_account_metas(
                        &self,
                        is_signer: Option<bool>,
                    ) -> Vec<anchor_lang::solana_program::instruction::AccountMeta> {
                        let mut account_metas = ::alloc::vec::Vec::new();
                        account_metas
                            .push(
                                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                                    self.owner,
                                    true,
                                ),
                            );
                        account_metas
                            .push(
                                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                                    self.authority,
                                    false,
                                ),
                            );
                        account_metas
                            .push(
                                anchor_lang::solana_program::instruction::AccountMeta::new(
                                    self.pool_state,
                                    false,
                                ),
                            );
                        account_metas
                            .push(
                                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                                    self.amm_config,
                                    false,
                                ),
                            );
                        account_metas
                            .push(
                                anchor_lang::solana_program::instruction::AccountMeta::new(
                                    self.token_0_vault,
                                    false,
                                ),
                            );
                        account_metas
                            .push(
                                anchor_lang::solana_program::instruction::AccountMeta::new(
                                    self.token_1_vault,
                                    false,
                                ),
                            );
                        account_metas
                            .push(
                                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                                    self.vault_0_mint,
                                    false,
                                ),
                            );
                        account_metas
                            .push(
                                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                                    self.vault_1_mint,
                                    false,
                                ),
                            );
                        account_metas
                            .push(
                                anchor_lang::solana_program::instruction::AccountMeta::new(
                                    self.recipient_token_0_account,
                                    false,
                                ),
                            );
                        account_metas
                            .push(
                                anchor_lang::solana_program::instruction::AccountMeta::new(
                                    self.recipient_token_1_account,
                                    false,
                                ),
                            );
                        account_metas
                            .push(
                                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                                    self.token_program,
                                    false,
                                ),
                            );
                        account_metas
                            .push(
                                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                                    self.token_program_2022,
                                    false,
                                ),
                            );
                        account_metas
                            .push(
                                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                                    self.compressed_token_program_cpi_authority,
                                    false,
                                ),
                            );
                        account_metas
                            .push(
                                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                                    self.compressed_token_program,
                                    false,
                                ),
                            );
                        account_metas
                            .push(
                                anchor_lang::solana_program::instruction::AccountMeta::new(
                                    self.compressed_token_0_pool_pda,
                                    false,
                                ),
                            );
                        account_metas
                            .push(
                                anchor_lang::solana_program::instruction::AccountMeta::new(
                                    self.compressed_token_1_pool_pda,
                                    false,
                                ),
                            );
                        account_metas
                    }
                }
            }
            /// An internal, Anchor generated module. This is used (as an
            /// implementation detail), to generate a CPI struct for a given
            /// `#[derive(Accounts)]` implementation, where each field is an
            /// AccountInfo.
            ///
            /// To access the struct in this module, one should use the sibling
            /// [`cpi::accounts`] module (also generated), which re-exports this.
            pub(crate) mod __cpi_client_accounts_collect_protocol_fee {
                use super::*;
                /// Generated CPI struct of the accounts for [`CollectProtocolFee`].
                pub struct CollectProtocolFee<'info> {
                    ///Only admin or owner can collect fee now
                    pub owner: anchor_lang::solana_program::account_info::AccountInfo<
                        'info,
                    >,
                    pub authority: anchor_lang::solana_program::account_info::AccountInfo<
                        'info,
                    >,
                    ///Pool state stores accumulated protocol fee amount
                    pub pool_state: anchor_lang::solana_program::account_info::AccountInfo<
                        'info,
                    >,
                    ///Amm config account stores owner
                    pub amm_config: anchor_lang::solana_program::account_info::AccountInfo<
                        'info,
                    >,
                    ///The address that holds pool tokens for token_0
                    pub token_0_vault: anchor_lang::solana_program::account_info::AccountInfo<
                        'info,
                    >,
                    ///The address that holds pool tokens for token_1
                    pub token_1_vault: anchor_lang::solana_program::account_info::AccountInfo<
                        'info,
                    >,
                    ///The mint of token_0 vault
                    pub vault_0_mint: anchor_lang::solana_program::account_info::AccountInfo<
                        'info,
                    >,
                    ///The mint of token_1 vault
                    pub vault_1_mint: anchor_lang::solana_program::account_info::AccountInfo<
                        'info,
                    >,
                    ///The address that receives the collected token_0 protocol fees
                    pub recipient_token_0_account: anchor_lang::solana_program::account_info::AccountInfo<
                        'info,
                    >,
                    ///The address that receives the collected token_1 protocol fees
                    pub recipient_token_1_account: anchor_lang::solana_program::account_info::AccountInfo<
                        'info,
                    >,
                    ///The SPL program to perform token transfers
                    pub token_program: anchor_lang::solana_program::account_info::AccountInfo<
                        'info,
                    >,
                    ///The SPL program 2022 to perform token transfers
                    pub token_program_2022: anchor_lang::solana_program::account_info::AccountInfo<
                        'info,
                    >,
                    pub compressed_token_program_cpi_authority: anchor_lang::solana_program::account_info::AccountInfo<
                        'info,
                    >,
                    pub compressed_token_program: anchor_lang::solana_program::account_info::AccountInfo<
                        'info,
                    >,
                    pub compressed_token_0_pool_pda: anchor_lang::solana_program::account_info::AccountInfo<
                        'info,
                    >,
                    pub compressed_token_1_pool_pda: anchor_lang::solana_program::account_info::AccountInfo<
                        'info,
                    >,
                }
                #[automatically_derived]
                impl<'info> anchor_lang::ToAccountMetas for CollectProtocolFee<'info> {
                    fn to_account_metas(
                        &self,
                        is_signer: Option<bool>,
                    ) -> Vec<anchor_lang::solana_program::instruction::AccountMeta> {
                        let mut account_metas = ::alloc::vec::Vec::new();
                        account_metas
                            .push(
                                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                                    anchor_lang::Key::key(&self.owner),
                                    true,
                                ),
                            );
                        account_metas
                            .push(
                                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                                    anchor_lang::Key::key(&self.authority),
                                    false,
                                ),
                            );
                        account_metas
                            .push(
                                anchor_lang::solana_program::instruction::AccountMeta::new(
                                    anchor_lang::Key::key(&self.pool_state),
                                    false,
                                ),
                            );
                        account_metas
                            .push(
                                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                                    anchor_lang::Key::key(&self.amm_config),
                                    false,
                                ),
                            );
                        account_metas
                            .push(
                                anchor_lang::solana_program::instruction::AccountMeta::new(
                                    anchor_lang::Key::key(&self.token_0_vault),
                                    false,
                                ),
                            );
                        account_metas
                            .push(
                                anchor_lang::solana_program::instruction::AccountMeta::new(
                                    anchor_lang::Key::key(&self.token_1_vault),
                                    false,
                                ),
                            );
                        account_metas
                            .push(
                                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                                    anchor_lang::Key::key(&self.vault_0_mint),
                                    false,
                                ),
                            );
                        account_metas
                            .push(
                                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                                    anchor_lang::Key::key(&self.vault_1_mint),
                                    false,
                                ),
                            );
                        account_metas
                            .push(
                                anchor_lang::solana_program::instruction::AccountMeta::new(
                                    anchor_lang::Key::key(&self.recipient_token_0_account),
                                    false,
                                ),
                            );
                        account_metas
                            .push(
                                anchor_lang::solana_program::instruction::AccountMeta::new(
                                    anchor_lang::Key::key(&self.recipient_token_1_account),
                                    false,
                                ),
                            );
                        account_metas
                            .push(
                                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                                    anchor_lang::Key::key(&self.token_program),
                                    false,
                                ),
                            );
                        account_metas
                            .push(
                                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                                    anchor_lang::Key::key(&self.token_program_2022),
                                    false,
                                ),
                            );
                        account_metas
                            .push(
                                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                                    anchor_lang::Key::key(
                                        &self.compressed_token_program_cpi_authority,
                                    ),
                                    false,
                                ),
                            );
                        account_metas
                            .push(
                                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                                    anchor_lang::Key::key(&self.compressed_token_program),
                                    false,
                                ),
                            );
                        account_metas
                            .push(
                                anchor_lang::solana_program::instruction::AccountMeta::new(
                                    anchor_lang::Key::key(&self.compressed_token_0_pool_pda),
                                    false,
                                ),
                            );
                        account_metas
                            .push(
                                anchor_lang::solana_program::instruction::AccountMeta::new(
                                    anchor_lang::Key::key(&self.compressed_token_1_pool_pda),
                                    false,
                                ),
                            );
                        account_metas
                    }
                }
                #[automatically_derived]
                impl<'info> anchor_lang::ToAccountInfos<'info>
                for CollectProtocolFee<'info> {
                    fn to_account_infos(
                        &self,
                    ) -> Vec<
                        anchor_lang::solana_program::account_info::AccountInfo<'info>,
                    > {
                        let mut account_infos = ::alloc::vec::Vec::new();
                        account_infos
                            .extend(
                                anchor_lang::ToAccountInfos::to_account_infos(&self.owner),
                            );
                        account_infos
                            .extend(
                                anchor_lang::ToAccountInfos::to_account_infos(
                                    &self.authority,
                                ),
                            );
                        account_infos
                            .extend(
                                anchor_lang::ToAccountInfos::to_account_infos(
                                    &self.pool_state,
                                ),
                            );
                        account_infos
                            .extend(
                                anchor_lang::ToAccountInfos::to_account_infos(
                                    &self.amm_config,
                                ),
                            );
                        account_infos
                            .extend(
                                anchor_lang::ToAccountInfos::to_account_infos(
                                    &self.token_0_vault,
                                ),
                            );
                        account_infos
                            .extend(
                                anchor_lang::ToAccountInfos::to_account_infos(
                                    &self.token_1_vault,
                                ),
                            );
                        account_infos
                            .extend(
                                anchor_lang::ToAccountInfos::to_account_infos(
                                    &self.vault_0_mint,
                                ),
                            );
                        account_infos
                            .extend(
                                anchor_lang::ToAccountInfos::to_account_infos(
                                    &self.vault_1_mint,
                                ),
                            );
                        account_infos
                            .extend(
                                anchor_lang::ToAccountInfos::to_account_infos(
                                    &self.recipient_token_0_account,
                                ),
                            );
                        account_infos
                            .extend(
                                anchor_lang::ToAccountInfos::to_account_infos(
                                    &self.recipient_token_1_account,
                                ),
                            );
                        account_infos
                            .extend(
                                anchor_lang::ToAccountInfos::to_account_infos(
                                    &self.token_program,
                                ),
                            );
                        account_infos
                            .extend(
                                anchor_lang::ToAccountInfos::to_account_infos(
                                    &self.token_program_2022,
                                ),
                            );
                        account_infos
                            .extend(
                                anchor_lang::ToAccountInfos::to_account_infos(
                                    &self.compressed_token_program_cpi_authority,
                                ),
                            );
                        account_infos
                            .extend(
                                anchor_lang::ToAccountInfos::to_account_infos(
                                    &self.compressed_token_program,
                                ),
                            );
                        account_infos
                            .extend(
                                anchor_lang::ToAccountInfos::to_account_infos(
                                    &self.compressed_token_0_pool_pda,
                                ),
                            );
                        account_infos
                            .extend(
                                anchor_lang::ToAccountInfos::to_account_infos(
                                    &self.compressed_token_1_pool_pda,
                                ),
                            );
                        account_infos
                    }
                }
            }
            impl<'info> CollectProtocolFee<'info> {
                pub fn __anchor_private_gen_idl_accounts(
                    accounts: &mut std::collections::BTreeMap<
                        String,
                        anchor_lang::idl::types::IdlAccount,
                    >,
                    types: &mut std::collections::BTreeMap<
                        String,
                        anchor_lang::idl::types::IdlTypeDef,
                    >,
                ) -> Vec<anchor_lang::idl::types::IdlInstructionAccountItem> {
                    if let Some(ty) = <PoolState>::create_type() {
                        let account = anchor_lang::idl::types::IdlAccount {
                            name: ty.name.clone(),
                            discriminator: PoolState::DISCRIMINATOR.into(),
                        };
                        accounts.insert(account.name.clone(), account);
                        types.insert(ty.name.clone(), ty);
                        <PoolState>::insert_types(types);
                    }
                    if let Some(ty) = <AmmConfig>::create_type() {
                        let account = anchor_lang::idl::types::IdlAccount {
                            name: ty.name.clone(),
                            discriminator: AmmConfig::DISCRIMINATOR.into(),
                        };
                        accounts.insert(account.name.clone(), account);
                        types.insert(ty.name.clone(), ty);
                        <AmmConfig>::insert_types(types);
                    }
                    if let Some(ty) = <TokenAccount>::create_type() {
                        let account = anchor_lang::idl::types::IdlAccount {
                            name: ty.name.clone(),
                            discriminator: TokenAccount::DISCRIMINATOR.into(),
                        };
                        accounts.insert(account.name.clone(), account);
                        types.insert(ty.name.clone(), ty);
                        <TokenAccount>::insert_types(types);
                    }
                    if let Some(ty) = <TokenAccount>::create_type() {
                        let account = anchor_lang::idl::types::IdlAccount {
                            name: ty.name.clone(),
                            discriminator: TokenAccount::DISCRIMINATOR.into(),
                        };
                        accounts.insert(account.name.clone(), account);
                        types.insert(ty.name.clone(), ty);
                        <TokenAccount>::insert_types(types);
                    }
                    if let Some(ty) = <Mint>::create_type() {
                        let account = anchor_lang::idl::types::IdlAccount {
                            name: ty.name.clone(),
                            discriminator: Mint::DISCRIMINATOR.into(),
                        };
                        accounts.insert(account.name.clone(), account);
                        types.insert(ty.name.clone(), ty);
                        <Mint>::insert_types(types);
                    }
                    if let Some(ty) = <Mint>::create_type() {
                        let account = anchor_lang::idl::types::IdlAccount {
                            name: ty.name.clone(),
                            discriminator: Mint::DISCRIMINATOR.into(),
                        };
                        accounts.insert(account.name.clone(), account);
                        types.insert(ty.name.clone(), ty);
                        <Mint>::insert_types(types);
                    }
                    if let Some(ty) = <TokenAccount>::create_type() {
                        let account = anchor_lang::idl::types::IdlAccount {
                            name: ty.name.clone(),
                            discriminator: TokenAccount::DISCRIMINATOR.into(),
                        };
                        accounts.insert(account.name.clone(), account);
                        types.insert(ty.name.clone(), ty);
                        <TokenAccount>::insert_types(types);
                    }
                    if let Some(ty) = <TokenAccount>::create_type() {
                        let account = anchor_lang::idl::types::IdlAccount {
                            name: ty.name.clone(),
                            discriminator: TokenAccount::DISCRIMINATOR.into(),
                        };
                        accounts.insert(account.name.clone(), account);
                        types.insert(ty.name.clone(), ty);
                        <TokenAccount>::insert_types(types);
                    }
                    <[_]>::into_vec(
                        ::alloc::boxed::box_new([
                            anchor_lang::idl::types::IdlInstructionAccountItem::Single(anchor_lang::idl::types::IdlInstructionAccount {
                                name: "owner".into(),
                                docs: <[_]>::into_vec(
                                    ::alloc::boxed::box_new([
                                        "Only admin or owner can collect fee now".into(),
                                    ]),
                                ),
                                writable: false,
                                signer: true,
                                optional: false,
                                address: None,
                                pda: None,
                                relations: ::alloc::vec::Vec::new(),
                            }),
                            anchor_lang::idl::types::IdlInstructionAccountItem::Single(anchor_lang::idl::types::IdlInstructionAccount {
                                name: "authority".into(),
                                docs: ::alloc::vec::Vec::new(),
                                writable: false,
                                signer: false,
                                optional: false,
                                address: None,
                                pda: None,
                                relations: ::alloc::vec::Vec::new(),
                            }),
                            anchor_lang::idl::types::IdlInstructionAccountItem::Single(anchor_lang::idl::types::IdlInstructionAccount {
                                name: "pool_state".into(),
                                docs: <[_]>::into_vec(
                                    ::alloc::boxed::box_new([
                                        "Pool state stores accumulated protocol fee amount".into(),
                                    ]),
                                ),
                                writable: true,
                                signer: false,
                                optional: false,
                                address: None,
                                pda: None,
                                relations: ::alloc::vec::Vec::new(),
                            }),
                            anchor_lang::idl::types::IdlInstructionAccountItem::Single(anchor_lang::idl::types::IdlInstructionAccount {
                                name: "amm_config".into(),
                                docs: <[_]>::into_vec(
                                    ::alloc::boxed::box_new([
                                        "Amm config account stores owner".into(),
                                    ]),
                                ),
                                writable: false,
                                signer: false,
                                optional: false,
                                address: None,
                                pda: None,
                                relations: ::alloc::vec::Vec::new(),
                            }),
                            anchor_lang::idl::types::IdlInstructionAccountItem::Single(anchor_lang::idl::types::IdlInstructionAccount {
                                name: "token_0_vault".into(),
                                docs: <[_]>::into_vec(
                                    ::alloc::boxed::box_new([
                                        "The address that holds pool tokens for token_0".into(),
                                    ]),
                                ),
                                writable: true,
                                signer: false,
                                optional: false,
                                address: None,
                                pda: None,
                                relations: ::alloc::vec::Vec::new(),
                            }),
                            anchor_lang::idl::types::IdlInstructionAccountItem::Single(anchor_lang::idl::types::IdlInstructionAccount {
                                name: "token_1_vault".into(),
                                docs: <[_]>::into_vec(
                                    ::alloc::boxed::box_new([
                                        "The address that holds pool tokens for token_1".into(),
                                    ]),
                                ),
                                writable: true,
                                signer: false,
                                optional: false,
                                address: None,
                                pda: None,
                                relations: ::alloc::vec::Vec::new(),
                            }),
                            anchor_lang::idl::types::IdlInstructionAccountItem::Single(anchor_lang::idl::types::IdlInstructionAccount {
                                name: "vault_0_mint".into(),
                                docs: <[_]>::into_vec(
                                    ::alloc::boxed::box_new([
                                        "The mint of token_0 vault".into(),
                                    ]),
                                ),
                                writable: false,
                                signer: false,
                                optional: false,
                                address: None,
                                pda: None,
                                relations: ::alloc::vec::Vec::new(),
                            }),
                            anchor_lang::idl::types::IdlInstructionAccountItem::Single(anchor_lang::idl::types::IdlInstructionAccount {
                                name: "vault_1_mint".into(),
                                docs: <[_]>::into_vec(
                                    ::alloc::boxed::box_new([
                                        "The mint of token_1 vault".into(),
                                    ]),
                                ),
                                writable: false,
                                signer: false,
                                optional: false,
                                address: None,
                                pda: None,
                                relations: ::alloc::vec::Vec::new(),
                            }),
                            anchor_lang::idl::types::IdlInstructionAccountItem::Single(anchor_lang::idl::types::IdlInstructionAccount {
                                name: "recipient_token_0_account".into(),
                                docs: <[_]>::into_vec(
                                    ::alloc::boxed::box_new([
                                        "The address that receives the collected token_0 protocol fees"
                                            .into(),
                                    ]),
                                ),
                                writable: true,
                                signer: false,
                                optional: false,
                                address: None,
                                pda: None,
                                relations: ::alloc::vec::Vec::new(),
                            }),
                            anchor_lang::idl::types::IdlInstructionAccountItem::Single(anchor_lang::idl::types::IdlInstructionAccount {
                                name: "recipient_token_1_account".into(),
                                docs: <[_]>::into_vec(
                                    ::alloc::boxed::box_new([
                                        "The address that receives the collected token_1 protocol fees"
                                            .into(),
                                    ]),
                                ),
                                writable: true,
                                signer: false,
                                optional: false,
                                address: None,
                                pda: None,
                                relations: ::alloc::vec::Vec::new(),
                            }),
                            anchor_lang::idl::types::IdlInstructionAccountItem::Single(anchor_lang::idl::types::IdlInstructionAccount {
                                name: "token_program".into(),
                                docs: <[_]>::into_vec(
                                    ::alloc::boxed::box_new([
                                        "The SPL program to perform token transfers".into(),
                                    ]),
                                ),
                                writable: false,
                                signer: false,
                                optional: false,
                                address: None,
                                pda: None,
                                relations: ::alloc::vec::Vec::new(),
                            }),
                            anchor_lang::idl::types::IdlInstructionAccountItem::Single(anchor_lang::idl::types::IdlInstructionAccount {
                                name: "token_program_2022".into(),
                                docs: <[_]>::into_vec(
                                    ::alloc::boxed::box_new([
                                        "The SPL program 2022 to perform token transfers".into(),
                                    ]),
                                ),
                                writable: false,
                                signer: false,
                                optional: false,
                                address: None,
                                pda: None,
                                relations: ::alloc::vec::Vec::new(),
                            }),
                            anchor_lang::idl::types::IdlInstructionAccountItem::Single(anchor_lang::idl::types::IdlInstructionAccount {
                                name: "compressed_token_program_cpi_authority".into(),
                                docs: ::alloc::vec::Vec::new(),
                                writable: false,
                                signer: false,
                                optional: false,
                                address: None,
                                pda: None,
                                relations: ::alloc::vec::Vec::new(),
                            }),
                            anchor_lang::idl::types::IdlInstructionAccountItem::Single(anchor_lang::idl::types::IdlInstructionAccount {
                                name: "compressed_token_program".into(),
                                docs: ::alloc::vec::Vec::new(),
                                writable: false,
                                signer: false,
                                optional: false,
                                address: None,
                                pda: None,
                                relations: ::alloc::vec::Vec::new(),
                            }),
                            anchor_lang::idl::types::IdlInstructionAccountItem::Single(anchor_lang::idl::types::IdlInstructionAccount {
                                name: "compressed_token_0_pool_pda".into(),
                                docs: ::alloc::vec::Vec::new(),
                                writable: true,
                                signer: false,
                                optional: false,
                                address: None,
                                pda: None,
                                relations: ::alloc::vec::Vec::new(),
                            }),
                            anchor_lang::idl::types::IdlInstructionAccountItem::Single(anchor_lang::idl::types::IdlInstructionAccount {
                                name: "compressed_token_1_pool_pda".into(),
                                docs: ::alloc::vec::Vec::new(),
                                writable: true,
                                signer: false,
                                optional: false,
                                address: None,
                                pda: None,
                                relations: ::alloc::vec::Vec::new(),
                            }),
                        ]),
                    )
                }
                pub fn __anchor_private_gen_light_metadata() -> Option<
                    anchor_lang::idl::types::IdlLightInstructionMeta,
                > {
                    Some(anchor_lang::idl::types::IdlLightInstructionMeta {
                        ctokens: None,
                        cpdas: Some(
                            <[_]>::into_vec(
                                ::alloc::boxed::box_new([
                                    anchor_lang::idl::types::IdlLightCpdaUsage {
                                        account: "pool_state".to_string(),
                                        ty: "PoolState".to_string(),
                                    },
                                ]),
                            ),
                        ),
                    })
                }
            }
            pub fn collect_protocol_fee(
                ctx: Context<CollectProtocolFee>,
                amount_0_requested: u64,
                amount_1_requested: u64,
            ) -> Result<()> {
                let amount_0: u64;
                let amount_1: u64;
                let auth_bump: u8;
                {
                    let pool_state = &mut ctx.accounts.pool_state;
                    amount_0 = amount_0_requested.min(pool_state.protocol_fees_token_0);
                    amount_1 = amount_1_requested.min(pool_state.protocol_fees_token_1);
                    pool_state.protocol_fees_token_0 = pool_state
                        .protocol_fees_token_0
                        .checked_sub(amount_0)
                        .unwrap();
                    pool_state.protocol_fees_token_1 = pool_state
                        .protocol_fees_token_1
                        .checked_sub(amount_1)
                        .unwrap();
                    auth_bump = pool_state.auth_bump;
                    pool_state.recent_epoch = Clock::get()?.epoch;
                }
                let (compressed_token_0_pool_bump, compressed_token_1_pool_bump) = get_bumps(
                    ctx.accounts.vault_0_mint.key(),
                    ctx.accounts.vault_1_mint.key(),
                    ctx.accounts.compressed_token_program.key(),
                );
                transfer_from_pool_vault_to_user(
                    ctx.accounts.owner.to_account_info(),
                    ctx.accounts.authority.to_account_info(),
                    ctx.accounts.token_0_vault.to_account_info(),
                    ctx.accounts.recipient_token_0_account.to_account_info(),
                    Some(ctx.accounts.vault_0_mint.to_account_info()),
                    Some(
                        if ctx.accounts.vault_0_mint.to_account_info().owner
                            == ctx.accounts.token_program.key
                        {
                            ctx.accounts.token_program.to_account_info()
                        } else {
                            ctx.accounts.token_program_2022.to_account_info()
                        },
                    ),
                    Some(ctx.accounts.compressed_token_0_pool_pda.to_account_info()),
                    Some(compressed_token_0_pool_bump),
                    ctx
                        .accounts
                        .compressed_token_program_cpi_authority
                        .to_account_info(),
                    amount_0,
                    &[&[crate::AUTH_SEED.as_bytes(), &[auth_bump]]],
                )?;
                transfer_from_pool_vault_to_user(
                    ctx.accounts.owner.to_account_info(),
                    ctx.accounts.authority.to_account_info(),
                    ctx.accounts.token_1_vault.to_account_info(),
                    ctx.accounts.recipient_token_1_account.to_account_info(),
                    Some(ctx.accounts.vault_1_mint.to_account_info()),
                    Some(
                        if ctx.accounts.vault_1_mint.to_account_info().owner
                            == ctx.accounts.token_program.key
                        {
                            ctx.accounts.token_program.to_account_info()
                        } else {
                            ctx.accounts.token_program_2022.to_account_info()
                        },
                    ),
                    Some(ctx.accounts.compressed_token_1_pool_pda.to_account_info()),
                    Some(compressed_token_1_pool_bump),
                    ctx
                        .accounts
                        .compressed_token_program_cpi_authority
                        .to_account_info(),
                    amount_1,
                    &[&[crate::AUTH_SEED.as_bytes(), &[auth_bump]]],
                )?;
                Ok(())
            }
        }
        pub use collect_protocol_fee::*;
        pub mod collect_fund_fee {
            use crate::error::ErrorCode;
            use crate::states::*;
            use crate::utils::ctoken::get_bumps;
            use crate::utils::token::*;
            use anchor_lang::prelude::*;
            use anchor_spl::token::Token;
            use anchor_spl::token_interface::Mint;
            use anchor_spl::token_interface::Token2022;
            use anchor_spl::token_interface::TokenAccount;
            pub struct CollectFundFee<'info> {
                /// Only admin or fund_owner can collect fee now
                #[account(
                    constraint = (
                        owner.key(

                        )= = amm_config.fund_owner||owner.key()= = crate::admin::ID
                    )@ErrorCode::InvalidOwner
                )]
                pub owner: Signer<'info>,
                /// CHECK: pool vault and lp mint authority
                #[account(seeds = [crate::AUTH_SEED.as_bytes()], bump)]
                pub authority: UncheckedAccount<'info>,
                /// Pool state stores accumulated protocol fee amount
                #[account(mut)]
                pub pool_state: Account<'info, PoolState>,
                /// Amm config account stores fund_owner
                #[account(address = pool_state.amm_config)]
                pub amm_config: Account<'info, AmmConfig>,
                /// The address that holds pool tokens for token_0
                #[account(
                    mut,
                    constraint = token_0_vault.key()= = pool_state.token_0_vault
                )]
                pub token_0_vault: Box<InterfaceAccount<'info, TokenAccount>>,
                /// The address that holds pool tokens for token_1
                #[account(
                    mut,
                    constraint = token_1_vault.key()= = pool_state.token_1_vault
                )]
                pub token_1_vault: Box<InterfaceAccount<'info, TokenAccount>>,
                /// The mint of token_0 vault
                #[account(
                    address = token_0_vault.mint,
                    mint::token_program = pool_state.token_0_program,
                )]
                pub vault_0_mint: Box<InterfaceAccount<'info, Mint>>,
                /// The mint of token_1 vault
                #[account(
                    address = token_1_vault.mint,
                    mint::token_program = pool_state.token_1_program,
                )]
                pub vault_1_mint: Box<InterfaceAccount<'info, Mint>>,
                /// The address that receives the collected token_0 fund fees
                #[account(mut)]
                pub recipient_token_0_account: Box<
                    InterfaceAccount<'info, TokenAccount>,
                >,
                /// The address that receives the collected token_1 fund fees
                #[account(mut)]
                pub recipient_token_1_account: Box<
                    InterfaceAccount<'info, TokenAccount>,
                >,
                /// The SPL program to perform token transfers
                pub token_program: Program<'info, Token>,
                /// The SPL program 2022 to perform token transfers
                pub token_program_2022: Program<'info, Token2022>,
                /// CHECK: checked by protocol.
                pub compressed_token_program_cpi_authority: AccountInfo<'info>,
                /// CHECK: checked by protocol.
                pub compressed_token_program: AccountInfo<'info>,
                /// CHECK: checked by protocol.
                #[account(mut)]
                pub compressed_token_0_pool_pda: AccountInfo<'info>,
                /// CHECK: checked by protocol.
                #[account(mut)]
                pub compressed_token_1_pool_pda: AccountInfo<'info>,
            }
            #[automatically_derived]
            impl<'info> anchor_lang::Accounts<'info, CollectFundFeeBumps>
            for CollectFundFee<'info>
            where
                'info: 'info,
            {
                #[inline(never)]
                fn try_accounts(
                    __program_id: &anchor_lang::solana_program::pubkey::Pubkey,
                    __accounts: &mut &'info [anchor_lang::solana_program::account_info::AccountInfo<
                        'info,
                    >],
                    __ix_data: &[u8],
                    __bumps: &mut CollectFundFeeBumps,
                    __reallocs: &mut std::collections::BTreeSet<
                        anchor_lang::solana_program::pubkey::Pubkey,
                    >,
                ) -> anchor_lang::Result<Self> {
                    let owner: Signer = anchor_lang::Accounts::try_accounts(
                            __program_id,
                            __accounts,
                            __ix_data,
                            __bumps,
                            __reallocs,
                        )
                        .map_err(|e| e.with_account_name("owner"))?;
                    let authority: UncheckedAccount = anchor_lang::Accounts::try_accounts(
                            __program_id,
                            __accounts,
                            __ix_data,
                            __bumps,
                            __reallocs,
                        )
                        .map_err(|e| e.with_account_name("authority"))?;
                    let pool_state: anchor_lang::accounts::account::Account<PoolState> = anchor_lang::Accounts::try_accounts(
                            __program_id,
                            __accounts,
                            __ix_data,
                            __bumps,
                            __reallocs,
                        )
                        .map_err(|e| e.with_account_name("pool_state"))?;
                    let amm_config: anchor_lang::accounts::account::Account<AmmConfig> = anchor_lang::Accounts::try_accounts(
                            __program_id,
                            __accounts,
                            __ix_data,
                            __bumps,
                            __reallocs,
                        )
                        .map_err(|e| e.with_account_name("amm_config"))?;
                    let token_0_vault: Box<
                        anchor_lang::accounts::interface_account::InterfaceAccount<
                            TokenAccount,
                        >,
                    > = anchor_lang::Accounts::try_accounts(
                            __program_id,
                            __accounts,
                            __ix_data,
                            __bumps,
                            __reallocs,
                        )
                        .map_err(|e| e.with_account_name("token_0_vault"))?;
                    let token_1_vault: Box<
                        anchor_lang::accounts::interface_account::InterfaceAccount<
                            TokenAccount,
                        >,
                    > = anchor_lang::Accounts::try_accounts(
                            __program_id,
                            __accounts,
                            __ix_data,
                            __bumps,
                            __reallocs,
                        )
                        .map_err(|e| e.with_account_name("token_1_vault"))?;
                    let vault_0_mint: Box<
                        anchor_lang::accounts::interface_account::InterfaceAccount<Mint>,
                    > = Box::new({
                        if __accounts.is_empty() {
                            return Err(
                                anchor_lang::error::ErrorCode::AccountNotEnoughKeys.into(),
                            );
                        }
                        let __acc = &__accounts[0];
                        *__accounts = &__accounts[1..];
                        anchor_lang::accounts::interface_account::InterfaceAccount::try_from_with_token_program(
                                __acc,
                                &pool_state.token_0_program,
                            )
                            .map_err(|e| e.with_account_name("vault_0_mint"))?
                    });
                    let vault_1_mint: Box<
                        anchor_lang::accounts::interface_account::InterfaceAccount<Mint>,
                    > = Box::new({
                        if __accounts.is_empty() {
                            return Err(
                                anchor_lang::error::ErrorCode::AccountNotEnoughKeys.into(),
                            );
                        }
                        let __acc = &__accounts[0];
                        *__accounts = &__accounts[1..];
                        anchor_lang::accounts::interface_account::InterfaceAccount::try_from_with_token_program(
                                __acc,
                                &pool_state.token_1_program,
                            )
                            .map_err(|e| e.with_account_name("vault_1_mint"))?
                    });
                    let recipient_token_0_account: Box<
                        anchor_lang::accounts::interface_account::InterfaceAccount<
                            TokenAccount,
                        >,
                    > = anchor_lang::Accounts::try_accounts(
                            __program_id,
                            __accounts,
                            __ix_data,
                            __bumps,
                            __reallocs,
                        )
                        .map_err(|e| e.with_account_name("recipient_token_0_account"))?;
                    let recipient_token_1_account: Box<
                        anchor_lang::accounts::interface_account::InterfaceAccount<
                            TokenAccount,
                        >,
                    > = anchor_lang::Accounts::try_accounts(
                            __program_id,
                            __accounts,
                            __ix_data,
                            __bumps,
                            __reallocs,
                        )
                        .map_err(|e| e.with_account_name("recipient_token_1_account"))?;
                    let token_program: anchor_lang::accounts::program::Program<Token> = anchor_lang::Accounts::try_accounts(
                            __program_id,
                            __accounts,
                            __ix_data,
                            __bumps,
                            __reallocs,
                        )
                        .map_err(|e| e.with_account_name("token_program"))?;
                    let token_program_2022: anchor_lang::accounts::program::Program<
                        Token2022,
                    > = anchor_lang::Accounts::try_accounts(
                            __program_id,
                            __accounts,
                            __ix_data,
                            __bumps,
                            __reallocs,
                        )
                        .map_err(|e| e.with_account_name("token_program_2022"))?;
                    let compressed_token_program_cpi_authority: AccountInfo = anchor_lang::Accounts::try_accounts(
                            __program_id,
                            __accounts,
                            __ix_data,
                            __bumps,
                            __reallocs,
                        )
                        .map_err(|e| {
                            e.with_account_name("compressed_token_program_cpi_authority")
                        })?;
                    let compressed_token_program: AccountInfo = anchor_lang::Accounts::try_accounts(
                            __program_id,
                            __accounts,
                            __ix_data,
                            __bumps,
                            __reallocs,
                        )
                        .map_err(|e| e.with_account_name("compressed_token_program"))?;
                    let compressed_token_0_pool_pda: AccountInfo = anchor_lang::Accounts::try_accounts(
                            __program_id,
                            __accounts,
                            __ix_data,
                            __bumps,
                            __reallocs,
                        )
                        .map_err(|e| {
                            e.with_account_name("compressed_token_0_pool_pda")
                        })?;
                    let compressed_token_1_pool_pda: AccountInfo = anchor_lang::Accounts::try_accounts(
                            __program_id,
                            __accounts,
                            __ix_data,
                            __bumps,
                            __reallocs,
                        )
                        .map_err(|e| {
                            e.with_account_name("compressed_token_1_pool_pda")
                        })?;
                    if !((owner.key() == amm_config.fund_owner
                        || owner.key() == crate::admin::ID))
                    {
                        return Err(
                            anchor_lang::error::Error::from(ErrorCode::InvalidOwner)
                                .with_account_name("owner"),
                        );
                    }
                    let (__pda_address, __bump) = Pubkey::find_program_address(
                        &[crate::AUTH_SEED.as_bytes()],
                        &__program_id,
                    );
                    __bumps.authority = __bump;
                    if authority.key() != __pda_address {
                        return Err(
                            anchor_lang::error::Error::from(
                                    anchor_lang::error::ErrorCode::ConstraintSeeds,
                                )
                                .with_account_name("authority")
                                .with_pubkeys((authority.key(), __pda_address)),
                        );
                    }
                    if !AsRef::<AccountInfo>::as_ref(&pool_state).is_writable {
                        return Err(
                            anchor_lang::error::Error::from(
                                    anchor_lang::error::ErrorCode::ConstraintMut,
                                )
                                .with_account_name("pool_state"),
                        );
                    }
                    {
                        let actual = amm_config.key();
                        let expected = pool_state.amm_config;
                        if actual != expected {
                            return Err(
                                anchor_lang::error::Error::from(
                                        anchor_lang::error::ErrorCode::ConstraintAddress,
                                    )
                                    .with_account_name("amm_config")
                                    .with_pubkeys((actual, expected)),
                            );
                        }
                    }
                    if !AsRef::<AccountInfo>::as_ref(token_0_vault.as_ref()).is_writable
                    {
                        return Err(
                            anchor_lang::error::Error::from(
                                    anchor_lang::error::ErrorCode::ConstraintMut,
                                )
                                .with_account_name("token_0_vault"),
                        );
                    }
                    if !(token_0_vault.key() == pool_state.token_0_vault) {
                        return Err(
                            anchor_lang::error::Error::from(
                                    anchor_lang::error::ErrorCode::ConstraintRaw,
                                )
                                .with_account_name("token_0_vault"),
                        );
                    }
                    if !AsRef::<AccountInfo>::as_ref(token_1_vault.as_ref()).is_writable
                    {
                        return Err(
                            anchor_lang::error::Error::from(
                                    anchor_lang::error::ErrorCode::ConstraintMut,
                                )
                                .with_account_name("token_1_vault"),
                        );
                    }
                    if !(token_1_vault.key() == pool_state.token_1_vault) {
                        return Err(
                            anchor_lang::error::Error::from(
                                    anchor_lang::error::ErrorCode::ConstraintRaw,
                                )
                                .with_account_name("token_1_vault"),
                        );
                    }
                    {
                        let actual = vault_0_mint.key();
                        let expected = token_0_vault.mint;
                        if actual != expected {
                            return Err(
                                anchor_lang::error::Error::from(
                                        anchor_lang::error::ErrorCode::ConstraintAddress,
                                    )
                                    .with_account_name("vault_0_mint")
                                    .with_pubkeys((actual, expected)),
                            );
                        }
                    }
                    {
                        let __is_ctoken = pool_state.token_0_program
                            == anchor_lang::CTOKEN_ID;
                        if __is_ctoken {
                            if AsRef::<AccountInfo>::as_ref(vault_0_mint.as_ref()).owner
                                != &anchor_lang::solana_program::system_program::ID
                            {
                                return Err(
                                    anchor_lang::error::ErrorCode::ConstraintMintTokenProgram
                                        .into(),
                                );
                            }
                        } else {
                            if AsRef::<AccountInfo>::as_ref(vault_0_mint.as_ref()).owner
                                != &pool_state.token_0_program
                            {
                                return Err(
                                    anchor_lang::error::ErrorCode::ConstraintMintTokenProgram
                                        .into(),
                                );
                            }
                        }
                        if !__is_ctoken {}
                    }
                    {
                        let actual = vault_1_mint.key();
                        let expected = token_1_vault.mint;
                        if actual != expected {
                            return Err(
                                anchor_lang::error::Error::from(
                                        anchor_lang::error::ErrorCode::ConstraintAddress,
                                    )
                                    .with_account_name("vault_1_mint")
                                    .with_pubkeys((actual, expected)),
                            );
                        }
                    }
                    {
                        let __is_ctoken = pool_state.token_1_program
                            == anchor_lang::CTOKEN_ID;
                        if __is_ctoken {
                            if AsRef::<AccountInfo>::as_ref(vault_1_mint.as_ref()).owner
                                != &anchor_lang::solana_program::system_program::ID
                            {
                                return Err(
                                    anchor_lang::error::ErrorCode::ConstraintMintTokenProgram
                                        .into(),
                                );
                            }
                        } else {
                            if AsRef::<AccountInfo>::as_ref(vault_1_mint.as_ref()).owner
                                != &pool_state.token_1_program
                            {
                                return Err(
                                    anchor_lang::error::ErrorCode::ConstraintMintTokenProgram
                                        .into(),
                                );
                            }
                        }
                        if !__is_ctoken {}
                    }
                    if !AsRef::<AccountInfo>::as_ref(recipient_token_0_account.as_ref())
                        .is_writable
                    {
                        return Err(
                            anchor_lang::error::Error::from(
                                    anchor_lang::error::ErrorCode::ConstraintMut,
                                )
                                .with_account_name("recipient_token_0_account"),
                        );
                    }
                    if !AsRef::<AccountInfo>::as_ref(recipient_token_1_account.as_ref())
                        .is_writable
                    {
                        return Err(
                            anchor_lang::error::Error::from(
                                    anchor_lang::error::ErrorCode::ConstraintMut,
                                )
                                .with_account_name("recipient_token_1_account"),
                        );
                    }
                    if !&compressed_token_0_pool_pda.is_writable {
                        return Err(
                            anchor_lang::error::Error::from(
                                    anchor_lang::error::ErrorCode::ConstraintMut,
                                )
                                .with_account_name("compressed_token_0_pool_pda"),
                        );
                    }
                    if !&compressed_token_1_pool_pda.is_writable {
                        return Err(
                            anchor_lang::error::Error::from(
                                    anchor_lang::error::ErrorCode::ConstraintMut,
                                )
                                .with_account_name("compressed_token_1_pool_pda"),
                        );
                    }
                    Ok(CollectFundFee {
                        owner,
                        authority,
                        pool_state,
                        amm_config,
                        token_0_vault,
                        token_1_vault,
                        vault_0_mint,
                        vault_1_mint,
                        recipient_token_0_account,
                        recipient_token_1_account,
                        token_program,
                        token_program_2022,
                        compressed_token_program_cpi_authority,
                        compressed_token_program,
                        compressed_token_0_pool_pda,
                        compressed_token_1_pool_pda,
                    })
                }
            }
            #[automatically_derived]
            impl<'info> anchor_lang::ToAccountInfos<'info> for CollectFundFee<'info>
            where
                'info: 'info,
            {
                fn to_account_infos(
                    &self,
                ) -> Vec<anchor_lang::solana_program::account_info::AccountInfo<'info>> {
                    let mut account_infos = ::alloc::vec::Vec::new();
                    account_infos.extend(self.owner.to_account_infos());
                    account_infos.extend(self.authority.to_account_infos());
                    account_infos.extend(self.pool_state.to_account_infos());
                    account_infos.extend(self.amm_config.to_account_infos());
                    account_infos.extend(self.token_0_vault.to_account_infos());
                    account_infos.extend(self.token_1_vault.to_account_infos());
                    account_infos.extend(self.vault_0_mint.to_account_infos());
                    account_infos.extend(self.vault_1_mint.to_account_infos());
                    account_infos
                        .extend(self.recipient_token_0_account.to_account_infos());
                    account_infos
                        .extend(self.recipient_token_1_account.to_account_infos());
                    account_infos.extend(self.token_program.to_account_infos());
                    account_infos.extend(self.token_program_2022.to_account_infos());
                    account_infos
                        .extend(
                            self
                                .compressed_token_program_cpi_authority
                                .to_account_infos(),
                        );
                    account_infos
                        .extend(self.compressed_token_program.to_account_infos());
                    account_infos
                        .extend(self.compressed_token_0_pool_pda.to_account_infos());
                    account_infos
                        .extend(self.compressed_token_1_pool_pda.to_account_infos());
                    account_infos
                }
            }
            #[automatically_derived]
            impl<'info> anchor_lang::ToAccountMetas for CollectFundFee<'info> {
                fn to_account_metas(
                    &self,
                    is_signer: Option<bool>,
                ) -> Vec<anchor_lang::solana_program::instruction::AccountMeta> {
                    let mut account_metas = ::alloc::vec::Vec::new();
                    account_metas.extend(self.owner.to_account_metas(None));
                    account_metas.extend(self.authority.to_account_metas(None));
                    account_metas.extend(self.pool_state.to_account_metas(None));
                    account_metas.extend(self.amm_config.to_account_metas(None));
                    account_metas.extend(self.token_0_vault.to_account_metas(None));
                    account_metas.extend(self.token_1_vault.to_account_metas(None));
                    account_metas.extend(self.vault_0_mint.to_account_metas(None));
                    account_metas.extend(self.vault_1_mint.to_account_metas(None));
                    account_metas
                        .extend(self.recipient_token_0_account.to_account_metas(None));
                    account_metas
                        .extend(self.recipient_token_1_account.to_account_metas(None));
                    account_metas.extend(self.token_program.to_account_metas(None));
                    account_metas.extend(self.token_program_2022.to_account_metas(None));
                    account_metas
                        .extend(
                            self
                                .compressed_token_program_cpi_authority
                                .to_account_metas(None),
                        );
                    account_metas
                        .extend(self.compressed_token_program.to_account_metas(None));
                    account_metas
                        .extend(self.compressed_token_0_pool_pda.to_account_metas(None));
                    account_metas
                        .extend(self.compressed_token_1_pool_pda.to_account_metas(None));
                    account_metas
                }
            }
            #[automatically_derived]
            impl<'info> anchor_lang::AccountsFinalize<'info, CollectFundFeeBumps>
            for CollectFundFee<'info>
            where
                'info: 'info,
            {
                fn finalize(
                    &mut self,
                    program_id: &anchor_lang::solana_program::pubkey::Pubkey,
                    _remaining: &[anchor_lang::solana_program::account_info::AccountInfo<
                        'info,
                    >],
                    _ix_data: &[u8],
                    _bumps: &CollectFundFeeBumps,
                ) -> anchor_lang::Result<()> {
                    anchor_lang::AccountsFinalize::finalize(
                            &mut self.pool_state,
                            program_id,
                            _remaining,
                            _ix_data,
                            _bumps,
                        )
                        .map_err(|e| e.with_account_name("pool_state"))?;
                    anchor_lang::AccountsFinalize::finalize(
                            &mut self.amm_config,
                            program_id,
                            _remaining,
                            _ix_data,
                            _bumps,
                        )
                        .map_err(|e| e.with_account_name("amm_config"))?;
                    anchor_lang::AccountsFinalize::finalize(
                            &mut self.token_0_vault,
                            program_id,
                            _remaining,
                            _ix_data,
                            _bumps,
                        )
                        .map_err(|e| e.with_account_name("token_0_vault"))?;
                    anchor_lang::AccountsFinalize::finalize(
                            &mut self.token_1_vault,
                            program_id,
                            _remaining,
                            _ix_data,
                            _bumps,
                        )
                        .map_err(|e| e.with_account_name("token_1_vault"))?;
                    anchor_lang::AccountsFinalize::finalize(
                            &mut self.vault_0_mint,
                            program_id,
                            _remaining,
                            _ix_data,
                            _bumps,
                        )
                        .map_err(|e| e.with_account_name("vault_0_mint"))?;
                    anchor_lang::AccountsFinalize::finalize(
                            &mut self.vault_1_mint,
                            program_id,
                            _remaining,
                            _ix_data,
                            _bumps,
                        )
                        .map_err(|e| e.with_account_name("vault_1_mint"))?;
                    anchor_lang::AccountsFinalize::finalize(
                            &mut self.recipient_token_0_account,
                            program_id,
                            _remaining,
                            _ix_data,
                            _bumps,
                        )
                        .map_err(|e| e.with_account_name("recipient_token_0_account"))?;
                    anchor_lang::AccountsFinalize::finalize(
                            &mut self.recipient_token_1_account,
                            program_id,
                            _remaining,
                            _ix_data,
                            _bumps,
                        )
                        .map_err(|e| e.with_account_name("recipient_token_1_account"))?;
                    anchor_lang::AccountsFinalize::finalize(
                            &mut self.token_program,
                            program_id,
                            _remaining,
                            _ix_data,
                            _bumps,
                        )
                        .map_err(|e| e.with_account_name("token_program"))?;
                    anchor_lang::AccountsFinalize::finalize(
                            &mut self.token_program_2022,
                            program_id,
                            _remaining,
                            _ix_data,
                            _bumps,
                        )
                        .map_err(|e| e.with_account_name("token_program_2022"))?;
                    Ok(())
                }
            }
            #[automatically_derived]
            impl<'info> anchor_lang::AccountsExit<'info> for CollectFundFee<'info>
            where
                'info: 'info,
            {
                fn exit(
                    &self,
                    program_id: &anchor_lang::solana_program::pubkey::Pubkey,
                ) -> anchor_lang::Result<()> {
                    anchor_lang::AccountsExit::exit(&self.pool_state, program_id)
                        .map_err(|e| e.with_account_name("pool_state"))?;
                    anchor_lang::AccountsExit::exit(&self.token_0_vault, program_id)
                        .map_err(|e| e.with_account_name("token_0_vault"))?;
                    anchor_lang::AccountsExit::exit(&self.token_1_vault, program_id)
                        .map_err(|e| e.with_account_name("token_1_vault"))?;
                    anchor_lang::AccountsExit::exit(
                            &self.recipient_token_0_account,
                            program_id,
                        )
                        .map_err(|e| e.with_account_name("recipient_token_0_account"))?;
                    anchor_lang::AccountsExit::exit(
                            &self.recipient_token_1_account,
                            program_id,
                        )
                        .map_err(|e| e.with_account_name("recipient_token_1_account"))?;
                    anchor_lang::AccountsExit::exit(
                            &self.compressed_token_0_pool_pda,
                            program_id,
                        )
                        .map_err(|e| {
                            e.with_account_name("compressed_token_0_pool_pda")
                        })?;
                    anchor_lang::AccountsExit::exit(
                            &self.compressed_token_1_pool_pda,
                            program_id,
                        )
                        .map_err(|e| {
                            e.with_account_name("compressed_token_1_pool_pda")
                        })?;
                    Ok(())
                }
            }
            pub struct CollectFundFeeBumps {
                pub authority: u8,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for CollectFundFeeBumps {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field1_finish(
                        f,
                        "CollectFundFeeBumps",
                        "authority",
                        &&self.authority,
                    )
                }
            }
            #[automatically_derived]
            impl ::core::clone::Clone for CollectFundFeeBumps {
                #[inline]
                fn clone(&self) -> CollectFundFeeBumps {
                    CollectFundFeeBumps {
                        authority: ::core::clone::Clone::clone(&self.authority),
                    }
                }
            }
            impl Default for CollectFundFeeBumps {
                fn default() -> Self {
                    CollectFundFeeBumps {
                        authority: u8::MAX,
                    }
                }
            }
            impl<'info> anchor_lang::Bumps for CollectFundFee<'info>
            where
                'info: 'info,
            {
                type Bumps = CollectFundFeeBumps;
            }
            /// An internal, Anchor generated module. This is used (as an
            /// implementation detail), to generate a struct for a given
            /// `#[derive(Accounts)]` implementation, where each field is a Pubkey,
            /// instead of an `AccountInfo`. This is useful for clients that want
            /// to generate a list of accounts, without explicitly knowing the
            /// order all the fields should be in.
            ///
            /// To access the struct in this module, one should use the sibling
            /// `accounts` module (also generated), which re-exports this.
            pub(crate) mod __client_accounts_collect_fund_fee {
                use super::*;
                use anchor_lang::prelude::borsh;
                /// Generated client accounts for [`CollectFundFee`].
                pub struct CollectFundFee {
                    ///Only admin or fund_owner can collect fee now
                    pub owner: Pubkey,
                    pub authority: Pubkey,
                    ///Pool state stores accumulated protocol fee amount
                    pub pool_state: Pubkey,
                    ///Amm config account stores fund_owner
                    pub amm_config: Pubkey,
                    ///The address that holds pool tokens for token_0
                    pub token_0_vault: Pubkey,
                    ///The address that holds pool tokens for token_1
                    pub token_1_vault: Pubkey,
                    ///The mint of token_0 vault
                    pub vault_0_mint: Pubkey,
                    ///The mint of token_1 vault
                    pub vault_1_mint: Pubkey,
                    ///The address that receives the collected token_0 fund fees
                    pub recipient_token_0_account: Pubkey,
                    ///The address that receives the collected token_1 fund fees
                    pub recipient_token_1_account: Pubkey,
                    ///The SPL program to perform token transfers
                    pub token_program: Pubkey,
                    ///The SPL program 2022 to perform token transfers
                    pub token_program_2022: Pubkey,
                    pub compressed_token_program_cpi_authority: Pubkey,
                    pub compressed_token_program: Pubkey,
                    pub compressed_token_0_pool_pda: Pubkey,
                    pub compressed_token_1_pool_pda: Pubkey,
                }
                impl borsh::ser::BorshSerialize for CollectFundFee
                where
                    Pubkey: borsh::ser::BorshSerialize,
                    Pubkey: borsh::ser::BorshSerialize,
                    Pubkey: borsh::ser::BorshSerialize,
                    Pubkey: borsh::ser::BorshSerialize,
                    Pubkey: borsh::ser::BorshSerialize,
                    Pubkey: borsh::ser::BorshSerialize,
                    Pubkey: borsh::ser::BorshSerialize,
                    Pubkey: borsh::ser::BorshSerialize,
                    Pubkey: borsh::ser::BorshSerialize,
                    Pubkey: borsh::ser::BorshSerialize,
                    Pubkey: borsh::ser::BorshSerialize,
                    Pubkey: borsh::ser::BorshSerialize,
                    Pubkey: borsh::ser::BorshSerialize,
                    Pubkey: borsh::ser::BorshSerialize,
                    Pubkey: borsh::ser::BorshSerialize,
                    Pubkey: borsh::ser::BorshSerialize,
                {
                    fn serialize<W: borsh::maybestd::io::Write>(
                        &self,
                        writer: &mut W,
                    ) -> ::core::result::Result<(), borsh::maybestd::io::Error> {
                        borsh::BorshSerialize::serialize(&self.owner, writer)?;
                        borsh::BorshSerialize::serialize(&self.authority, writer)?;
                        borsh::BorshSerialize::serialize(&self.pool_state, writer)?;
                        borsh::BorshSerialize::serialize(&self.amm_config, writer)?;
                        borsh::BorshSerialize::serialize(&self.token_0_vault, writer)?;
                        borsh::BorshSerialize::serialize(&self.token_1_vault, writer)?;
                        borsh::BorshSerialize::serialize(&self.vault_0_mint, writer)?;
                        borsh::BorshSerialize::serialize(&self.vault_1_mint, writer)?;
                        borsh::BorshSerialize::serialize(
                            &self.recipient_token_0_account,
                            writer,
                        )?;
                        borsh::BorshSerialize::serialize(
                            &self.recipient_token_1_account,
                            writer,
                        )?;
                        borsh::BorshSerialize::serialize(&self.token_program, writer)?;
                        borsh::BorshSerialize::serialize(
                            &self.token_program_2022,
                            writer,
                        )?;
                        borsh::BorshSerialize::serialize(
                            &self.compressed_token_program_cpi_authority,
                            writer,
                        )?;
                        borsh::BorshSerialize::serialize(
                            &self.compressed_token_program,
                            writer,
                        )?;
                        borsh::BorshSerialize::serialize(
                            &self.compressed_token_0_pool_pda,
                            writer,
                        )?;
                        borsh::BorshSerialize::serialize(
                            &self.compressed_token_1_pool_pda,
                            writer,
                        )?;
                        Ok(())
                    }
                }
                impl anchor_lang::idl::build::IdlBuild for CollectFundFee {
                    fn create_type() -> Option<anchor_lang::idl::types::IdlTypeDef> {
                        Some(anchor_lang::idl::types::IdlTypeDef {
                            name: Self::get_full_path(),
                            docs: <[_]>::into_vec(
                                ::alloc::boxed::box_new([
                                    "Generated client accounts for [`CollectFundFee`].".into(),
                                ]),
                            ),
                            serialization: anchor_lang::idl::types::IdlSerialization::default(),
                            repr: None,
                            generics: ::alloc::vec::Vec::new(),
                            ty: anchor_lang::idl::types::IdlTypeDefTy::Struct {
                                fields: Some(
                                    anchor_lang::idl::types::IdlDefinedFields::Named(
                                        <[_]>::into_vec(
                                            ::alloc::boxed::box_new([
                                                anchor_lang::idl::types::IdlField {
                                                    name: "owner".into(),
                                                    docs: <[_]>::into_vec(
                                                        ::alloc::boxed::box_new([
                                                            "Only admin or fund_owner can collect fee now".into(),
                                                        ]),
                                                    ),
                                                    ty: anchor_lang::idl::types::IdlType::Pubkey,
                                                },
                                                anchor_lang::idl::types::IdlField {
                                                    name: "authority".into(),
                                                    docs: ::alloc::vec::Vec::new(),
                                                    ty: anchor_lang::idl::types::IdlType::Pubkey,
                                                },
                                                anchor_lang::idl::types::IdlField {
                                                    name: "pool_state".into(),
                                                    docs: <[_]>::into_vec(
                                                        ::alloc::boxed::box_new([
                                                            "Pool state stores accumulated protocol fee amount".into(),
                                                        ]),
                                                    ),
                                                    ty: anchor_lang::idl::types::IdlType::Pubkey,
                                                },
                                                anchor_lang::idl::types::IdlField {
                                                    name: "amm_config".into(),
                                                    docs: <[_]>::into_vec(
                                                        ::alloc::boxed::box_new([
                                                            "Amm config account stores fund_owner".into(),
                                                        ]),
                                                    ),
                                                    ty: anchor_lang::idl::types::IdlType::Pubkey,
                                                },
                                                anchor_lang::idl::types::IdlField {
                                                    name: "token_0_vault".into(),
                                                    docs: <[_]>::into_vec(
                                                        ::alloc::boxed::box_new([
                                                            "The address that holds pool tokens for token_0".into(),
                                                        ]),
                                                    ),
                                                    ty: anchor_lang::idl::types::IdlType::Pubkey,
                                                },
                                                anchor_lang::idl::types::IdlField {
                                                    name: "token_1_vault".into(),
                                                    docs: <[_]>::into_vec(
                                                        ::alloc::boxed::box_new([
                                                            "The address that holds pool tokens for token_1".into(),
                                                        ]),
                                                    ),
                                                    ty: anchor_lang::idl::types::IdlType::Pubkey,
                                                },
                                                anchor_lang::idl::types::IdlField {
                                                    name: "vault_0_mint".into(),
                                                    docs: <[_]>::into_vec(
                                                        ::alloc::boxed::box_new([
                                                            "The mint of token_0 vault".into(),
                                                        ]),
                                                    ),
                                                    ty: anchor_lang::idl::types::IdlType::Pubkey,
                                                },
                                                anchor_lang::idl::types::IdlField {
                                                    name: "vault_1_mint".into(),
                                                    docs: <[_]>::into_vec(
                                                        ::alloc::boxed::box_new([
                                                            "The mint of token_1 vault".into(),
                                                        ]),
                                                    ),
                                                    ty: anchor_lang::idl::types::IdlType::Pubkey,
                                                },
                                                anchor_lang::idl::types::IdlField {
                                                    name: "recipient_token_0_account".into(),
                                                    docs: <[_]>::into_vec(
                                                        ::alloc::boxed::box_new([
                                                            "The address that receives the collected token_0 fund fees"
                                                                .into(),
                                                        ]),
                                                    ),
                                                    ty: anchor_lang::idl::types::IdlType::Pubkey,
                                                },
                                                anchor_lang::idl::types::IdlField {
                                                    name: "recipient_token_1_account".into(),
                                                    docs: <[_]>::into_vec(
                                                        ::alloc::boxed::box_new([
                                                            "The address that receives the collected token_1 fund fees"
                                                                .into(),
                                                        ]),
                                                    ),
                                                    ty: anchor_lang::idl::types::IdlType::Pubkey,
                                                },
                                                anchor_lang::idl::types::IdlField {
                                                    name: "token_program".into(),
                                                    docs: <[_]>::into_vec(
                                                        ::alloc::boxed::box_new([
                                                            "The SPL program to perform token transfers".into(),
                                                        ]),
                                                    ),
                                                    ty: anchor_lang::idl::types::IdlType::Pubkey,
                                                },
                                                anchor_lang::idl::types::IdlField {
                                                    name: "token_program_2022".into(),
                                                    docs: <[_]>::into_vec(
                                                        ::alloc::boxed::box_new([
                                                            "The SPL program 2022 to perform token transfers".into(),
                                                        ]),
                                                    ),
                                                    ty: anchor_lang::idl::types::IdlType::Pubkey,
                                                },
                                                anchor_lang::idl::types::IdlField {
                                                    name: "compressed_token_program_cpi_authority".into(),
                                                    docs: ::alloc::vec::Vec::new(),
                                                    ty: anchor_lang::idl::types::IdlType::Pubkey,
                                                },
                                                anchor_lang::idl::types::IdlField {
                                                    name: "compressed_token_program".into(),
                                                    docs: ::alloc::vec::Vec::new(),
                                                    ty: anchor_lang::idl::types::IdlType::Pubkey,
                                                },
                                                anchor_lang::idl::types::IdlField {
                                                    name: "compressed_token_0_pool_pda".into(),
                                                    docs: ::alloc::vec::Vec::new(),
                                                    ty: anchor_lang::idl::types::IdlType::Pubkey,
                                                },
                                                anchor_lang::idl::types::IdlField {
                                                    name: "compressed_token_1_pool_pda".into(),
                                                    docs: ::alloc::vec::Vec::new(),
                                                    ty: anchor_lang::idl::types::IdlType::Pubkey,
                                                },
                                            ]),
                                        ),
                                    ),
                                ),
                            },
                        })
                    }
                    fn insert_types(
                        types: &mut std::collections::BTreeMap<
                            String,
                            anchor_lang::idl::types::IdlTypeDef,
                        >,
                    ) {}
                    fn get_full_path() -> String {
                        ::alloc::__export::must_use({
                            ::alloc::fmt::format(
                                format_args!(
                                    "{0}::{1}",
                                    "raydium_cp_swap::instructions::admin::collect_fund_fee::__client_accounts_collect_fund_fee",
                                    "CollectFundFee",
                                ),
                            )
                        })
                    }
                }
                #[automatically_derived]
                impl anchor_lang::ToAccountMetas for CollectFundFee {
                    fn to_account_metas(
                        &self,
                        is_signer: Option<bool>,
                    ) -> Vec<anchor_lang::solana_program::instruction::AccountMeta> {
                        let mut account_metas = ::alloc::vec::Vec::new();
                        account_metas
                            .push(
                                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                                    self.owner,
                                    true,
                                ),
                            );
                        account_metas
                            .push(
                                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                                    self.authority,
                                    false,
                                ),
                            );
                        account_metas
                            .push(
                                anchor_lang::solana_program::instruction::AccountMeta::new(
                                    self.pool_state,
                                    false,
                                ),
                            );
                        account_metas
                            .push(
                                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                                    self.amm_config,
                                    false,
                                ),
                            );
                        account_metas
                            .push(
                                anchor_lang::solana_program::instruction::AccountMeta::new(
                                    self.token_0_vault,
                                    false,
                                ),
                            );
                        account_metas
                            .push(
                                anchor_lang::solana_program::instruction::AccountMeta::new(
                                    self.token_1_vault,
                                    false,
                                ),
                            );
                        account_metas
                            .push(
                                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                                    self.vault_0_mint,
                                    false,
                                ),
                            );
                        account_metas
                            .push(
                                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                                    self.vault_1_mint,
                                    false,
                                ),
                            );
                        account_metas
                            .push(
                                anchor_lang::solana_program::instruction::AccountMeta::new(
                                    self.recipient_token_0_account,
                                    false,
                                ),
                            );
                        account_metas
                            .push(
                                anchor_lang::solana_program::instruction::AccountMeta::new(
                                    self.recipient_token_1_account,
                                    false,
                                ),
                            );
                        account_metas
                            .push(
                                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                                    self.token_program,
                                    false,
                                ),
                            );
                        account_metas
                            .push(
                                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                                    self.token_program_2022,
                                    false,
                                ),
                            );
                        account_metas
                            .push(
                                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                                    self.compressed_token_program_cpi_authority,
                                    false,
                                ),
                            );
                        account_metas
                            .push(
                                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                                    self.compressed_token_program,
                                    false,
                                ),
                            );
                        account_metas
                            .push(
                                anchor_lang::solana_program::instruction::AccountMeta::new(
                                    self.compressed_token_0_pool_pda,
                                    false,
                                ),
                            );
                        account_metas
                            .push(
                                anchor_lang::solana_program::instruction::AccountMeta::new(
                                    self.compressed_token_1_pool_pda,
                                    false,
                                ),
                            );
                        account_metas
                    }
                }
            }
            /// An internal, Anchor generated module. This is used (as an
            /// implementation detail), to generate a CPI struct for a given
            /// `#[derive(Accounts)]` implementation, where each field is an
            /// AccountInfo.
            ///
            /// To access the struct in this module, one should use the sibling
            /// [`cpi::accounts`] module (also generated), which re-exports this.
            pub(crate) mod __cpi_client_accounts_collect_fund_fee {
                use super::*;
                /// Generated CPI struct of the accounts for [`CollectFundFee`].
                pub struct CollectFundFee<'info> {
                    ///Only admin or fund_owner can collect fee now
                    pub owner: anchor_lang::solana_program::account_info::AccountInfo<
                        'info,
                    >,
                    pub authority: anchor_lang::solana_program::account_info::AccountInfo<
                        'info,
                    >,
                    ///Pool state stores accumulated protocol fee amount
                    pub pool_state: anchor_lang::solana_program::account_info::AccountInfo<
                        'info,
                    >,
                    ///Amm config account stores fund_owner
                    pub amm_config: anchor_lang::solana_program::account_info::AccountInfo<
                        'info,
                    >,
                    ///The address that holds pool tokens for token_0
                    pub token_0_vault: anchor_lang::solana_program::account_info::AccountInfo<
                        'info,
                    >,
                    ///The address that holds pool tokens for token_1
                    pub token_1_vault: anchor_lang::solana_program::account_info::AccountInfo<
                        'info,
                    >,
                    ///The mint of token_0 vault
                    pub vault_0_mint: anchor_lang::solana_program::account_info::AccountInfo<
                        'info,
                    >,
                    ///The mint of token_1 vault
                    pub vault_1_mint: anchor_lang::solana_program::account_info::AccountInfo<
                        'info,
                    >,
                    ///The address that receives the collected token_0 fund fees
                    pub recipient_token_0_account: anchor_lang::solana_program::account_info::AccountInfo<
                        'info,
                    >,
                    ///The address that receives the collected token_1 fund fees
                    pub recipient_token_1_account: anchor_lang::solana_program::account_info::AccountInfo<
                        'info,
                    >,
                    ///The SPL program to perform token transfers
                    pub token_program: anchor_lang::solana_program::account_info::AccountInfo<
                        'info,
                    >,
                    ///The SPL program 2022 to perform token transfers
                    pub token_program_2022: anchor_lang::solana_program::account_info::AccountInfo<
                        'info,
                    >,
                    pub compressed_token_program_cpi_authority: anchor_lang::solana_program::account_info::AccountInfo<
                        'info,
                    >,
                    pub compressed_token_program: anchor_lang::solana_program::account_info::AccountInfo<
                        'info,
                    >,
                    pub compressed_token_0_pool_pda: anchor_lang::solana_program::account_info::AccountInfo<
                        'info,
                    >,
                    pub compressed_token_1_pool_pda: anchor_lang::solana_program::account_info::AccountInfo<
                        'info,
                    >,
                }
                #[automatically_derived]
                impl<'info> anchor_lang::ToAccountMetas for CollectFundFee<'info> {
                    fn to_account_metas(
                        &self,
                        is_signer: Option<bool>,
                    ) -> Vec<anchor_lang::solana_program::instruction::AccountMeta> {
                        let mut account_metas = ::alloc::vec::Vec::new();
                        account_metas
                            .push(
                                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                                    anchor_lang::Key::key(&self.owner),
                                    true,
                                ),
                            );
                        account_metas
                            .push(
                                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                                    anchor_lang::Key::key(&self.authority),
                                    false,
                                ),
                            );
                        account_metas
                            .push(
                                anchor_lang::solana_program::instruction::AccountMeta::new(
                                    anchor_lang::Key::key(&self.pool_state),
                                    false,
                                ),
                            );
                        account_metas
                            .push(
                                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                                    anchor_lang::Key::key(&self.amm_config),
                                    false,
                                ),
                            );
                        account_metas
                            .push(
                                anchor_lang::solana_program::instruction::AccountMeta::new(
                                    anchor_lang::Key::key(&self.token_0_vault),
                                    false,
                                ),
                            );
                        account_metas
                            .push(
                                anchor_lang::solana_program::instruction::AccountMeta::new(
                                    anchor_lang::Key::key(&self.token_1_vault),
                                    false,
                                ),
                            );
                        account_metas
                            .push(
                                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                                    anchor_lang::Key::key(&self.vault_0_mint),
                                    false,
                                ),
                            );
                        account_metas
                            .push(
                                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                                    anchor_lang::Key::key(&self.vault_1_mint),
                                    false,
                                ),
                            );
                        account_metas
                            .push(
                                anchor_lang::solana_program::instruction::AccountMeta::new(
                                    anchor_lang::Key::key(&self.recipient_token_0_account),
                                    false,
                                ),
                            );
                        account_metas
                            .push(
                                anchor_lang::solana_program::instruction::AccountMeta::new(
                                    anchor_lang::Key::key(&self.recipient_token_1_account),
                                    false,
                                ),
                            );
                        account_metas
                            .push(
                                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                                    anchor_lang::Key::key(&self.token_program),
                                    false,
                                ),
                            );
                        account_metas
                            .push(
                                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                                    anchor_lang::Key::key(&self.token_program_2022),
                                    false,
                                ),
                            );
                        account_metas
                            .push(
                                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                                    anchor_lang::Key::key(
                                        &self.compressed_token_program_cpi_authority,
                                    ),
                                    false,
                                ),
                            );
                        account_metas
                            .push(
                                anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                                    anchor_lang::Key::key(&self.compressed_token_program),
                                    false,
                                ),
                            );
                        account_metas
                            .push(
                                anchor_lang::solana_program::instruction::AccountMeta::new(
                                    anchor_lang::Key::key(&self.compressed_token_0_pool_pda),
                                    false,
                                ),
                            );
                        account_metas
                            .push(
                                anchor_lang::solana_program::instruction::AccountMeta::new(
                                    anchor_lang::Key::key(&self.compressed_token_1_pool_pda),
                                    false,
                                ),
                            );
                        account_metas
                    }
                }
                #[automatically_derived]
                impl<'info> anchor_lang::ToAccountInfos<'info>
                for CollectFundFee<'info> {
                    fn to_account_infos(
                        &self,
                    ) -> Vec<
                        anchor_lang::solana_program::account_info::AccountInfo<'info>,
                    > {
                        let mut account_infos = ::alloc::vec::Vec::new();
                        account_infos
                            .extend(
                                anchor_lang::ToAccountInfos::to_account_infos(&self.owner),
                            );
                        account_infos
                            .extend(
                                anchor_lang::ToAccountInfos::to_account_infos(
                                    &self.authority,
                                ),
                            );
                        account_infos
                            .extend(
                                anchor_lang::ToAccountInfos::to_account_infos(
                                    &self.pool_state,
                                ),
                            );
                        account_infos
                            .extend(
                                anchor_lang::ToAccountInfos::to_account_infos(
                                    &self.amm_config,
                                ),
                            );
                        account_infos
                            .extend(
                                anchor_lang::ToAccountInfos::to_account_infos(
                                    &self.token_0_vault,
                                ),
                            );
                        account_infos
                            .extend(
                                anchor_lang::ToAccountInfos::to_account_infos(
                                    &self.token_1_vault,
                                ),
                            );
                        account_infos
                            .extend(
                                anchor_lang::ToAccountInfos::to_account_infos(
                                    &self.vault_0_mint,
                                ),
                            );
                        account_infos
                            .extend(
                                anchor_lang::ToAccountInfos::to_account_infos(
                                    &self.vault_1_mint,
                                ),
                            );
                        account_infos
                            .extend(
                                anchor_lang::ToAccountInfos::to_account_infos(
                                    &self.recipient_token_0_account,
                                ),
                            );
                        account_infos
                            .extend(
                                anchor_lang::ToAccountInfos::to_account_infos(
                                    &self.recipient_token_1_account,
                                ),
                            );
                        account_infos
                            .extend(
                                anchor_lang::ToAccountInfos::to_account_infos(
                                    &self.token_program,
                                ),
                            );
                        account_infos
                            .extend(
                                anchor_lang::ToAccountInfos::to_account_infos(
                                    &self.token_program_2022,
                                ),
                            );
                        account_infos
                            .extend(
                                anchor_lang::ToAccountInfos::to_account_infos(
                                    &self.compressed_token_program_cpi_authority,
                                ),
                            );
                        account_infos
                            .extend(
                                anchor_lang::ToAccountInfos::to_account_infos(
                                    &self.compressed_token_program,
                                ),
                            );
                        account_infos
                            .extend(
                                anchor_lang::ToAccountInfos::to_account_infos(
                                    &self.compressed_token_0_pool_pda,
                                ),
                            );
                        account_infos
                            .extend(
                                anchor_lang::ToAccountInfos::to_account_infos(
                                    &self.compressed_token_1_pool_pda,
                                ),
                            );
                        account_infos
                    }
                }
            }
            impl<'info> CollectFundFee<'info> {
                pub fn __anchor_private_gen_idl_accounts(
                    accounts: &mut std::collections::BTreeMap<
                        String,
                        anchor_lang::idl::types::IdlAccount,
                    >,
                    types: &mut std::collections::BTreeMap<
                        String,
                        anchor_lang::idl::types::IdlTypeDef,
                    >,
                ) -> Vec<anchor_lang::idl::types::IdlInstructionAccountItem> {
                    if let Some(ty) = <PoolState>::create_type() {
                        let account = anchor_lang::idl::types::IdlAccount {
                            name: ty.name.clone(),
                            discriminator: PoolState::DISCRIMINATOR.into(),
                        };
                        accounts.insert(account.name.clone(), account);
                        types.insert(ty.name.clone(), ty);
                        <PoolState>::insert_types(types);
                    }
                    if let Some(ty) = <AmmConfig>::create_type() {
                        let account = anchor_lang::idl::types::IdlAccount {
                            name: ty.name.clone(),
                            discriminator: AmmConfig::DISCRIMINATOR.into(),
                        };
                        accounts.insert(account.name.clone(), account);
                        types.insert(ty.name.clone(), ty);
                        <AmmConfig>::insert_types(types);
                    }
                    if let Some(ty) = <TokenAccount>::create_type() {
                        let account = anchor_lang::idl::types::IdlAccount {
                            name: ty.name.clone(),
                            discriminator: TokenAccount::DISCRIMINATOR.into(),
                        };
                        accounts.insert(account.name.clone(), account);
                        types.insert(ty.name.clone(), ty);
                        <TokenAccount>::insert_types(types);
                    }
                    if let Some(ty) = <TokenAccount>::create_type() {
                        let account = anchor_lang::idl::types::IdlAccount {
                            name: ty.name.clone(),
                            discriminator: TokenAccount::DISCRIMINATOR.into(),
                        };
                        accounts.insert(account.name.clone(), account);
                        types.insert(ty.name.clone(), ty);
                        <TokenAccount>::insert_types(types);
                    }
                    if let Some(ty) = <Mint>::create_type() {
                        let account = anchor_lang::idl::types::IdlAccount {
                            name: ty.name.clone(),
                            discriminator: Mint::DISCRIMINATOR.into(),
                        };
                        accounts.insert(account.name.clone(), account);
                        types.insert(ty.name.clone(), ty);
                        <Mint>::insert_types(types);
                    }
                    if let Some(ty) = <Mint>::create_type() {
                        let account = anchor_lang::idl::types::IdlAccount {
                            name: ty.name.clone(),
                            discriminator: Mint::DISCRIMINATOR.into(),
                        };
                        accounts.insert(account.name.clone(), account);
                        types.insert(ty.name.clone(), ty);
                        <Mint>::insert_types(types);
                    }
                    if let Some(ty) = <TokenAccount>::create_type() {
                        let account = anchor_lang::idl::types::IdlAccount {
                            name: ty.name.clone(),
                            discriminator: TokenAccount::DISCRIMINATOR.into(),
                        };
                        accounts.insert(account.name.clone(), account);
                        types.insert(ty.name.clone(), ty);
                        <TokenAccount>::insert_types(types);
                    }
                    if let Some(ty) = <TokenAccount>::create_type() {
                        let account = anchor_lang::idl::types::IdlAccount {
                            name: ty.name.clone(),
                            discriminator: TokenAccount::DISCRIMINATOR.into(),
                        };
                        accounts.insert(account.name.clone(), account);
                        types.insert(ty.name.clone(), ty);
                        <TokenAccount>::insert_types(types);
                    }
                    <[_]>::into_vec(
                        ::alloc::boxed::box_new([
                            anchor_lang::idl::types::IdlInstructionAccountItem::Single(anchor_lang::idl::types::IdlInstructionAccount {
                                name: "owner".into(),
                                docs: <[_]>::into_vec(
                                    ::alloc::boxed::box_new([
                                        "Only admin or fund_owner can collect fee now".into(),
                                    ]),
                                ),
                                writable: false,
                                signer: true,
                                optional: false,
                                address: None,
                                pda: None,
                                relations: ::alloc::vec::Vec::new(),
                            }),
                            anchor_lang::idl::types::IdlInstructionAccountItem::Single(anchor_lang::idl::types::IdlInstructionAccount {
                                name: "authority".into(),
                                docs: ::alloc::vec::Vec::new(),
                                writable: false,
                                signer: false,
                                optional: false,
                                address: None,
                                pda: None,
                                relations: ::alloc::vec::Vec::new(),
                            }),
                            anchor_lang::idl::types::IdlInstructionAccountItem::Single(anchor_lang::idl::types::IdlInstructionAccount {
                                name: "pool_state".into(),
                                docs: <[_]>::into_vec(
                                    ::alloc::boxed::box_new([
                                        "Pool state stores accumulated protocol fee amount".into(),
                                    ]),
                                ),
                                writable: true,
                                signer: false,
                                optional: false,
                                address: None,
                                pda: None,
                                relations: ::alloc::vec::Vec::new(),
                            }),
                            anchor_lang::idl::types::IdlInstructionAccountItem::Single(anchor_lang::idl::types::IdlInstructionAccount {
                                name: "amm_config".into(),
                                docs: <[_]>::into_vec(
                                    ::alloc::boxed::box_new([
                                        "Amm config account stores fund_owner".into(),
                                    ]),
                                ),
                                writable: false,
                                signer: false,
                                optional: false,
                                address: None,
                                pda: None,
                                relations: ::alloc::vec::Vec::new(),
                            }),
                            anchor_lang::idl::types::IdlInstructionAccountItem::Single(anchor_lang::idl::types::IdlInstructionAccount {
                                name: "token_0_vault".into(),
                                docs: <[_]>::into_vec(
                                    ::alloc::boxed::box_new([
                                        "The address that holds pool tokens for token_0".into(),
                                    ]),
                                ),
                                writable: true,
                                signer: false,
                                optional: false,
                                address: None,
                                pda: None,
                                relations: ::alloc::vec::Vec::new(),
                            }),
                            anchor_lang::idl::types::IdlInstructionAccountItem::Single(anchor_lang::idl::types::IdlInstructionAccount {
                                name: "token_1_vault".into(),
                                docs: <[_]>::into_vec(
                                    ::alloc::boxed::box_new([
                                        "The address that holds pool tokens for token_1".into(),
                                    ]),
                                ),
                                writable: true,
                                signer: false,
                                optional: false,
                                address: None,
                                pda: None,
                                relations: ::alloc::vec::Vec::new(),
                            }),
                            anchor_lang::idl::types::IdlInstructionAccountItem::Single(anchor_lang::idl::types::IdlInstructionAccount {
                                name: "vault_0_mint".into(),
                                docs: <[_]>::into_vec(
                                    ::alloc::boxed::box_new([
                                        "The mint of token_0 vault".into(),
                                    ]),
                                ),
                                writable: false,
                                signer: false,
                                optional: false,
                                address: None,
                                pda: None,
                                relations: ::alloc::vec::Vec::new(),
                            }),
                            anchor_lang::idl::types::IdlInstructionAccountItem::Single(anchor_lang::idl::types::IdlInstructionAccount {
                                name: "vault_1_mint".into(),
                                docs: <[_]>::into_vec(
                                    ::alloc::boxed::box_new([
                                        "The mint of token_1 vault".into(),
                                    ]),
                                ),
                                writable: false,
                                signer: false,
                                optional: false,
                                address: None,
                                pda: None,
                                relations: ::alloc::vec::Vec::new(),
                            }),
                            anchor_lang::idl::types::IdlInstructionAccountItem::Single(anchor_lang::idl::types::IdlInstructionAccount {
                                name: "recipient_token_0_account".into(),
                                docs: <[_]>::into_vec(
                                    ::alloc::boxed::box_new([
                                        "The address that receives the collected token_0 fund fees"
                                            .into(),
                                    ]),
                                ),
                                writable: true,
                                signer: false,
                                optional: false,
                                address: None,
                                pda: None,
                                relations: ::alloc::vec::Vec::new(),
                            }),
                            anchor_lang::idl::types::IdlInstructionAccountItem::Single(anchor_lang::idl::types::IdlInstructionAccount {
                                name: "recipient_token_1_account".into(),
                                docs: <[_]>::into_vec(
                                    ::alloc::boxed::box_new([
                                        "The address that receives the collected token_1 fund fees"
                                            .into(),
                                    ]),
                                ),
                                writable: true,
                                signer: false,
                                optional: false,
                                address: None,
                                pda: None,
                                relations: ::alloc::vec::Vec::new(),
                            }),
                            anchor_lang::idl::types::IdlInstructionAccountItem::Single(anchor_lang::idl::types::IdlInstructionAccount {
                                name: "token_program".into(),
                                docs: <[_]>::into_vec(
                                    ::alloc::boxed::box_new([
                                        "The SPL program to perform token transfers".into(),
                                    ]),
                                ),
                                writable: false,
                                signer: false,
                                optional: false,
                                address: None,
                                pda: None,
                                relations: ::alloc::vec::Vec::new(),
                            }),
                            anchor_lang::idl::types::IdlInstructionAccountItem::Single(anchor_lang::idl::types::IdlInstructionAccount {
                                name: "token_program_2022".into(),
                                docs: <[_]>::into_vec(
                                    ::alloc::boxed::box_new([
                                        "The SPL program 2022 to perform token transfers".into(),
                                    ]),
                                ),
                                writable: false,
                                signer: false,
                                optional: false,
                                address: None,
                                pda: None,
                                relations: ::alloc::vec::Vec::new(),
                            }),
                            anchor_lang::idl::types::IdlInstructionAccountItem::Single(anchor_lang::idl::types::IdlInstructionAccount {
                                name: "compressed_token_program_cpi_authority".into(),
                                docs: ::alloc::vec::Vec::new(),
                                writable: false,
                                signer: false,
                                optional: false,
                                address: None,
                                pda: None,
                                relations: ::alloc::vec::Vec::new(),
                            }),
                            anchor_lang::idl::types::IdlInstructionAccountItem::Single(anchor_lang::idl::types::IdlInstructionAccount {
                                name: "compressed_token_program".into(),
                                docs: ::alloc::vec::Vec::new(),
                                writable: false,
                                signer: false,
                                optional: false,
                                address: None,
                                pda: None,
                                relations: ::alloc::vec::Vec::new(),
                            }),
                            anchor_lang::idl::types::IdlInstructionAccountItem::Single(anchor_lang::idl::types::IdlInstructionAccount {
                                name: "compressed_token_0_pool_pda".into(),
                                docs: ::alloc::vec::Vec::new(),
                                writable: true,
                                signer: false,
                                optional: false,
                                address: None,
                                pda: None,
                                relations: ::alloc::vec::Vec::new(),
                            }),
                            anchor_lang::idl::types::IdlInstructionAccountItem::Single(anchor_lang::idl::types::IdlInstructionAccount {
                                name: "compressed_token_1_pool_pda".into(),
                                docs: ::alloc::vec::Vec::new(),
                                writable: true,
                                signer: false,
                                optional: false,
                                address: None,
                                pda: None,
                                relations: ::alloc::vec::Vec::new(),
                            }),
                        ]),
                    )
                }
                pub fn __anchor_private_gen_light_metadata() -> Option<
                    anchor_lang::idl::types::IdlLightInstructionMeta,
                > {
                    Some(anchor_lang::idl::types::IdlLightInstructionMeta {
                        ctokens: None,
                        cpdas: Some(
                            <[_]>::into_vec(
                                ::alloc::boxed::box_new([
                                    anchor_lang::idl::types::IdlLightCpdaUsage {
                                        account: "pool_state".to_string(),
                                        ty: "PoolState".to_string(),
                                    },
                                ]),
                            ),
                        ),
                    })
                }
            }
            pub fn collect_fund_fee(
                ctx: Context<CollectFundFee>,
                amount_0_requested: u64,
                amount_1_requested: u64,
            ) -> Result<()> {
                let amount_0: u64;
                let amount_1: u64;
                let auth_bump: u8;
                {
                    let pool_state = &mut ctx.accounts.pool_state;
                    amount_0 = amount_0_requested.min(pool_state.fund_fees_token_0);
                    amount_1 = amount_1_requested.min(pool_state.fund_fees_token_1);
                    pool_state.fund_fees_token_0 = pool_state
                        .fund_fees_token_0
                        .checked_sub(amount_0)
                        .unwrap();
                    pool_state.fund_fees_token_1 = pool_state
                        .fund_fees_token_1
                        .checked_sub(amount_1)
                        .unwrap();
                    auth_bump = pool_state.auth_bump;
                    pool_state.recent_epoch = Clock::get()?.epoch;
                }
                let (compressed_token_0_pool_bump, compressed_token_1_pool_bump) = get_bumps(
                    ctx.accounts.vault_0_mint.key(),
                    ctx.accounts.vault_1_mint.key(),
                    ctx.accounts.compressed_token_program.key(),
                );
                transfer_from_pool_vault_to_user(
                    ctx.accounts.owner.to_account_info(),
                    ctx.accounts.authority.to_account_info(),
                    ctx.accounts.token_0_vault.to_account_info(),
                    ctx.accounts.recipient_token_0_account.to_account_info(),
                    Some(ctx.accounts.vault_0_mint.to_account_info()),
                    Some(
                        if ctx.accounts.vault_0_mint.to_account_info().owner
                            == ctx.accounts.token_program.key
                        {
                            ctx.accounts.token_program.to_account_info()
                        } else {
                            ctx.accounts.token_program_2022.to_account_info()
                        },
                    ),
                    Some(ctx.accounts.compressed_token_0_pool_pda.to_account_info()),
                    Some(compressed_token_0_pool_bump),
                    ctx
                        .accounts
                        .compressed_token_program_cpi_authority
                        .to_account_info(),
                    amount_0,
                    &[&[crate::AUTH_SEED.as_bytes(), &[auth_bump]]],
                )?;
                transfer_from_pool_vault_to_user(
                    ctx.accounts.owner.to_account_info(),
                    ctx.accounts.authority.to_account_info(),
                    ctx.accounts.token_1_vault.to_account_info(),
                    ctx.accounts.recipient_token_1_account.to_account_info(),
                    Some(ctx.accounts.vault_1_mint.to_account_info()),
                    Some(
                        if ctx.accounts.vault_1_mint.to_account_info().owner
                            == ctx.accounts.token_program.key
                        {
                            ctx.accounts.token_program.to_account_info()
                        } else {
                            ctx.accounts.token_program_2022.to_account_info()
                        },
                    ),
                    Some(ctx.accounts.compressed_token_1_pool_pda.to_account_info()),
                    Some(compressed_token_1_pool_bump),
                    ctx
                        .accounts
                        .compressed_token_program_cpi_authority
                        .to_account_info(),
                    amount_1,
                    &[&[crate::AUTH_SEED.as_bytes(), &[auth_bump]]],
                )?;
                Ok(())
            }
        }
        pub use collect_fund_fee::*;
    }
    pub use admin::*;
    pub mod swap_base_output {
        use super::swap_base_input::Swap;
        use crate::curve::{calculator::CurveCalculator, TradeDirection};
        use crate::error::ErrorCode;
        use crate::states::*;
        use crate::utils::ctoken::get_bumps;
        use crate::utils::token::*;
        use anchor_lang::prelude::*;
        use anchor_lang::solana_program;
        use light_sdk::compressible::HasCompressionInfo;
        pub fn swap_base_output(
            ctx: Context<Swap>,
            max_amount_in: u64,
            amount_out_less_fee: u64,
        ) -> Result<()> {
            if amount_out_less_fee <= 0 {
                return Err(
                    anchor_lang::error::Error::from(anchor_lang::error::AnchorError {
                            error_name: anchor_lang::error::ErrorCode::RequireGtViolated
                                .name(),
                            error_code_number: anchor_lang::error::ErrorCode::RequireGtViolated
                                .into(),
                            error_msg: anchor_lang::error::ErrorCode::RequireGtViolated
                                .to_string(),
                            error_origin: Some(
                                anchor_lang::error::ErrorOrigin::Source(anchor_lang::error::Source {
                                    filename: "programs/cp-swap/src/instructions/swap_base_output.rs",
                                    line: 16u32,
                                }),
                            ),
                            compared_values: None,
                        })
                        .with_values((amount_out_less_fee, 0)),
                );
            }
            let block_timestamp = solana_program::clock::Clock::get()?.unix_timestamp
                as u64;
            let pool_id = ctx.accounts.pool_state.key();
            let pool_state = &mut ctx.accounts.pool_state;
            if !pool_state.get_status_by_bit(PoolStatusBitIndex::Swap)
                || block_timestamp < pool_state.open_time
            {
                return Err(
                    anchor_lang::error::Error::from(anchor_lang::error::AnchorError {
                        error_name: ErrorCode::NotApproved.name(),
                        error_code_number: ErrorCode::NotApproved.into(),
                        error_msg: ErrorCode::NotApproved.to_string(),
                        error_origin: Some(
                            anchor_lang::error::ErrorOrigin::Source(anchor_lang::error::Source {
                                filename: "programs/cp-swap/src/instructions/swap_base_output.rs",
                                line: 23u32,
                            }),
                        ),
                        compared_values: None,
                    }),
                );
            }
            let out_transfer_fee = get_transfer_inverse_fee(
                &ctx.accounts.output_token_mint.to_account_info(),
                amount_out_less_fee,
            )?;
            let actual_amount_out = amount_out_less_fee
                .checked_add(out_transfer_fee)
                .unwrap();
            let (
                trade_direction,
                total_input_token_amount,
                total_output_token_amount,
                token_0_price_x64,
                token_1_price_x64,
            ) = if ctx.accounts.input_vault.key() == pool_state.token_0_vault
                && ctx.accounts.output_vault.key() == pool_state.token_1_vault
            {
                let (total_input_token_amount, total_output_token_amount) = pool_state
                    .vault_amount_without_fee(
                        ctx.accounts.input_vault.amount,
                        ctx.accounts.output_vault.amount,
                    );
                let (token_0_price_x64, token_1_price_x64) = pool_state
                    .token_price_x32(
                        ctx.accounts.input_vault.amount,
                        ctx.accounts.output_vault.amount,
                    );
                (
                    TradeDirection::ZeroForOne,
                    total_input_token_amount,
                    total_output_token_amount,
                    token_0_price_x64,
                    token_1_price_x64,
                )
            } else if ctx.accounts.input_vault.key() == pool_state.token_1_vault
                && ctx.accounts.output_vault.key() == pool_state.token_0_vault
            {
                let (total_output_token_amount, total_input_token_amount) = pool_state
                    .vault_amount_without_fee(
                        ctx.accounts.output_vault.amount,
                        ctx.accounts.input_vault.amount,
                    );
                let (token_0_price_x64, token_1_price_x64) = pool_state
                    .token_price_x32(
                        ctx.accounts.output_vault.amount,
                        ctx.accounts.input_vault.amount,
                    );
                (
                    TradeDirection::OneForZero,
                    total_input_token_amount,
                    total_output_token_amount,
                    token_0_price_x64,
                    token_1_price_x64,
                )
            } else {
                return Err(
                    anchor_lang::error::Error::from(anchor_lang::error::AnchorError {
                        error_name: ErrorCode::InvalidVault.name(),
                        error_code_number: ErrorCode::InvalidVault.into(),
                        error_msg: ErrorCode::InvalidVault.to_string(),
                        error_origin: Some(
                            anchor_lang::error::ErrorOrigin::Source(anchor_lang::error::Source {
                                filename: "programs/cp-swap/src/instructions/swap_base_output.rs",
                                line: 79u32,
                            }),
                        ),
                        compared_values: None,
                    }),
                );
            };
            let constant_before = u128::from(total_input_token_amount)
                .checked_mul(u128::from(total_output_token_amount))
                .unwrap();
            let result = CurveCalculator::swap_base_output(
                    u128::from(actual_amount_out),
                    u128::from(total_input_token_amount),
                    u128::from(total_output_token_amount),
                    ctx.accounts.amm_config.trade_fee_rate,
                    ctx.accounts.amm_config.protocol_fee_rate,
                    ctx.accounts.amm_config.fund_fee_rate,
                )
                .ok_or(ErrorCode::ZeroTradingTokens)?;
            let constant_after = u128::from(
                    result.new_swap_source_amount.checked_sub(result.trade_fee).unwrap(),
                )
                .checked_mul(u128::from(result.new_swap_destination_amount))
                .unwrap();
            let (input_transfer_amount, input_transfer_fee) = {
                let source_amount_swapped = u64::try_from(result.source_amount_swapped)
                    .unwrap();
                if source_amount_swapped <= 0 {
                    return Err(
                        anchor_lang::error::Error::from(anchor_lang::error::AnchorError {
                                error_name: anchor_lang::error::ErrorCode::RequireGtViolated
                                    .name(),
                                error_code_number: anchor_lang::error::ErrorCode::RequireGtViolated
                                    .into(),
                                error_msg: anchor_lang::error::ErrorCode::RequireGtViolated
                                    .to_string(),
                                error_origin: Some(
                                    anchor_lang::error::ErrorOrigin::Source(anchor_lang::error::Source {
                                        filename: "programs/cp-swap/src/instructions/swap_base_output.rs",
                                        line: 117u32,
                                    }),
                                ),
                                compared_values: None,
                            })
                            .with_values((source_amount_swapped, 0)),
                    );
                }
                let transfer_fee = get_transfer_inverse_fee(
                    &ctx.accounts.input_token_mint.to_account_info(),
                    source_amount_swapped,
                )?;
                let input_transfer_amount = source_amount_swapped
                    .checked_add(transfer_fee)
                    .unwrap();
                if max_amount_in < input_transfer_amount {
                    return Err(
                        anchor_lang::error::Error::from(anchor_lang::error::AnchorError {
                                error_name: ErrorCode::ExceededSlippage.name(),
                                error_code_number: ErrorCode::ExceededSlippage.into(),
                                error_msg: ErrorCode::ExceededSlippage.to_string(),
                                error_origin: Some(
                                    anchor_lang::error::ErrorOrigin::Source(anchor_lang::error::Source {
                                        filename: "programs/cp-swap/src/instructions/swap_base_output.rs",
                                        line: 123u32,
                                    }),
                                ),
                                compared_values: None,
                            })
                            .with_values((max_amount_in, input_transfer_amount)),
                    );
                }
                (input_transfer_amount, transfer_fee)
            };
            if u64::try_from(result.destination_amount_swapped).unwrap()
                != actual_amount_out
            {
                return Err(
                    anchor_lang::error::Error::from(anchor_lang::error::AnchorError {
                            error_name: anchor_lang::error::ErrorCode::RequireEqViolated
                                .name(),
                            error_code_number: anchor_lang::error::ErrorCode::RequireEqViolated
                                .into(),
                            error_msg: anchor_lang::error::ErrorCode::RequireEqViolated
                                .to_string(),
                            error_origin: Some(
                                anchor_lang::error::ErrorOrigin::Source(anchor_lang::error::Source {
                                    filename: "programs/cp-swap/src/instructions/swap_base_output.rs",
                                    line: 130u32,
                                }),
                            ),
                            compared_values: None,
                        })
                        .with_values((
                            u64::try_from(result.destination_amount_swapped).unwrap(),
                            actual_amount_out,
                        )),
                );
            }
            let (output_transfer_amount, output_transfer_fee) = (
                actual_amount_out,
                out_transfer_fee,
            );
            let protocol_fee = u64::try_from(result.protocol_fee).unwrap();
            let fund_fee = u64::try_from(result.fund_fee).unwrap();
            match trade_direction {
                TradeDirection::ZeroForOne => {
                    pool_state.protocol_fees_token_0 = pool_state
                        .protocol_fees_token_0
                        .checked_add(protocol_fee)
                        .unwrap();
                    pool_state.fund_fees_token_0 = pool_state
                        .fund_fees_token_0
                        .checked_add(fund_fee)
                        .unwrap();
                }
                TradeDirection::OneForZero => {
                    pool_state.protocol_fees_token_1 = pool_state
                        .protocol_fees_token_1
                        .checked_add(protocol_fee)
                        .unwrap();
                    pool_state.fund_fees_token_1 = pool_state
                        .fund_fees_token_1
                        .checked_add(fund_fee)
                        .unwrap();
                }
            };
            {
                anchor_lang::solana_program::log::sol_log_data(
                    &[
                        &anchor_lang::Event::data(
                            &SwapEvent {
                                pool_id,
                                input_vault_before: total_input_token_amount,
                                output_vault_before: total_output_token_amount,
                                input_amount: u64::try_from(result.source_amount_swapped)
                                    .unwrap(),
                                output_amount: u64::try_from(
                                        result.destination_amount_swapped,
                                    )
                                    .unwrap(),
                                input_transfer_fee,
                                output_transfer_fee,
                                base_input: false,
                            },
                        ),
                    ],
                );
            };
            if constant_after < constant_before {
                return Err(
                    anchor_lang::error::Error::from(anchor_lang::error::AnchorError {
                            error_name: anchor_lang::error::ErrorCode::RequireGteViolated
                                .name(),
                            error_code_number: anchor_lang::error::ErrorCode::RequireGteViolated
                                .into(),
                            error_msg: anchor_lang::error::ErrorCode::RequireGteViolated
                                .to_string(),
                            error_origin: Some(
                                anchor_lang::error::ErrorOrigin::Source(anchor_lang::error::Source {
                                    filename: "programs/cp-swap/src/instructions/swap_base_output.rs",
                                    line: 168u32,
                                }),
                            ),
                            compared_values: None,
                        })
                        .with_values((constant_after, constant_before)),
                );
            }
            let (compressed_token_0_pool_bump, compressed_token_1_pool_bump) = get_bumps(
                ctx.accounts.input_token_mint.key(),
                ctx.accounts.output_token_mint.key(),
                ctx.accounts.compressed_token_program.key(),
            );
            transfer_from_user_to_pool_vault(
                ctx.accounts.payer.to_account_info(),
                ctx.accounts.input_token_account.to_account_info(),
                ctx.accounts.input_vault.to_account_info(),
                Some(ctx.accounts.input_token_mint.to_account_info()),
                Some(ctx.accounts.input_token_program.to_account_info()),
                Some(ctx.accounts.compressed_token_0_pool_pda.to_account_info()),
                Some(compressed_token_0_pool_bump),
                ctx.accounts.compressed_token_program_cpi_authority.to_account_info(),
                input_transfer_amount,
            )?;
            transfer_from_pool_vault_to_user(
                ctx.accounts.payer.to_account_info(),
                ctx.accounts.authority.to_account_info(),
                ctx.accounts.output_vault.to_account_info(),
                ctx.accounts.output_token_account.to_account_info(),
                Some(ctx.accounts.output_token_mint.to_account_info()),
                Some(ctx.accounts.output_token_program.to_account_info()),
                Some(ctx.accounts.compressed_token_1_pool_pda.to_account_info()),
                Some(compressed_token_1_pool_bump),
                ctx.accounts.compressed_token_program_cpi_authority.to_account_info(),
                output_transfer_amount,
                &[&[crate::AUTH_SEED.as_bytes(), &[pool_state.auth_bump]]],
            )?;
            ctx.accounts
                .observation_state
                .update(oracle::block_timestamp(), token_0_price_x64, token_1_price_x64);
            pool_state.recent_epoch = Clock::get()?.epoch;
            pool_state.compression_info_mut().bump_last_written_slot()?;
            Ok(())
        }
    }
    pub use swap_base_output::*;
}
pub mod states {
    pub mod config {
        use anchor_lang::prelude::*;
        pub const AMM_CONFIG_SEED: &str = "amm_config";
        /// Holds the current owner of the factory
        pub struct AmmConfig {
            /// Bump to identify PDA
            pub bump: u8,
            /// Status to control if new pool can be create
            pub disable_create_pool: bool,
            /// Config index
            pub index: u16,
            /// The trade fee, denominated in hundredths of a bip (10^-6)
            pub trade_fee_rate: u64,
            /// The protocol fee
            pub protocol_fee_rate: u64,
            /// The fund fee, denominated in hundredths of a bip (10^-6)
            pub fund_fee_rate: u64,
            /// Fee for create a new pool
            pub create_pool_fee: u64,
            /// Address of the protocol fee owner
            pub protocol_owner: Pubkey,
            /// Address of the fund fee owner
            pub fund_owner: Pubkey,
            /// padding
            pub padding: [u64; 16],
        }
        #[automatically_derived]
        impl ::core::default::Default for AmmConfig {
            #[inline]
            fn default() -> AmmConfig {
                AmmConfig {
                    bump: ::core::default::Default::default(),
                    disable_create_pool: ::core::default::Default::default(),
                    index: ::core::default::Default::default(),
                    trade_fee_rate: ::core::default::Default::default(),
                    protocol_fee_rate: ::core::default::Default::default(),
                    fund_fee_rate: ::core::default::Default::default(),
                    create_pool_fee: ::core::default::Default::default(),
                    protocol_owner: ::core::default::Default::default(),
                    fund_owner: ::core::default::Default::default(),
                    padding: ::core::default::Default::default(),
                }
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for AmmConfig {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                let names: &'static _ = &[
                    "bump",
                    "disable_create_pool",
                    "index",
                    "trade_fee_rate",
                    "protocol_fee_rate",
                    "fund_fee_rate",
                    "create_pool_fee",
                    "protocol_owner",
                    "fund_owner",
                    "padding",
                ];
                let values: &[&dyn ::core::fmt::Debug] = &[
                    &self.bump,
                    &self.disable_create_pool,
                    &self.index,
                    &self.trade_fee_rate,
                    &self.protocol_fee_rate,
                    &self.fund_fee_rate,
                    &self.create_pool_fee,
                    &self.protocol_owner,
                    &self.fund_owner,
                    &&self.padding,
                ];
                ::core::fmt::Formatter::debug_struct_fields_finish(
                    f,
                    "AmmConfig",
                    names,
                    values,
                )
            }
        }
        impl borsh::ser::BorshSerialize for AmmConfig
        where
            u8: borsh::ser::BorshSerialize,
            bool: borsh::ser::BorshSerialize,
            u16: borsh::ser::BorshSerialize,
            u64: borsh::ser::BorshSerialize,
            u64: borsh::ser::BorshSerialize,
            u64: borsh::ser::BorshSerialize,
            u64: borsh::ser::BorshSerialize,
            Pubkey: borsh::ser::BorshSerialize,
            Pubkey: borsh::ser::BorshSerialize,
            [u64; 16]: borsh::ser::BorshSerialize,
        {
            fn serialize<W: borsh::maybestd::io::Write>(
                &self,
                writer: &mut W,
            ) -> ::core::result::Result<(), borsh::maybestd::io::Error> {
                borsh::BorshSerialize::serialize(&self.bump, writer)?;
                borsh::BorshSerialize::serialize(&self.disable_create_pool, writer)?;
                borsh::BorshSerialize::serialize(&self.index, writer)?;
                borsh::BorshSerialize::serialize(&self.trade_fee_rate, writer)?;
                borsh::BorshSerialize::serialize(&self.protocol_fee_rate, writer)?;
                borsh::BorshSerialize::serialize(&self.fund_fee_rate, writer)?;
                borsh::BorshSerialize::serialize(&self.create_pool_fee, writer)?;
                borsh::BorshSerialize::serialize(&self.protocol_owner, writer)?;
                borsh::BorshSerialize::serialize(&self.fund_owner, writer)?;
                borsh::BorshSerialize::serialize(&self.padding, writer)?;
                Ok(())
            }
        }
        impl anchor_lang::idl::build::IdlBuild for AmmConfig {
            fn create_type() -> Option<anchor_lang::idl::types::IdlTypeDef> {
                Some(anchor_lang::idl::types::IdlTypeDef {
                    name: Self::get_full_path(),
                    docs: <[_]>::into_vec(
                        ::alloc::boxed::box_new([
                            "Holds the current owner of the factory".into(),
                        ]),
                    ),
                    serialization: anchor_lang::idl::types::IdlSerialization::default(),
                    repr: None,
                    generics: ::alloc::vec::Vec::new(),
                    ty: anchor_lang::idl::types::IdlTypeDefTy::Struct {
                        fields: Some(
                            anchor_lang::idl::types::IdlDefinedFields::Named(
                                <[_]>::into_vec(
                                    ::alloc::boxed::box_new([
                                        anchor_lang::idl::types::IdlField {
                                            name: "bump".into(),
                                            docs: <[_]>::into_vec(
                                                ::alloc::boxed::box_new(["Bump to identify PDA".into()]),
                                            ),
                                            ty: anchor_lang::idl::types::IdlType::U8,
                                        },
                                        anchor_lang::idl::types::IdlField {
                                            name: "disable_create_pool".into(),
                                            docs: <[_]>::into_vec(
                                                ::alloc::boxed::box_new([
                                                    "Status to control if new pool can be create".into(),
                                                ]),
                                            ),
                                            ty: anchor_lang::idl::types::IdlType::Bool,
                                        },
                                        anchor_lang::idl::types::IdlField {
                                            name: "index".into(),
                                            docs: <[_]>::into_vec(
                                                ::alloc::boxed::box_new(["Config index".into()]),
                                            ),
                                            ty: anchor_lang::idl::types::IdlType::U16,
                                        },
                                        anchor_lang::idl::types::IdlField {
                                            name: "trade_fee_rate".into(),
                                            docs: <[_]>::into_vec(
                                                ::alloc::boxed::box_new([
                                                    "The trade fee, denominated in hundredths of a bip (10^-6)"
                                                        .into(),
                                                ]),
                                            ),
                                            ty: anchor_lang::idl::types::IdlType::U64,
                                        },
                                        anchor_lang::idl::types::IdlField {
                                            name: "protocol_fee_rate".into(),
                                            docs: <[_]>::into_vec(
                                                ::alloc::boxed::box_new(["The protocol fee".into()]),
                                            ),
                                            ty: anchor_lang::idl::types::IdlType::U64,
                                        },
                                        anchor_lang::idl::types::IdlField {
                                            name: "fund_fee_rate".into(),
                                            docs: <[_]>::into_vec(
                                                ::alloc::boxed::box_new([
                                                    "The fund fee, denominated in hundredths of a bip (10^-6)"
                                                        .into(),
                                                ]),
                                            ),
                                            ty: anchor_lang::idl::types::IdlType::U64,
                                        },
                                        anchor_lang::idl::types::IdlField {
                                            name: "create_pool_fee".into(),
                                            docs: <[_]>::into_vec(
                                                ::alloc::boxed::box_new([
                                                    "Fee for create a new pool".into(),
                                                ]),
                                            ),
                                            ty: anchor_lang::idl::types::IdlType::U64,
                                        },
                                        anchor_lang::idl::types::IdlField {
                                            name: "protocol_owner".into(),
                                            docs: <[_]>::into_vec(
                                                ::alloc::boxed::box_new([
                                                    "Address of the protocol fee owner".into(),
                                                ]),
                                            ),
                                            ty: anchor_lang::idl::types::IdlType::Pubkey,
                                        },
                                        anchor_lang::idl::types::IdlField {
                                            name: "fund_owner".into(),
                                            docs: <[_]>::into_vec(
                                                ::alloc::boxed::box_new([
                                                    "Address of the fund fee owner".into(),
                                                ]),
                                            ),
                                            ty: anchor_lang::idl::types::IdlType::Pubkey,
                                        },
                                        anchor_lang::idl::types::IdlField {
                                            name: "padding".into(),
                                            docs: <[_]>::into_vec(
                                                ::alloc::boxed::box_new(["padding".into()]),
                                            ),
                                            ty: anchor_lang::idl::types::IdlType::Array(
                                                Box::new(anchor_lang::idl::types::IdlType::U64),
                                                anchor_lang::idl::types::IdlArrayLen::Value(16),
                                            ),
                                        },
                                    ]),
                                ),
                            ),
                        ),
                    },
                })
            }
            fn insert_types(
                types: &mut std::collections::BTreeMap<
                    String,
                    anchor_lang::idl::types::IdlTypeDef,
                >,
            ) {}
            fn get_full_path() -> String {
                ::alloc::__export::must_use({
                    ::alloc::fmt::format(
                        format_args!(
                            "{0}::{1}",
                            "raydium_cp_swap::states::config",
                            "AmmConfig",
                        ),
                    )
                })
            }
        }
        impl borsh::de::BorshDeserialize for AmmConfig
        where
            u8: borsh::BorshDeserialize,
            bool: borsh::BorshDeserialize,
            u16: borsh::BorshDeserialize,
            u64: borsh::BorshDeserialize,
            u64: borsh::BorshDeserialize,
            u64: borsh::BorshDeserialize,
            u64: borsh::BorshDeserialize,
            Pubkey: borsh::BorshDeserialize,
            Pubkey: borsh::BorshDeserialize,
            [u64; 16]: borsh::BorshDeserialize,
        {
            fn deserialize_reader<R: borsh::maybestd::io::Read>(
                reader: &mut R,
            ) -> ::core::result::Result<Self, borsh::maybestd::io::Error> {
                Ok(Self {
                    bump: borsh::BorshDeserialize::deserialize_reader(reader)?,
                    disable_create_pool: borsh::BorshDeserialize::deserialize_reader(
                        reader,
                    )?,
                    index: borsh::BorshDeserialize::deserialize_reader(reader)?,
                    trade_fee_rate: borsh::BorshDeserialize::deserialize_reader(reader)?,
                    protocol_fee_rate: borsh::BorshDeserialize::deserialize_reader(
                        reader,
                    )?,
                    fund_fee_rate: borsh::BorshDeserialize::deserialize_reader(reader)?,
                    create_pool_fee: borsh::BorshDeserialize::deserialize_reader(
                        reader,
                    )?,
                    protocol_owner: borsh::BorshDeserialize::deserialize_reader(reader)?,
                    fund_owner: borsh::BorshDeserialize::deserialize_reader(reader)?,
                    padding: borsh::BorshDeserialize::deserialize_reader(reader)?,
                })
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for AmmConfig {
            #[inline]
            fn clone(&self) -> AmmConfig {
                AmmConfig {
                    bump: ::core::clone::Clone::clone(&self.bump),
                    disable_create_pool: ::core::clone::Clone::clone(
                        &self.disable_create_pool,
                    ),
                    index: ::core::clone::Clone::clone(&self.index),
                    trade_fee_rate: ::core::clone::Clone::clone(&self.trade_fee_rate),
                    protocol_fee_rate: ::core::clone::Clone::clone(
                        &self.protocol_fee_rate,
                    ),
                    fund_fee_rate: ::core::clone::Clone::clone(&self.fund_fee_rate),
                    create_pool_fee: ::core::clone::Clone::clone(&self.create_pool_fee),
                    protocol_owner: ::core::clone::Clone::clone(&self.protocol_owner),
                    fund_owner: ::core::clone::Clone::clone(&self.fund_owner),
                    padding: ::core::clone::Clone::clone(&self.padding),
                }
            }
        }
        #[automatically_derived]
        impl anchor_lang::AccountSerialize for AmmConfig {
            fn try_serialize<W: std::io::Write>(
                &self,
                writer: &mut W,
            ) -> anchor_lang::Result<()> {
                if writer.write_all(AmmConfig::DISCRIMINATOR).is_err() {
                    return Err(
                        anchor_lang::error::ErrorCode::AccountDidNotSerialize.into(),
                    );
                }
                if AnchorSerialize::serialize(self, writer).is_err() {
                    return Err(
                        anchor_lang::error::ErrorCode::AccountDidNotSerialize.into(),
                    );
                }
                Ok(())
            }
        }
        #[automatically_derived]
        impl anchor_lang::AccountDeserialize for AmmConfig {
            fn try_deserialize(buf: &mut &[u8]) -> anchor_lang::Result<Self> {
                if buf.len() < AmmConfig::DISCRIMINATOR.len() {
                    return Err(
                        anchor_lang::error::ErrorCode::AccountDiscriminatorNotFound
                            .into(),
                    );
                }
                let given_disc = &buf[..AmmConfig::DISCRIMINATOR.len()];
                if AmmConfig::DISCRIMINATOR != given_disc {
                    return Err(
                        anchor_lang::error::Error::from(anchor_lang::error::AnchorError {
                                error_name: anchor_lang::error::ErrorCode::AccountDiscriminatorMismatch
                                    .name(),
                                error_code_number: anchor_lang::error::ErrorCode::AccountDiscriminatorMismatch
                                    .into(),
                                error_msg: anchor_lang::error::ErrorCode::AccountDiscriminatorMismatch
                                    .to_string(),
                                error_origin: Some(
                                    anchor_lang::error::ErrorOrigin::Source(anchor_lang::error::Source {
                                        filename: "programs/cp-swap/src/states/config.rs",
                                        line: 6u32,
                                    }),
                                ),
                                compared_values: None,
                            })
                            .with_account_name("AmmConfig"),
                    );
                }
                Self::try_deserialize_unchecked(buf)
            }
            fn try_deserialize_unchecked(buf: &mut &[u8]) -> anchor_lang::Result<Self> {
                let mut data: &[u8] = &buf[AmmConfig::DISCRIMINATOR.len()..];
                AnchorDeserialize::deserialize(&mut data)
                    .map_err(|_| {
                        anchor_lang::error::ErrorCode::AccountDidNotDeserialize.into()
                    })
            }
        }
        #[automatically_derived]
        impl anchor_lang::Discriminator for AmmConfig {
            const DISCRIMINATOR: &'static [u8] = &[218, 244, 33, 104, 203, 203, 43, 111];
        }
        #[automatically_derived]
        impl anchor_lang::Owner for AmmConfig {
            fn owner() -> Pubkey {
                crate::ID
            }
        }
        impl AmmConfig {
            pub const LEN: usize = 8 + 1 + 1 + 2 + 4 * 8 + 32 * 2 + 8 * 16;
        }
    }
    pub use config::*;
    pub mod pool {
        use anchor_lang::prelude::*;
        use anchor_spl::token_interface::Mint;
        use light_sdk::{
            compressible::CompressionInfo, sha::LightHasher, CompressiblePack,
            LightDiscriminator,
        };
        use light_sdk_macros::Compressible;
        use std::ops::{BitAnd, BitOr, BitXor};
        /// Seed to derive account address and signature
        pub const POOL_SEED: &str = "pool";
        pub const POOL_LP_MINT_SEED: &str = "pool_lp_mint";
        pub const POOL_VAULT_SEED: &str = "pool_vault";
        pub const Q32: u128 = (u32::MAX as u128) + 1;
        pub enum PoolStatusBitIndex {
            Deposit,
            Withdraw,
            Swap,
        }
        pub enum PoolStatusBitFlag {
            Enable,
            Disable,
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for PoolStatusBitFlag {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for PoolStatusBitFlag {
            #[inline]
            fn eq(&self, other: &PoolStatusBitFlag) -> bool {
                let __self_discr = ::core::intrinsics::discriminant_value(self);
                let __arg1_discr = ::core::intrinsics::discriminant_value(other);
                __self_discr == __arg1_discr
            }
        }
        #[automatically_derived]
        impl ::core::cmp::Eq for PoolStatusBitFlag {
            #[inline]
            #[doc(hidden)]
            #[coverage(off)]
            fn assert_receiver_is_total_eq(&self) -> () {}
        }
        /// Tip: The 'Compressible' macro derives compress/decompress methods for the
        /// account. CompressionInfo tracks the last_written_slot. Whenever a
        /// compressible account is written to, last_written_slot must be updated. If
        /// last_written_slot >= threshold (compression_delay), the account becomes
        /// eligible for compression. Eligible accounts can be compressed
        /// asynchronously.
        #[repr(C)]
        pub struct PoolState {
            /// Which config the pool belongs
            pub amm_config: Pubkey,
            /// pool creator
            pub pool_creator: Pubkey,
            /// Token A
            pub token_0_vault: Pubkey,
            /// Token B
            pub token_1_vault: Pubkey,
            /// Pool tokens are issued when A or B tokens are deposited.
            /// Pool tokens can be withdrawn back to the original A or B token.
            pub lp_mint: Pubkey,
            /// Holds all LP tokens. Compressible.
            pub lp_vault: Pubkey,
            /// Mint information for token A
            pub token_0_mint: Pubkey,
            /// Mint information for token B
            pub token_1_mint: Pubkey,
            /// token_0 program
            pub token_0_program: Pubkey,
            /// token_1 program
            pub token_1_program: Pubkey,
            /// observation account to store oracle data
            pub observation_key: Pubkey,
            pub auth_bump: u8,
            /// Bitwise representation of the state of the pool
            /// bit0, 1: disable deposit(value is 1), 0: normal
            /// bit1, 1: disable withdraw(value is 2), 0: normal
            /// bit2, 1: disable swap(value is 4), 0: normal
            pub status: u8,
            pub lp_mint_decimals: u8,
            /// mint0 and mint1 decimals
            pub mint_0_decimals: u8,
            pub mint_1_decimals: u8,
            /// True circulating supply without burns and lock ups
            pub lp_supply: u64,
            /// The amounts of token_0 and token_1 that are owed to the liquidity provider.
            pub protocol_fees_token_0: u64,
            pub protocol_fees_token_1: u64,
            pub fund_fees_token_0: u64,
            pub fund_fees_token_1: u64,
            /// The timestamp allowed for swap in the pool.
            pub open_time: u64,
            /// recent epoch
            pub recent_epoch: u64,
            /// #[skip] is required. Is Some when the account is decompressed and None
            /// when compressed.
            #[skip]
            pub compression_info: Option<CompressionInfo>,
            /// padding for future updates
            pub padding: [u64; 1],
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for PoolState {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                let names: &'static _ = &[
                    "amm_config",
                    "pool_creator",
                    "token_0_vault",
                    "token_1_vault",
                    "lp_mint",
                    "lp_vault",
                    "token_0_mint",
                    "token_1_mint",
                    "token_0_program",
                    "token_1_program",
                    "observation_key",
                    "auth_bump",
                    "status",
                    "lp_mint_decimals",
                    "mint_0_decimals",
                    "mint_1_decimals",
                    "lp_supply",
                    "protocol_fees_token_0",
                    "protocol_fees_token_1",
                    "fund_fees_token_0",
                    "fund_fees_token_1",
                    "open_time",
                    "recent_epoch",
                    "compression_info",
                    "padding",
                ];
                let values: &[&dyn ::core::fmt::Debug] = &[
                    &self.amm_config,
                    &self.pool_creator,
                    &self.token_0_vault,
                    &self.token_1_vault,
                    &self.lp_mint,
                    &self.lp_vault,
                    &self.token_0_mint,
                    &self.token_1_mint,
                    &self.token_0_program,
                    &self.token_1_program,
                    &self.observation_key,
                    &self.auth_bump,
                    &self.status,
                    &self.lp_mint_decimals,
                    &self.mint_0_decimals,
                    &self.mint_1_decimals,
                    &self.lp_supply,
                    &self.protocol_fees_token_0,
                    &self.protocol_fees_token_1,
                    &self.fund_fees_token_0,
                    &self.fund_fees_token_1,
                    &self.open_time,
                    &self.recent_epoch,
                    &self.compression_info,
                    &&self.padding,
                ];
                ::core::fmt::Formatter::debug_struct_fields_finish(
                    f,
                    "PoolState",
                    names,
                    values,
                )
            }
        }
        impl ::light_hasher::to_byte_array::ToByteArray for PoolState {
            const NUM_FIELDS: usize = 25usize;
            fn to_byte_array(
                &self,
            ) -> ::std::result::Result<[u8; 32], ::light_hasher::HasherError> {
                use borsh::BorshSerialize;
                use ::light_hasher::Hasher;
                let serialized = self
                    .try_to_vec()
                    .map_err(|_| ::light_hasher::HasherError::BorshError)?;
                let mut result = ::light_hasher::Sha256::hash(&serialized)?;
                result[0] = 0;
                Ok(result)
            }
        }
        impl ::light_hasher::DataHasher for PoolState {
            fn hash<H>(
                &self,
            ) -> ::std::result::Result<[u8; 32], ::light_hasher::HasherError>
            where
                H: ::light_hasher::Hasher,
            {
                use ::light_hasher::Hasher;
                use borsh::BorshSerialize;
                let serialized = self
                    .try_to_vec()
                    .map_err(|_| ::light_hasher::HasherError::BorshError)?;
                let mut result = H::hash(&serialized)?;
                if H::ID != 0 {
                    result[0] = 0;
                }
                Ok(result)
            }
        }
        impl LightDiscriminator for PoolState {
            const LIGHT_DISCRIMINATOR: [u8; 8] = [247, 237, 227, 245, 215, 195, 222, 70];
            const LIGHT_DISCRIMINATOR_SLICE: &'static [u8] = &Self::LIGHT_DISCRIMINATOR;
            fn discriminator() -> [u8; 8] {
                Self::LIGHT_DISCRIMINATOR
            }
        }
        #[automatically_derived]
        impl ::core::default::Default for PoolState {
            #[inline]
            fn default() -> PoolState {
                PoolState {
                    amm_config: ::core::default::Default::default(),
                    pool_creator: ::core::default::Default::default(),
                    token_0_vault: ::core::default::Default::default(),
                    token_1_vault: ::core::default::Default::default(),
                    lp_mint: ::core::default::Default::default(),
                    lp_vault: ::core::default::Default::default(),
                    token_0_mint: ::core::default::Default::default(),
                    token_1_mint: ::core::default::Default::default(),
                    token_0_program: ::core::default::Default::default(),
                    token_1_program: ::core::default::Default::default(),
                    observation_key: ::core::default::Default::default(),
                    auth_bump: ::core::default::Default::default(),
                    status: ::core::default::Default::default(),
                    lp_mint_decimals: ::core::default::Default::default(),
                    mint_0_decimals: ::core::default::Default::default(),
                    mint_1_decimals: ::core::default::Default::default(),
                    lp_supply: ::core::default::Default::default(),
                    protocol_fees_token_0: ::core::default::Default::default(),
                    protocol_fees_token_1: ::core::default::Default::default(),
                    fund_fees_token_0: ::core::default::Default::default(),
                    fund_fees_token_1: ::core::default::Default::default(),
                    open_time: ::core::default::Default::default(),
                    recent_epoch: ::core::default::Default::default(),
                    compression_info: ::core::default::Default::default(),
                    padding: ::core::default::Default::default(),
                }
            }
        }
        #[automatically_derived]
        impl anchor_lang::Space for PoolState {
            const INIT_SPACE: usize = 0 + 32 + 32 + 32 + 32 + 32 + 32 + 32 + 32 + 32 + 32
                + 32 + 1 + 1 + 1 + 1 + 1 + 8 + 8 + 8 + 8 + 8 + 8 + 8
                + (1 + <CompressionInfo as anchor_lang::Space>::INIT_SPACE) + (1 * 8);
        }
        impl light_sdk::compressible::HasCompressionInfo for PoolState {
            fn compression_info(&self) -> &light_sdk::compressible::CompressionInfo {
                self.compression_info
                    .as_ref()
                    .expect("CompressionInfo must be Some on-chain")
            }
            fn compression_info_mut(
                &mut self,
            ) -> &mut light_sdk::compressible::CompressionInfo {
                self.compression_info
                    .as_mut()
                    .expect("CompressionInfo must be Some on-chain")
            }
            fn compression_info_mut_opt(
                &mut self,
            ) -> &mut Option<light_sdk::compressible::CompressionInfo> {
                &mut self.compression_info
            }
            fn set_compression_info_none(&mut self) {
                self.compression_info = None;
            }
        }
        impl light_sdk::account::Size for PoolState {
            fn size(&self) -> usize {
                Self::LIGHT_DISCRIMINATOR.len() + Self::INIT_SPACE
            }
        }
        impl light_sdk::compressible::CompressAs for PoolState {
            type Output = Self;
            fn compress_as(&self) -> std::borrow::Cow<'_, Self::Output> {
                std::borrow::Cow::Owned(Self {
                    amm_config: self.amm_config,
                    pool_creator: self.pool_creator,
                    token_0_vault: self.token_0_vault,
                    token_1_vault: self.token_1_vault,
                    lp_mint: self.lp_mint,
                    lp_vault: self.lp_vault,
                    token_0_mint: self.token_0_mint,
                    token_1_mint: self.token_1_mint,
                    token_0_program: self.token_0_program,
                    token_1_program: self.token_1_program,
                    observation_key: self.observation_key,
                    auth_bump: self.auth_bump,
                    status: self.status,
                    lp_mint_decimals: self.lp_mint_decimals,
                    mint_0_decimals: self.mint_0_decimals,
                    mint_1_decimals: self.mint_1_decimals,
                    lp_supply: self.lp_supply,
                    protocol_fees_token_0: self.protocol_fees_token_0,
                    protocol_fees_token_1: self.protocol_fees_token_1,
                    fund_fees_token_0: self.fund_fees_token_0,
                    fund_fees_token_1: self.fund_fees_token_1,
                    open_time: self.open_time,
                    recent_epoch: self.recent_epoch,
                    compression_info: None,
                    padding: self.padding.clone(),
                })
            }
        }
        impl light_sdk::compressible::compression_info::CompressedInitSpace
        for PoolState {
            const COMPRESSED_INIT_SPACE: usize = Self::INIT_SPACE
                - (0 + <CompressionInfo>::INIT_SPACE);
        }
        pub struct PackedPoolState {
            pub amm_config: u8,
            pub pool_creator: u8,
            pub token_0_vault: u8,
            pub token_1_vault: u8,
            pub lp_mint: u8,
            pub lp_vault: u8,
            pub token_0_mint: u8,
            pub token_1_mint: u8,
            pub token_0_program: u8,
            pub token_1_program: u8,
            pub observation_key: u8,
            pub auth_bump: u8,
            pub status: u8,
            pub lp_mint_decimals: u8,
            pub mint_0_decimals: u8,
            pub mint_1_decimals: u8,
            pub lp_supply: u64,
            pub protocol_fees_token_0: u64,
            pub protocol_fees_token_1: u64,
            pub fund_fees_token_0: u64,
            pub fund_fees_token_1: u64,
            pub open_time: u64,
            pub recent_epoch: u64,
            pub compression_info: Option<CompressionInfo>,
            pub padding: [u64; 1],
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for PackedPoolState {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                let names: &'static _ = &[
                    "amm_config",
                    "pool_creator",
                    "token_0_vault",
                    "token_1_vault",
                    "lp_mint",
                    "lp_vault",
                    "token_0_mint",
                    "token_1_mint",
                    "token_0_program",
                    "token_1_program",
                    "observation_key",
                    "auth_bump",
                    "status",
                    "lp_mint_decimals",
                    "mint_0_decimals",
                    "mint_1_decimals",
                    "lp_supply",
                    "protocol_fees_token_0",
                    "protocol_fees_token_1",
                    "fund_fees_token_0",
                    "fund_fees_token_1",
                    "open_time",
                    "recent_epoch",
                    "compression_info",
                    "padding",
                ];
                let values: &[&dyn ::core::fmt::Debug] = &[
                    &self.amm_config,
                    &self.pool_creator,
                    &self.token_0_vault,
                    &self.token_1_vault,
                    &self.lp_mint,
                    &self.lp_vault,
                    &self.token_0_mint,
                    &self.token_1_mint,
                    &self.token_0_program,
                    &self.token_1_program,
                    &self.observation_key,
                    &self.auth_bump,
                    &self.status,
                    &self.lp_mint_decimals,
                    &self.mint_0_decimals,
                    &self.mint_1_decimals,
                    &self.lp_supply,
                    &self.protocol_fees_token_0,
                    &self.protocol_fees_token_1,
                    &self.fund_fees_token_0,
                    &self.fund_fees_token_1,
                    &self.open_time,
                    &self.recent_epoch,
                    &self.compression_info,
                    &&self.padding,
                ];
                ::core::fmt::Formatter::debug_struct_fields_finish(
                    f,
                    "PackedPoolState",
                    names,
                    values,
                )
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for PackedPoolState {
            #[inline]
            fn clone(&self) -> PackedPoolState {
                PackedPoolState {
                    amm_config: ::core::clone::Clone::clone(&self.amm_config),
                    pool_creator: ::core::clone::Clone::clone(&self.pool_creator),
                    token_0_vault: ::core::clone::Clone::clone(&self.token_0_vault),
                    token_1_vault: ::core::clone::Clone::clone(&self.token_1_vault),
                    lp_mint: ::core::clone::Clone::clone(&self.lp_mint),
                    lp_vault: ::core::clone::Clone::clone(&self.lp_vault),
                    token_0_mint: ::core::clone::Clone::clone(&self.token_0_mint),
                    token_1_mint: ::core::clone::Clone::clone(&self.token_1_mint),
                    token_0_program: ::core::clone::Clone::clone(&self.token_0_program),
                    token_1_program: ::core::clone::Clone::clone(&self.token_1_program),
                    observation_key: ::core::clone::Clone::clone(&self.observation_key),
                    auth_bump: ::core::clone::Clone::clone(&self.auth_bump),
                    status: ::core::clone::Clone::clone(&self.status),
                    lp_mint_decimals: ::core::clone::Clone::clone(
                        &self.lp_mint_decimals,
                    ),
                    mint_0_decimals: ::core::clone::Clone::clone(&self.mint_0_decimals),
                    mint_1_decimals: ::core::clone::Clone::clone(&self.mint_1_decimals),
                    lp_supply: ::core::clone::Clone::clone(&self.lp_supply),
                    protocol_fees_token_0: ::core::clone::Clone::clone(
                        &self.protocol_fees_token_0,
                    ),
                    protocol_fees_token_1: ::core::clone::Clone::clone(
                        &self.protocol_fees_token_1,
                    ),
                    fund_fees_token_0: ::core::clone::Clone::clone(
                        &self.fund_fees_token_0,
                    ),
                    fund_fees_token_1: ::core::clone::Clone::clone(
                        &self.fund_fees_token_1,
                    ),
                    open_time: ::core::clone::Clone::clone(&self.open_time),
                    recent_epoch: ::core::clone::Clone::clone(&self.recent_epoch),
                    compression_info: ::core::clone::Clone::clone(
                        &self.compression_info,
                    ),
                    padding: ::core::clone::Clone::clone(&self.padding),
                }
            }
        }
        impl borsh::ser::BorshSerialize for PackedPoolState
        where
            u8: borsh::ser::BorshSerialize,
            u8: borsh::ser::BorshSerialize,
            u8: borsh::ser::BorshSerialize,
            u8: borsh::ser::BorshSerialize,
            u8: borsh::ser::BorshSerialize,
            u8: borsh::ser::BorshSerialize,
            u8: borsh::ser::BorshSerialize,
            u8: borsh::ser::BorshSerialize,
            u8: borsh::ser::BorshSerialize,
            u8: borsh::ser::BorshSerialize,
            u8: borsh::ser::BorshSerialize,
            u8: borsh::ser::BorshSerialize,
            u8: borsh::ser::BorshSerialize,
            u8: borsh::ser::BorshSerialize,
            u8: borsh::ser::BorshSerialize,
            u8: borsh::ser::BorshSerialize,
            u64: borsh::ser::BorshSerialize,
            u64: borsh::ser::BorshSerialize,
            u64: borsh::ser::BorshSerialize,
            u64: borsh::ser::BorshSerialize,
            u64: borsh::ser::BorshSerialize,
            u64: borsh::ser::BorshSerialize,
            u64: borsh::ser::BorshSerialize,
            Option<CompressionInfo>: borsh::ser::BorshSerialize,
            [u64; 1]: borsh::ser::BorshSerialize,
        {
            fn serialize<W: borsh::maybestd::io::Write>(
                &self,
                writer: &mut W,
            ) -> ::core::result::Result<(), borsh::maybestd::io::Error> {
                borsh::BorshSerialize::serialize(&self.amm_config, writer)?;
                borsh::BorshSerialize::serialize(&self.pool_creator, writer)?;
                borsh::BorshSerialize::serialize(&self.token_0_vault, writer)?;
                borsh::BorshSerialize::serialize(&self.token_1_vault, writer)?;
                borsh::BorshSerialize::serialize(&self.lp_mint, writer)?;
                borsh::BorshSerialize::serialize(&self.lp_vault, writer)?;
                borsh::BorshSerialize::serialize(&self.token_0_mint, writer)?;
                borsh::BorshSerialize::serialize(&self.token_1_mint, writer)?;
                borsh::BorshSerialize::serialize(&self.token_0_program, writer)?;
                borsh::BorshSerialize::serialize(&self.token_1_program, writer)?;
                borsh::BorshSerialize::serialize(&self.observation_key, writer)?;
                borsh::BorshSerialize::serialize(&self.auth_bump, writer)?;
                borsh::BorshSerialize::serialize(&self.status, writer)?;
                borsh::BorshSerialize::serialize(&self.lp_mint_decimals, writer)?;
                borsh::BorshSerialize::serialize(&self.mint_0_decimals, writer)?;
                borsh::BorshSerialize::serialize(&self.mint_1_decimals, writer)?;
                borsh::BorshSerialize::serialize(&self.lp_supply, writer)?;
                borsh::BorshSerialize::serialize(&self.protocol_fees_token_0, writer)?;
                borsh::BorshSerialize::serialize(&self.protocol_fees_token_1, writer)?;
                borsh::BorshSerialize::serialize(&self.fund_fees_token_0, writer)?;
                borsh::BorshSerialize::serialize(&self.fund_fees_token_1, writer)?;
                borsh::BorshSerialize::serialize(&self.open_time, writer)?;
                borsh::BorshSerialize::serialize(&self.recent_epoch, writer)?;
                borsh::BorshSerialize::serialize(&self.compression_info, writer)?;
                borsh::BorshSerialize::serialize(&self.padding, writer)?;
                Ok(())
            }
        }
        impl anchor_lang::idl::build::IdlBuild for PackedPoolState {
            fn create_type() -> Option<anchor_lang::idl::types::IdlTypeDef> {
                Some(anchor_lang::idl::types::IdlTypeDef {
                    name: Self::get_full_path(),
                    docs: ::alloc::vec::Vec::new(),
                    serialization: anchor_lang::idl::types::IdlSerialization::default(),
                    repr: None,
                    generics: ::alloc::vec::Vec::new(),
                    ty: anchor_lang::idl::types::IdlTypeDefTy::Struct {
                        fields: Some(
                            anchor_lang::idl::types::IdlDefinedFields::Named(
                                <[_]>::into_vec(
                                    ::alloc::boxed::box_new([
                                        anchor_lang::idl::types::IdlField {
                                            name: "amm_config".into(),
                                            docs: ::alloc::vec::Vec::new(),
                                            ty: anchor_lang::idl::types::IdlType::U8,
                                        },
                                        anchor_lang::idl::types::IdlField {
                                            name: "pool_creator".into(),
                                            docs: ::alloc::vec::Vec::new(),
                                            ty: anchor_lang::idl::types::IdlType::U8,
                                        },
                                        anchor_lang::idl::types::IdlField {
                                            name: "token_0_vault".into(),
                                            docs: ::alloc::vec::Vec::new(),
                                            ty: anchor_lang::idl::types::IdlType::U8,
                                        },
                                        anchor_lang::idl::types::IdlField {
                                            name: "token_1_vault".into(),
                                            docs: ::alloc::vec::Vec::new(),
                                            ty: anchor_lang::idl::types::IdlType::U8,
                                        },
                                        anchor_lang::idl::types::IdlField {
                                            name: "lp_mint".into(),
                                            docs: ::alloc::vec::Vec::new(),
                                            ty: anchor_lang::idl::types::IdlType::U8,
                                        },
                                        anchor_lang::idl::types::IdlField {
                                            name: "lp_vault".into(),
                                            docs: ::alloc::vec::Vec::new(),
                                            ty: anchor_lang::idl::types::IdlType::U8,
                                        },
                                        anchor_lang::idl::types::IdlField {
                                            name: "token_0_mint".into(),
                                            docs: ::alloc::vec::Vec::new(),
                                            ty: anchor_lang::idl::types::IdlType::U8,
                                        },
                                        anchor_lang::idl::types::IdlField {
                                            name: "token_1_mint".into(),
                                            docs: ::alloc::vec::Vec::new(),
                                            ty: anchor_lang::idl::types::IdlType::U8,
                                        },
                                        anchor_lang::idl::types::IdlField {
                                            name: "token_0_program".into(),
                                            docs: ::alloc::vec::Vec::new(),
                                            ty: anchor_lang::idl::types::IdlType::U8,
                                        },
                                        anchor_lang::idl::types::IdlField {
                                            name: "token_1_program".into(),
                                            docs: ::alloc::vec::Vec::new(),
                                            ty: anchor_lang::idl::types::IdlType::U8,
                                        },
                                        anchor_lang::idl::types::IdlField {
                                            name: "observation_key".into(),
                                            docs: ::alloc::vec::Vec::new(),
                                            ty: anchor_lang::idl::types::IdlType::U8,
                                        },
                                        anchor_lang::idl::types::IdlField {
                                            name: "auth_bump".into(),
                                            docs: ::alloc::vec::Vec::new(),
                                            ty: anchor_lang::idl::types::IdlType::U8,
                                        },
                                        anchor_lang::idl::types::IdlField {
                                            name: "status".into(),
                                            docs: ::alloc::vec::Vec::new(),
                                            ty: anchor_lang::idl::types::IdlType::U8,
                                        },
                                        anchor_lang::idl::types::IdlField {
                                            name: "lp_mint_decimals".into(),
                                            docs: ::alloc::vec::Vec::new(),
                                            ty: anchor_lang::idl::types::IdlType::U8,
                                        },
                                        anchor_lang::idl::types::IdlField {
                                            name: "mint_0_decimals".into(),
                                            docs: ::alloc::vec::Vec::new(),
                                            ty: anchor_lang::idl::types::IdlType::U8,
                                        },
                                        anchor_lang::idl::types::IdlField {
                                            name: "mint_1_decimals".into(),
                                            docs: ::alloc::vec::Vec::new(),
                                            ty: anchor_lang::idl::types::IdlType::U8,
                                        },
                                        anchor_lang::idl::types::IdlField {
                                            name: "lp_supply".into(),
                                            docs: ::alloc::vec::Vec::new(),
                                            ty: anchor_lang::idl::types::IdlType::U64,
                                        },
                                        anchor_lang::idl::types::IdlField {
                                            name: "protocol_fees_token_0".into(),
                                            docs: ::alloc::vec::Vec::new(),
                                            ty: anchor_lang::idl::types::IdlType::U64,
                                        },
                                        anchor_lang::idl::types::IdlField {
                                            name: "protocol_fees_token_1".into(),
                                            docs: ::alloc::vec::Vec::new(),
                                            ty: anchor_lang::idl::types::IdlType::U64,
                                        },
                                        anchor_lang::idl::types::IdlField {
                                            name: "fund_fees_token_0".into(),
                                            docs: ::alloc::vec::Vec::new(),
                                            ty: anchor_lang::idl::types::IdlType::U64,
                                        },
                                        anchor_lang::idl::types::IdlField {
                                            name: "fund_fees_token_1".into(),
                                            docs: ::alloc::vec::Vec::new(),
                                            ty: anchor_lang::idl::types::IdlType::U64,
                                        },
                                        anchor_lang::idl::types::IdlField {
                                            name: "open_time".into(),
                                            docs: ::alloc::vec::Vec::new(),
                                            ty: anchor_lang::idl::types::IdlType::U64,
                                        },
                                        anchor_lang::idl::types::IdlField {
                                            name: "recent_epoch".into(),
                                            docs: ::alloc::vec::Vec::new(),
                                            ty: anchor_lang::idl::types::IdlType::U64,
                                        },
                                        anchor_lang::idl::types::IdlField {
                                            name: "compression_info".into(),
                                            docs: ::alloc::vec::Vec::new(),
                                            ty: anchor_lang::idl::types::IdlType::Option(
                                                Box::new(anchor_lang::idl::types::IdlType::Defined {
                                                    name: <CompressionInfo>::get_full_path(),
                                                    generics: ::alloc::vec::Vec::new(),
                                                }),
                                            ),
                                        },
                                        anchor_lang::idl::types::IdlField {
                                            name: "padding".into(),
                                            docs: ::alloc::vec::Vec::new(),
                                            ty: anchor_lang::idl::types::IdlType::Array(
                                                Box::new(anchor_lang::idl::types::IdlType::U64),
                                                anchor_lang::idl::types::IdlArrayLen::Value(1),
                                            ),
                                        },
                                    ]),
                                ),
                            ),
                        ),
                    },
                })
            }
            fn insert_types(
                types: &mut std::collections::BTreeMap<
                    String,
                    anchor_lang::idl::types::IdlTypeDef,
                >,
            ) {
                if let Some(ty) = <CompressionInfo>::create_type() {
                    types.insert(<CompressionInfo>::get_full_path(), ty);
                    <CompressionInfo>::insert_types(types);
                }
            }
            fn get_full_path() -> String {
                ::alloc::__export::must_use({
                    ::alloc::fmt::format(
                        format_args!(
                            "{0}::{1}",
                            "raydium_cp_swap::states::pool",
                            "PackedPoolState",
                        ),
                    )
                })
            }
        }
        impl borsh::de::BorshDeserialize for PackedPoolState
        where
            u8: borsh::BorshDeserialize,
            u8: borsh::BorshDeserialize,
            u8: borsh::BorshDeserialize,
            u8: borsh::BorshDeserialize,
            u8: borsh::BorshDeserialize,
            u8: borsh::BorshDeserialize,
            u8: borsh::BorshDeserialize,
            u8: borsh::BorshDeserialize,
            u8: borsh::BorshDeserialize,
            u8: borsh::BorshDeserialize,
            u8: borsh::BorshDeserialize,
            u8: borsh::BorshDeserialize,
            u8: borsh::BorshDeserialize,
            u8: borsh::BorshDeserialize,
            u8: borsh::BorshDeserialize,
            u8: borsh::BorshDeserialize,
            u64: borsh::BorshDeserialize,
            u64: borsh::BorshDeserialize,
            u64: borsh::BorshDeserialize,
            u64: borsh::BorshDeserialize,
            u64: borsh::BorshDeserialize,
            u64: borsh::BorshDeserialize,
            u64: borsh::BorshDeserialize,
            Option<CompressionInfo>: borsh::BorshDeserialize,
            [u64; 1]: borsh::BorshDeserialize,
        {
            fn deserialize_reader<R: borsh::maybestd::io::Read>(
                reader: &mut R,
            ) -> ::core::result::Result<Self, borsh::maybestd::io::Error> {
                Ok(Self {
                    amm_config: borsh::BorshDeserialize::deserialize_reader(reader)?,
                    pool_creator: borsh::BorshDeserialize::deserialize_reader(reader)?,
                    token_0_vault: borsh::BorshDeserialize::deserialize_reader(reader)?,
                    token_1_vault: borsh::BorshDeserialize::deserialize_reader(reader)?,
                    lp_mint: borsh::BorshDeserialize::deserialize_reader(reader)?,
                    lp_vault: borsh::BorshDeserialize::deserialize_reader(reader)?,
                    token_0_mint: borsh::BorshDeserialize::deserialize_reader(reader)?,
                    token_1_mint: borsh::BorshDeserialize::deserialize_reader(reader)?,
                    token_0_program: borsh::BorshDeserialize::deserialize_reader(
                        reader,
                    )?,
                    token_1_program: borsh::BorshDeserialize::deserialize_reader(
                        reader,
                    )?,
                    observation_key: borsh::BorshDeserialize::deserialize_reader(
                        reader,
                    )?,
                    auth_bump: borsh::BorshDeserialize::deserialize_reader(reader)?,
                    status: borsh::BorshDeserialize::deserialize_reader(reader)?,
                    lp_mint_decimals: borsh::BorshDeserialize::deserialize_reader(
                        reader,
                    )?,
                    mint_0_decimals: borsh::BorshDeserialize::deserialize_reader(
                        reader,
                    )?,
                    mint_1_decimals: borsh::BorshDeserialize::deserialize_reader(
                        reader,
                    )?,
                    lp_supply: borsh::BorshDeserialize::deserialize_reader(reader)?,
                    protocol_fees_token_0: borsh::BorshDeserialize::deserialize_reader(
                        reader,
                    )?,
                    protocol_fees_token_1: borsh::BorshDeserialize::deserialize_reader(
                        reader,
                    )?,
                    fund_fees_token_0: borsh::BorshDeserialize::deserialize_reader(
                        reader,
                    )?,
                    fund_fees_token_1: borsh::BorshDeserialize::deserialize_reader(
                        reader,
                    )?,
                    open_time: borsh::BorshDeserialize::deserialize_reader(reader)?,
                    recent_epoch: borsh::BorshDeserialize::deserialize_reader(reader)?,
                    compression_info: borsh::BorshDeserialize::deserialize_reader(
                        reader,
                    )?,
                    padding: borsh::BorshDeserialize::deserialize_reader(reader)?,
                })
            }
        }
        impl light_sdk::compressible::Pack for PoolState {
            type Packed = PackedPoolState;
            #[inline(never)]
            fn pack(
                &self,
                remaining_accounts: &mut light_sdk::instruction::PackedAccounts,
            ) -> Self::Packed {
                PackedPoolState {
                    amm_config: remaining_accounts.insert_or_get(self.amm_config),
                    pool_creator: remaining_accounts.insert_or_get(self.pool_creator),
                    token_0_vault: remaining_accounts.insert_or_get(self.token_0_vault),
                    token_1_vault: remaining_accounts.insert_or_get(self.token_1_vault),
                    lp_mint: remaining_accounts.insert_or_get(self.lp_mint),
                    lp_vault: remaining_accounts.insert_or_get(self.lp_vault),
                    token_0_mint: remaining_accounts.insert_or_get(self.token_0_mint),
                    token_1_mint: remaining_accounts.insert_or_get(self.token_1_mint),
                    token_0_program: remaining_accounts
                        .insert_or_get(self.token_0_program),
                    token_1_program: remaining_accounts
                        .insert_or_get(self.token_1_program),
                    observation_key: remaining_accounts
                        .insert_or_get(self.observation_key),
                    auth_bump: self.auth_bump,
                    status: self.status,
                    lp_mint_decimals: self.lp_mint_decimals,
                    mint_0_decimals: self.mint_0_decimals,
                    mint_1_decimals: self.mint_1_decimals,
                    lp_supply: self.lp_supply,
                    protocol_fees_token_0: self.protocol_fees_token_0,
                    protocol_fees_token_1: self.protocol_fees_token_1,
                    fund_fees_token_0: self.fund_fees_token_0,
                    fund_fees_token_1: self.fund_fees_token_1,
                    open_time: self.open_time,
                    recent_epoch: self.recent_epoch,
                    compression_info: None,
                    padding: self.padding.clone(),
                }
            }
        }
        impl light_sdk::compressible::Unpack for PoolState {
            type Unpacked = Self;
            #[inline(never)]
            fn unpack(
                &self,
                _remaining_accounts: &[anchor_lang::prelude::AccountInfo],
            ) -> std::result::Result<
                Self::Unpacked,
                anchor_lang::prelude::ProgramError,
            > {
                Ok(self.clone())
            }
        }
        impl light_sdk::compressible::Pack for PackedPoolState {
            type Packed = Self;
            #[inline(never)]
            fn pack(
                &self,
                _remaining_accounts: &mut light_sdk::instruction::PackedAccounts,
            ) -> Self::Packed {
                self.clone()
            }
        }
        impl light_sdk::compressible::Unpack for PackedPoolState {
            type Unpacked = PoolState;
            #[inline(never)]
            fn unpack(
                &self,
                remaining_accounts: &[anchor_lang::prelude::AccountInfo],
            ) -> std::result::Result<
                Self::Unpacked,
                anchor_lang::prelude::ProgramError,
            > {
                Ok(PoolState {
                    amm_config: *remaining_accounts[self.amm_config as usize].key,
                    pool_creator: *remaining_accounts[self.pool_creator as usize].key,
                    token_0_vault: *remaining_accounts[self.token_0_vault as usize].key,
                    token_1_vault: *remaining_accounts[self.token_1_vault as usize].key,
                    lp_mint: *remaining_accounts[self.lp_mint as usize].key,
                    lp_vault: *remaining_accounts[self.lp_vault as usize].key,
                    token_0_mint: *remaining_accounts[self.token_0_mint as usize].key,
                    token_1_mint: *remaining_accounts[self.token_1_mint as usize].key,
                    token_0_program: *remaining_accounts[self.token_0_program as usize]
                        .key,
                    token_1_program: *remaining_accounts[self.token_1_program as usize]
                        .key,
                    observation_key: *remaining_accounts[self.observation_key as usize]
                        .key,
                    auth_bump: self.auth_bump,
                    status: self.status,
                    lp_mint_decimals: self.lp_mint_decimals,
                    mint_0_decimals: self.mint_0_decimals,
                    mint_1_decimals: self.mint_1_decimals,
                    lp_supply: self.lp_supply,
                    protocol_fees_token_0: self.protocol_fees_token_0,
                    protocol_fees_token_1: self.protocol_fees_token_1,
                    fund_fees_token_0: self.fund_fees_token_0,
                    fund_fees_token_1: self.fund_fees_token_1,
                    open_time: self.open_time,
                    recent_epoch: self.recent_epoch,
                    compression_info: None,
                    padding: self.padding.clone(),
                })
            }
        }
        impl borsh::ser::BorshSerialize for PoolState
        where
            Pubkey: borsh::ser::BorshSerialize,
            Pubkey: borsh::ser::BorshSerialize,
            Pubkey: borsh::ser::BorshSerialize,
            Pubkey: borsh::ser::BorshSerialize,
            Pubkey: borsh::ser::BorshSerialize,
            Pubkey: borsh::ser::BorshSerialize,
            Pubkey: borsh::ser::BorshSerialize,
            Pubkey: borsh::ser::BorshSerialize,
            Pubkey: borsh::ser::BorshSerialize,
            Pubkey: borsh::ser::BorshSerialize,
            Pubkey: borsh::ser::BorshSerialize,
            u8: borsh::ser::BorshSerialize,
            u8: borsh::ser::BorshSerialize,
            u8: borsh::ser::BorshSerialize,
            u8: borsh::ser::BorshSerialize,
            u8: borsh::ser::BorshSerialize,
            u64: borsh::ser::BorshSerialize,
            u64: borsh::ser::BorshSerialize,
            u64: borsh::ser::BorshSerialize,
            u64: borsh::ser::BorshSerialize,
            u64: borsh::ser::BorshSerialize,
            u64: borsh::ser::BorshSerialize,
            u64: borsh::ser::BorshSerialize,
            Option<CompressionInfo>: borsh::ser::BorshSerialize,
            [u64; 1]: borsh::ser::BorshSerialize,
        {
            fn serialize<W: borsh::maybestd::io::Write>(
                &self,
                writer: &mut W,
            ) -> ::core::result::Result<(), borsh::maybestd::io::Error> {
                borsh::BorshSerialize::serialize(&self.amm_config, writer)?;
                borsh::BorshSerialize::serialize(&self.pool_creator, writer)?;
                borsh::BorshSerialize::serialize(&self.token_0_vault, writer)?;
                borsh::BorshSerialize::serialize(&self.token_1_vault, writer)?;
                borsh::BorshSerialize::serialize(&self.lp_mint, writer)?;
                borsh::BorshSerialize::serialize(&self.lp_vault, writer)?;
                borsh::BorshSerialize::serialize(&self.token_0_mint, writer)?;
                borsh::BorshSerialize::serialize(&self.token_1_mint, writer)?;
                borsh::BorshSerialize::serialize(&self.token_0_program, writer)?;
                borsh::BorshSerialize::serialize(&self.token_1_program, writer)?;
                borsh::BorshSerialize::serialize(&self.observation_key, writer)?;
                borsh::BorshSerialize::serialize(&self.auth_bump, writer)?;
                borsh::BorshSerialize::serialize(&self.status, writer)?;
                borsh::BorshSerialize::serialize(&self.lp_mint_decimals, writer)?;
                borsh::BorshSerialize::serialize(&self.mint_0_decimals, writer)?;
                borsh::BorshSerialize::serialize(&self.mint_1_decimals, writer)?;
                borsh::BorshSerialize::serialize(&self.lp_supply, writer)?;
                borsh::BorshSerialize::serialize(&self.protocol_fees_token_0, writer)?;
                borsh::BorshSerialize::serialize(&self.protocol_fees_token_1, writer)?;
                borsh::BorshSerialize::serialize(&self.fund_fees_token_0, writer)?;
                borsh::BorshSerialize::serialize(&self.fund_fees_token_1, writer)?;
                borsh::BorshSerialize::serialize(&self.open_time, writer)?;
                borsh::BorshSerialize::serialize(&self.recent_epoch, writer)?;
                borsh::BorshSerialize::serialize(&self.compression_info, writer)?;
                borsh::BorshSerialize::serialize(&self.padding, writer)?;
                Ok(())
            }
        }
        impl anchor_lang::idl::build::IdlBuild for PoolState {
            fn create_type() -> Option<anchor_lang::idl::types::IdlTypeDef> {
                Some(anchor_lang::idl::types::IdlTypeDef {
                    name: Self::get_full_path(),
                    docs: <[_]>::into_vec(
                        ::alloc::boxed::box_new([
                            "Tip: The 'Compressible' macro derives compress/decompress methods for the"
                                .into(),
                            "account. CompressionInfo tracks the last_written_slot. Whenever a"
                                .into(),
                            "compressible account is written to, last_written_slot must be updated. If"
                                .into(),
                            "last_written_slot >= threshold (compression_delay), the account becomes"
                                .into(),
                            "eligible for compression. Eligible accounts can be compressed"
                                .into(),
                            "asynchronously.".into(),
                        ]),
                    ),
                    serialization: anchor_lang::idl::types::IdlSerialization::default(),
                    repr: Some(
                        anchor_lang::idl::types::IdlRepr::C(anchor_lang::idl::types::IdlReprModifier {
                            packed: false,
                            align: None,
                        }),
                    ),
                    generics: ::alloc::vec::Vec::new(),
                    ty: anchor_lang::idl::types::IdlTypeDefTy::Struct {
                        fields: Some(
                            anchor_lang::idl::types::IdlDefinedFields::Named(
                                <[_]>::into_vec(
                                    ::alloc::boxed::box_new([
                                        anchor_lang::idl::types::IdlField {
                                            name: "amm_config".into(),
                                            docs: <[_]>::into_vec(
                                                ::alloc::boxed::box_new([
                                                    "Which config the pool belongs".into(),
                                                ]),
                                            ),
                                            ty: anchor_lang::idl::types::IdlType::Pubkey,
                                        },
                                        anchor_lang::idl::types::IdlField {
                                            name: "pool_creator".into(),
                                            docs: <[_]>::into_vec(
                                                ::alloc::boxed::box_new(["pool creator".into()]),
                                            ),
                                            ty: anchor_lang::idl::types::IdlType::Pubkey,
                                        },
                                        anchor_lang::idl::types::IdlField {
                                            name: "token_0_vault".into(),
                                            docs: <[_]>::into_vec(
                                                ::alloc::boxed::box_new(["Token A".into()]),
                                            ),
                                            ty: anchor_lang::idl::types::IdlType::Pubkey,
                                        },
                                        anchor_lang::idl::types::IdlField {
                                            name: "token_1_vault".into(),
                                            docs: <[_]>::into_vec(
                                                ::alloc::boxed::box_new(["Token B".into()]),
                                            ),
                                            ty: anchor_lang::idl::types::IdlType::Pubkey,
                                        },
                                        anchor_lang::idl::types::IdlField {
                                            name: "lp_mint".into(),
                                            docs: <[_]>::into_vec(
                                                ::alloc::boxed::box_new([
                                                    "Pool tokens are issued when A or B tokens are deposited."
                                                        .into(),
                                                    "Pool tokens can be withdrawn back to the original A or B token."
                                                        .into(),
                                                ]),
                                            ),
                                            ty: anchor_lang::idl::types::IdlType::Pubkey,
                                        },
                                        anchor_lang::idl::types::IdlField {
                                            name: "lp_vault".into(),
                                            docs: <[_]>::into_vec(
                                                ::alloc::boxed::box_new([
                                                    "Holds all LP tokens. Compressible.".into(),
                                                ]),
                                            ),
                                            ty: anchor_lang::idl::types::IdlType::Pubkey,
                                        },
                                        anchor_lang::idl::types::IdlField {
                                            name: "token_0_mint".into(),
                                            docs: <[_]>::into_vec(
                                                ::alloc::boxed::box_new([
                                                    "Mint information for token A".into(),
                                                ]),
                                            ),
                                            ty: anchor_lang::idl::types::IdlType::Pubkey,
                                        },
                                        anchor_lang::idl::types::IdlField {
                                            name: "token_1_mint".into(),
                                            docs: <[_]>::into_vec(
                                                ::alloc::boxed::box_new([
                                                    "Mint information for token B".into(),
                                                ]),
                                            ),
                                            ty: anchor_lang::idl::types::IdlType::Pubkey,
                                        },
                                        anchor_lang::idl::types::IdlField {
                                            name: "token_0_program".into(),
                                            docs: <[_]>::into_vec(
                                                ::alloc::boxed::box_new(["token_0 program".into()]),
                                            ),
                                            ty: anchor_lang::idl::types::IdlType::Pubkey,
                                        },
                                        anchor_lang::idl::types::IdlField {
                                            name: "token_1_program".into(),
                                            docs: <[_]>::into_vec(
                                                ::alloc::boxed::box_new(["token_1 program".into()]),
                                            ),
                                            ty: anchor_lang::idl::types::IdlType::Pubkey,
                                        },
                                        anchor_lang::idl::types::IdlField {
                                            name: "observation_key".into(),
                                            docs: <[_]>::into_vec(
                                                ::alloc::boxed::box_new([
                                                    "observation account to store oracle data".into(),
                                                ]),
                                            ),
                                            ty: anchor_lang::idl::types::IdlType::Pubkey,
                                        },
                                        anchor_lang::idl::types::IdlField {
                                            name: "auth_bump".into(),
                                            docs: ::alloc::vec::Vec::new(),
                                            ty: anchor_lang::idl::types::IdlType::U8,
                                        },
                                        anchor_lang::idl::types::IdlField {
                                            name: "status".into(),
                                            docs: <[_]>::into_vec(
                                                ::alloc::boxed::box_new([
                                                    "Bitwise representation of the state of the pool".into(),
                                                    "bit0, 1: disable deposit(value is 1), 0: normal".into(),
                                                    "bit1, 1: disable withdraw(value is 2), 0: normal".into(),
                                                    "bit2, 1: disable swap(value is 4), 0: normal".into(),
                                                ]),
                                            ),
                                            ty: anchor_lang::idl::types::IdlType::U8,
                                        },
                                        anchor_lang::idl::types::IdlField {
                                            name: "lp_mint_decimals".into(),
                                            docs: ::alloc::vec::Vec::new(),
                                            ty: anchor_lang::idl::types::IdlType::U8,
                                        },
                                        anchor_lang::idl::types::IdlField {
                                            name: "mint_0_decimals".into(),
                                            docs: <[_]>::into_vec(
                                                ::alloc::boxed::box_new(["mint0 and mint1 decimals".into()]),
                                            ),
                                            ty: anchor_lang::idl::types::IdlType::U8,
                                        },
                                        anchor_lang::idl::types::IdlField {
                                            name: "mint_1_decimals".into(),
                                            docs: ::alloc::vec::Vec::new(),
                                            ty: anchor_lang::idl::types::IdlType::U8,
                                        },
                                        anchor_lang::idl::types::IdlField {
                                            name: "lp_supply".into(),
                                            docs: <[_]>::into_vec(
                                                ::alloc::boxed::box_new([
                                                    "True circulating supply without burns and lock ups".into(),
                                                ]),
                                            ),
                                            ty: anchor_lang::idl::types::IdlType::U64,
                                        },
                                        anchor_lang::idl::types::IdlField {
                                            name: "protocol_fees_token_0".into(),
                                            docs: <[_]>::into_vec(
                                                ::alloc::boxed::box_new([
                                                    "The amounts of token_0 and token_1 that are owed to the liquidity provider."
                                                        .into(),
                                                ]),
                                            ),
                                            ty: anchor_lang::idl::types::IdlType::U64,
                                        },
                                        anchor_lang::idl::types::IdlField {
                                            name: "protocol_fees_token_1".into(),
                                            docs: ::alloc::vec::Vec::new(),
                                            ty: anchor_lang::idl::types::IdlType::U64,
                                        },
                                        anchor_lang::idl::types::IdlField {
                                            name: "fund_fees_token_0".into(),
                                            docs: ::alloc::vec::Vec::new(),
                                            ty: anchor_lang::idl::types::IdlType::U64,
                                        },
                                        anchor_lang::idl::types::IdlField {
                                            name: "fund_fees_token_1".into(),
                                            docs: ::alloc::vec::Vec::new(),
                                            ty: anchor_lang::idl::types::IdlType::U64,
                                        },
                                        anchor_lang::idl::types::IdlField {
                                            name: "open_time".into(),
                                            docs: <[_]>::into_vec(
                                                ::alloc::boxed::box_new([
                                                    "The timestamp allowed for swap in the pool.".into(),
                                                ]),
                                            ),
                                            ty: anchor_lang::idl::types::IdlType::U64,
                                        },
                                        anchor_lang::idl::types::IdlField {
                                            name: "recent_epoch".into(),
                                            docs: <[_]>::into_vec(
                                                ::alloc::boxed::box_new(["recent epoch".into()]),
                                            ),
                                            ty: anchor_lang::idl::types::IdlType::U64,
                                        },
                                        anchor_lang::idl::types::IdlField {
                                            name: "compression_info".into(),
                                            docs: <[_]>::into_vec(
                                                ::alloc::boxed::box_new([
                                                    "#[skip] is required. Is Some when the account is decompressed and None"
                                                        .into(),
                                                    "when compressed.".into(),
                                                ]),
                                            ),
                                            ty: anchor_lang::idl::types::IdlType::Option(
                                                Box::new(anchor_lang::idl::types::IdlType::Defined {
                                                    name: <CompressionInfo>::get_full_path(),
                                                    generics: ::alloc::vec::Vec::new(),
                                                }),
                                            ),
                                        },
                                        anchor_lang::idl::types::IdlField {
                                            name: "padding".into(),
                                            docs: <[_]>::into_vec(
                                                ::alloc::boxed::box_new([
                                                    "padding for future updates".into(),
                                                ]),
                                            ),
                                            ty: anchor_lang::idl::types::IdlType::Array(
                                                Box::new(anchor_lang::idl::types::IdlType::U64),
                                                anchor_lang::idl::types::IdlArrayLen::Value(1),
                                            ),
                                        },
                                    ]),
                                ),
                            ),
                        ),
                    },
                })
            }
            fn insert_types(
                types: &mut std::collections::BTreeMap<
                    String,
                    anchor_lang::idl::types::IdlTypeDef,
                >,
            ) {
                if let Some(ty) = <CompressionInfo>::create_type() {
                    types.insert(<CompressionInfo>::get_full_path(), ty);
                    <CompressionInfo>::insert_types(types);
                }
            }
            fn get_full_path() -> String {
                ::alloc::__export::must_use({
                    ::alloc::fmt::format(
                        format_args!(
                            "{0}::{1}",
                            "raydium_cp_swap::states::pool",
                            "PoolState",
                        ),
                    )
                })
            }
        }
        impl borsh::de::BorshDeserialize for PoolState
        where
            Pubkey: borsh::BorshDeserialize,
            Pubkey: borsh::BorshDeserialize,
            Pubkey: borsh::BorshDeserialize,
            Pubkey: borsh::BorshDeserialize,
            Pubkey: borsh::BorshDeserialize,
            Pubkey: borsh::BorshDeserialize,
            Pubkey: borsh::BorshDeserialize,
            Pubkey: borsh::BorshDeserialize,
            Pubkey: borsh::BorshDeserialize,
            Pubkey: borsh::BorshDeserialize,
            Pubkey: borsh::BorshDeserialize,
            u8: borsh::BorshDeserialize,
            u8: borsh::BorshDeserialize,
            u8: borsh::BorshDeserialize,
            u8: borsh::BorshDeserialize,
            u8: borsh::BorshDeserialize,
            u64: borsh::BorshDeserialize,
            u64: borsh::BorshDeserialize,
            u64: borsh::BorshDeserialize,
            u64: borsh::BorshDeserialize,
            u64: borsh::BorshDeserialize,
            u64: borsh::BorshDeserialize,
            u64: borsh::BorshDeserialize,
            Option<CompressionInfo>: borsh::BorshDeserialize,
            [u64; 1]: borsh::BorshDeserialize,
        {
            fn deserialize_reader<R: borsh::maybestd::io::Read>(
                reader: &mut R,
            ) -> ::core::result::Result<Self, borsh::maybestd::io::Error> {
                Ok(Self {
                    amm_config: borsh::BorshDeserialize::deserialize_reader(reader)?,
                    pool_creator: borsh::BorshDeserialize::deserialize_reader(reader)?,
                    token_0_vault: borsh::BorshDeserialize::deserialize_reader(reader)?,
                    token_1_vault: borsh::BorshDeserialize::deserialize_reader(reader)?,
                    lp_mint: borsh::BorshDeserialize::deserialize_reader(reader)?,
                    lp_vault: borsh::BorshDeserialize::deserialize_reader(reader)?,
                    token_0_mint: borsh::BorshDeserialize::deserialize_reader(reader)?,
                    token_1_mint: borsh::BorshDeserialize::deserialize_reader(reader)?,
                    token_0_program: borsh::BorshDeserialize::deserialize_reader(
                        reader,
                    )?,
                    token_1_program: borsh::BorshDeserialize::deserialize_reader(
                        reader,
                    )?,
                    observation_key: borsh::BorshDeserialize::deserialize_reader(
                        reader,
                    )?,
                    auth_bump: borsh::BorshDeserialize::deserialize_reader(reader)?,
                    status: borsh::BorshDeserialize::deserialize_reader(reader)?,
                    lp_mint_decimals: borsh::BorshDeserialize::deserialize_reader(
                        reader,
                    )?,
                    mint_0_decimals: borsh::BorshDeserialize::deserialize_reader(
                        reader,
                    )?,
                    mint_1_decimals: borsh::BorshDeserialize::deserialize_reader(
                        reader,
                    )?,
                    lp_supply: borsh::BorshDeserialize::deserialize_reader(reader)?,
                    protocol_fees_token_0: borsh::BorshDeserialize::deserialize_reader(
                        reader,
                    )?,
                    protocol_fees_token_1: borsh::BorshDeserialize::deserialize_reader(
                        reader,
                    )?,
                    fund_fees_token_0: borsh::BorshDeserialize::deserialize_reader(
                        reader,
                    )?,
                    fund_fees_token_1: borsh::BorshDeserialize::deserialize_reader(
                        reader,
                    )?,
                    open_time: borsh::BorshDeserialize::deserialize_reader(reader)?,
                    recent_epoch: borsh::BorshDeserialize::deserialize_reader(reader)?,
                    compression_info: borsh::BorshDeserialize::deserialize_reader(
                        reader,
                    )?,
                    padding: borsh::BorshDeserialize::deserialize_reader(reader)?,
                })
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for PoolState {
            #[inline]
            fn clone(&self) -> PoolState {
                PoolState {
                    amm_config: ::core::clone::Clone::clone(&self.amm_config),
                    pool_creator: ::core::clone::Clone::clone(&self.pool_creator),
                    token_0_vault: ::core::clone::Clone::clone(&self.token_0_vault),
                    token_1_vault: ::core::clone::Clone::clone(&self.token_1_vault),
                    lp_mint: ::core::clone::Clone::clone(&self.lp_mint),
                    lp_vault: ::core::clone::Clone::clone(&self.lp_vault),
                    token_0_mint: ::core::clone::Clone::clone(&self.token_0_mint),
                    token_1_mint: ::core::clone::Clone::clone(&self.token_1_mint),
                    token_0_program: ::core::clone::Clone::clone(&self.token_0_program),
                    token_1_program: ::core::clone::Clone::clone(&self.token_1_program),
                    observation_key: ::core::clone::Clone::clone(&self.observation_key),
                    auth_bump: ::core::clone::Clone::clone(&self.auth_bump),
                    status: ::core::clone::Clone::clone(&self.status),
                    lp_mint_decimals: ::core::clone::Clone::clone(
                        &self.lp_mint_decimals,
                    ),
                    mint_0_decimals: ::core::clone::Clone::clone(&self.mint_0_decimals),
                    mint_1_decimals: ::core::clone::Clone::clone(&self.mint_1_decimals),
                    lp_supply: ::core::clone::Clone::clone(&self.lp_supply),
                    protocol_fees_token_0: ::core::clone::Clone::clone(
                        &self.protocol_fees_token_0,
                    ),
                    protocol_fees_token_1: ::core::clone::Clone::clone(
                        &self.protocol_fees_token_1,
                    ),
                    fund_fees_token_0: ::core::clone::Clone::clone(
                        &self.fund_fees_token_0,
                    ),
                    fund_fees_token_1: ::core::clone::Clone::clone(
                        &self.fund_fees_token_1,
                    ),
                    open_time: ::core::clone::Clone::clone(&self.open_time),
                    recent_epoch: ::core::clone::Clone::clone(&self.recent_epoch),
                    compression_info: ::core::clone::Clone::clone(
                        &self.compression_info,
                    ),
                    padding: ::core::clone::Clone::clone(&self.padding),
                }
            }
        }
        #[automatically_derived]
        impl anchor_lang::AccountSerialize for PoolState {
            fn try_serialize<W: std::io::Write>(
                &self,
                writer: &mut W,
            ) -> anchor_lang::Result<()> {
                if writer.write_all(PoolState::DISCRIMINATOR).is_err() {
                    return Err(
                        anchor_lang::error::ErrorCode::AccountDidNotSerialize.into(),
                    );
                }
                if AnchorSerialize::serialize(self, writer).is_err() {
                    return Err(
                        anchor_lang::error::ErrorCode::AccountDidNotSerialize.into(),
                    );
                }
                Ok(())
            }
        }
        #[automatically_derived]
        impl anchor_lang::AccountDeserialize for PoolState {
            fn try_deserialize(buf: &mut &[u8]) -> anchor_lang::Result<Self> {
                if buf.len() < PoolState::DISCRIMINATOR.len() {
                    return Err(
                        anchor_lang::error::ErrorCode::AccountDiscriminatorNotFound
                            .into(),
                    );
                }
                let given_disc = &buf[..PoolState::DISCRIMINATOR.len()];
                if PoolState::DISCRIMINATOR != given_disc {
                    return Err(
                        anchor_lang::error::Error::from(anchor_lang::error::AnchorError {
                                error_name: anchor_lang::error::ErrorCode::AccountDiscriminatorMismatch
                                    .name(),
                                error_code_number: anchor_lang::error::ErrorCode::AccountDiscriminatorMismatch
                                    .into(),
                                error_msg: anchor_lang::error::ErrorCode::AccountDiscriminatorMismatch
                                    .to_string(),
                                error_origin: Some(
                                    anchor_lang::error::ErrorOrigin::Source(anchor_lang::error::Source {
                                        filename: "programs/cp-swap/src/states/pool.rs",
                                        line: 34u32,
                                    }),
                                ),
                                compared_values: None,
                            })
                            .with_account_name("PoolState"),
                    );
                }
                Self::try_deserialize_unchecked(buf)
            }
            fn try_deserialize_unchecked(buf: &mut &[u8]) -> anchor_lang::Result<Self> {
                let mut data: &[u8] = &buf[PoolState::DISCRIMINATOR.len()..];
                AnchorDeserialize::deserialize(&mut data)
                    .map_err(|_| {
                        anchor_lang::error::ErrorCode::AccountDidNotDeserialize.into()
                    })
            }
        }
        #[automatically_derived]
        impl anchor_lang::Discriminator for PoolState {
            const DISCRIMINATOR: &'static [u8] = &[
                247,
                237,
                227,
                245,
                215,
                195,
                222,
                70,
            ];
        }
        #[automatically_derived]
        impl anchor_lang::Owner for PoolState {
            fn owner() -> Pubkey {
                crate::ID
            }
        }
        impl PoolState {
            pub fn initialize(
                &mut self,
                auth_bump: u8,
                lp_supply: u64,
                open_time: u64,
                pool_creator: Pubkey,
                amm_config: Pubkey,
                token_0_vault: Pubkey,
                token_1_vault: Pubkey,
                token_0_mint: &InterfaceAccount<Mint>,
                token_1_mint: &InterfaceAccount<Mint>,
                token_0_program: Pubkey,
                token_1_program: Pubkey,
                lp_vault: &AccountInfo,
                lp_mint: &AccountInfo,
                observation_key: Pubkey,
            ) {
                self.amm_config = amm_config.key();
                self.pool_creator = pool_creator.key();
                self.token_0_vault = token_0_vault;
                self.token_1_vault = token_1_vault;
                self.lp_mint = lp_mint.key();
                self.lp_vault = lp_vault.key();
                self.token_0_mint = token_0_mint.key();
                self.token_1_mint = token_1_mint.key();
                self.token_0_program = token_0_program;
                self.token_1_program = token_1_program;
                self.observation_key = observation_key;
                self.auth_bump = auth_bump;
                self.lp_mint_decimals = 9;
                self.mint_0_decimals = 0;
                self.mint_1_decimals = 0;
                self.lp_supply = lp_supply;
                self.protocol_fees_token_0 = 0;
                self.protocol_fees_token_1 = 0;
                self.fund_fees_token_0 = 0;
                self.fund_fees_token_1 = 0;
                self.open_time = open_time;
                self.recent_epoch = Clock::get().unwrap().epoch;
                self.padding = [0u64; 1];
            }
            pub fn set_status(&mut self, status: u8) {
                self.status = status;
            }
            pub fn set_status_by_bit(
                &mut self,
                bit: PoolStatusBitIndex,
                flag: PoolStatusBitFlag,
            ) {
                let s = u8::from(1) << (bit as u8);
                if flag == PoolStatusBitFlag::Disable {
                    self.status = self.status.bitor(s);
                } else {
                    let m = u8::from(255).bitxor(s);
                    self.status = self.status.bitand(m);
                }
            }
            /// Get status by bit, if it is `noraml` status, return true
            pub fn get_status_by_bit(&self, bit: PoolStatusBitIndex) -> bool {
                let status = u8::from(1) << (bit as u8);
                self.status.bitand(status) == 0
            }
            pub fn vault_amount_without_fee(
                &self,
                vault_0: u64,
                vault_1: u64,
            ) -> (u64, u64) {
                (
                    vault_0
                        .checked_sub(self.protocol_fees_token_0 + self.fund_fees_token_0)
                        .unwrap(),
                    vault_1
                        .checked_sub(self.protocol_fees_token_1 + self.fund_fees_token_1)
                        .unwrap(),
                )
            }
            pub fn token_price_x32(&self, vault_0: u64, vault_1: u64) -> (u128, u128) {
                let (token_0_amount, token_1_amount) = self
                    .vault_amount_without_fee(vault_0, vault_1);
                (
                    token_1_amount as u128 * Q32 as u128 / token_0_amount as u128,
                    token_0_amount as u128 * Q32 as u128 / token_1_amount as u128,
                )
            }
        }
    }
    pub use pool::*;
    pub mod events {
        use anchor_lang::prelude::*;
        /// Emitted when deposit and withdraw
        pub struct LpChangeEvent {
            pub pool_id: Pubkey,
            pub lp_amount_before: u64,
            /// pool vault sub trade fees
            pub token_0_vault_before: u64,
            /// pool vault sub trade fees
            pub token_1_vault_before: u64,
            /// calculate result without transfer fee
            pub token_0_amount: u64,
            /// calculate result without transfer fee
            pub token_1_amount: u64,
            pub token_0_transfer_fee: u64,
            pub token_1_transfer_fee: u64,
            pub change_type: u8,
        }
        impl borsh::ser::BorshSerialize for LpChangeEvent
        where
            Pubkey: borsh::ser::BorshSerialize,
            u64: borsh::ser::BorshSerialize,
            u64: borsh::ser::BorshSerialize,
            u64: borsh::ser::BorshSerialize,
            u64: borsh::ser::BorshSerialize,
            u64: borsh::ser::BorshSerialize,
            u64: borsh::ser::BorshSerialize,
            u64: borsh::ser::BorshSerialize,
            u8: borsh::ser::BorshSerialize,
        {
            fn serialize<W: borsh::maybestd::io::Write>(
                &self,
                writer: &mut W,
            ) -> ::core::result::Result<(), borsh::maybestd::io::Error> {
                borsh::BorshSerialize::serialize(&self.pool_id, writer)?;
                borsh::BorshSerialize::serialize(&self.lp_amount_before, writer)?;
                borsh::BorshSerialize::serialize(&self.token_0_vault_before, writer)?;
                borsh::BorshSerialize::serialize(&self.token_1_vault_before, writer)?;
                borsh::BorshSerialize::serialize(&self.token_0_amount, writer)?;
                borsh::BorshSerialize::serialize(&self.token_1_amount, writer)?;
                borsh::BorshSerialize::serialize(&self.token_0_transfer_fee, writer)?;
                borsh::BorshSerialize::serialize(&self.token_1_transfer_fee, writer)?;
                borsh::BorshSerialize::serialize(&self.change_type, writer)?;
                Ok(())
            }
        }
        impl anchor_lang::idl::build::IdlBuild for LpChangeEvent {
            fn create_type() -> Option<anchor_lang::idl::types::IdlTypeDef> {
                Some(anchor_lang::idl::types::IdlTypeDef {
                    name: Self::get_full_path(),
                    docs: <[_]>::into_vec(
                        ::alloc::boxed::box_new([
                            "Emitted when deposit and withdraw".into(),
                        ]),
                    ),
                    serialization: anchor_lang::idl::types::IdlSerialization::default(),
                    repr: None,
                    generics: ::alloc::vec::Vec::new(),
                    ty: anchor_lang::idl::types::IdlTypeDefTy::Struct {
                        fields: Some(
                            anchor_lang::idl::types::IdlDefinedFields::Named(
                                <[_]>::into_vec(
                                    ::alloc::boxed::box_new([
                                        anchor_lang::idl::types::IdlField {
                                            name: "pool_id".into(),
                                            docs: ::alloc::vec::Vec::new(),
                                            ty: anchor_lang::idl::types::IdlType::Pubkey,
                                        },
                                        anchor_lang::idl::types::IdlField {
                                            name: "lp_amount_before".into(),
                                            docs: ::alloc::vec::Vec::new(),
                                            ty: anchor_lang::idl::types::IdlType::U64,
                                        },
                                        anchor_lang::idl::types::IdlField {
                                            name: "token_0_vault_before".into(),
                                            docs: <[_]>::into_vec(
                                                ::alloc::boxed::box_new([
                                                    "pool vault sub trade fees".into(),
                                                ]),
                                            ),
                                            ty: anchor_lang::idl::types::IdlType::U64,
                                        },
                                        anchor_lang::idl::types::IdlField {
                                            name: "token_1_vault_before".into(),
                                            docs: <[_]>::into_vec(
                                                ::alloc::boxed::box_new([
                                                    "pool vault sub trade fees".into(),
                                                ]),
                                            ),
                                            ty: anchor_lang::idl::types::IdlType::U64,
                                        },
                                        anchor_lang::idl::types::IdlField {
                                            name: "token_0_amount".into(),
                                            docs: <[_]>::into_vec(
                                                ::alloc::boxed::box_new([
                                                    "calculate result without transfer fee".into(),
                                                ]),
                                            ),
                                            ty: anchor_lang::idl::types::IdlType::U64,
                                        },
                                        anchor_lang::idl::types::IdlField {
                                            name: "token_1_amount".into(),
                                            docs: <[_]>::into_vec(
                                                ::alloc::boxed::box_new([
                                                    "calculate result without transfer fee".into(),
                                                ]),
                                            ),
                                            ty: anchor_lang::idl::types::IdlType::U64,
                                        },
                                        anchor_lang::idl::types::IdlField {
                                            name: "token_0_transfer_fee".into(),
                                            docs: ::alloc::vec::Vec::new(),
                                            ty: anchor_lang::idl::types::IdlType::U64,
                                        },
                                        anchor_lang::idl::types::IdlField {
                                            name: "token_1_transfer_fee".into(),
                                            docs: ::alloc::vec::Vec::new(),
                                            ty: anchor_lang::idl::types::IdlType::U64,
                                        },
                                        anchor_lang::idl::types::IdlField {
                                            name: "change_type".into(),
                                            docs: ::alloc::vec::Vec::new(),
                                            ty: anchor_lang::idl::types::IdlType::U8,
                                        },
                                    ]),
                                ),
                            ),
                        ),
                    },
                })
            }
            fn insert_types(
                types: &mut std::collections::BTreeMap<
                    String,
                    anchor_lang::idl::types::IdlTypeDef,
                >,
            ) {}
            fn get_full_path() -> String {
                ::alloc::__export::must_use({
                    ::alloc::fmt::format(
                        format_args!(
                            "{0}::{1}",
                            "raydium_cp_swap::states::events",
                            "LpChangeEvent",
                        ),
                    )
                })
            }
        }
        impl borsh::de::BorshDeserialize for LpChangeEvent
        where
            Pubkey: borsh::BorshDeserialize,
            u64: borsh::BorshDeserialize,
            u64: borsh::BorshDeserialize,
            u64: borsh::BorshDeserialize,
            u64: borsh::BorshDeserialize,
            u64: borsh::BorshDeserialize,
            u64: borsh::BorshDeserialize,
            u64: borsh::BorshDeserialize,
            u8: borsh::BorshDeserialize,
        {
            fn deserialize_reader<R: borsh::maybestd::io::Read>(
                reader: &mut R,
            ) -> ::core::result::Result<Self, borsh::maybestd::io::Error> {
                Ok(Self {
                    pool_id: borsh::BorshDeserialize::deserialize_reader(reader)?,
                    lp_amount_before: borsh::BorshDeserialize::deserialize_reader(
                        reader,
                    )?,
                    token_0_vault_before: borsh::BorshDeserialize::deserialize_reader(
                        reader,
                    )?,
                    token_1_vault_before: borsh::BorshDeserialize::deserialize_reader(
                        reader,
                    )?,
                    token_0_amount: borsh::BorshDeserialize::deserialize_reader(reader)?,
                    token_1_amount: borsh::BorshDeserialize::deserialize_reader(reader)?,
                    token_0_transfer_fee: borsh::BorshDeserialize::deserialize_reader(
                        reader,
                    )?,
                    token_1_transfer_fee: borsh::BorshDeserialize::deserialize_reader(
                        reader,
                    )?,
                    change_type: borsh::BorshDeserialize::deserialize_reader(reader)?,
                })
            }
        }
        impl anchor_lang::Event for LpChangeEvent {
            fn data(&self) -> Vec<u8> {
                let mut data = Vec::with_capacity(256);
                data.extend_from_slice(LpChangeEvent::DISCRIMINATOR);
                self.serialize(&mut data).unwrap();
                data
            }
        }
        impl anchor_lang::Discriminator for LpChangeEvent {
            const DISCRIMINATOR: &'static [u8] = &[121, 163, 205, 201, 57, 218, 117, 60];
        }
        impl LpChangeEvent {
            pub fn __anchor_private_gen_idl_event(
                types: &mut std::collections::BTreeMap<
                    String,
                    anchor_lang::idl::types::IdlTypeDef,
                >,
            ) -> Option<anchor_lang::idl::types::IdlEvent> {
                let ty = anchor_lang::idl::types::IdlTypeDef {
                    name: Self::get_full_path(),
                    docs: <[_]>::into_vec(
                        ::alloc::boxed::box_new([
                            "Emitted when deposit and withdraw".into(),
                        ]),
                    ),
                    serialization: anchor_lang::idl::types::IdlSerialization::default(),
                    repr: None,
                    generics: ::alloc::vec::Vec::new(),
                    ty: anchor_lang::idl::types::IdlTypeDefTy::Struct {
                        fields: Some(
                            anchor_lang::idl::types::IdlDefinedFields::Named(
                                <[_]>::into_vec(
                                    ::alloc::boxed::box_new([
                                        anchor_lang::idl::types::IdlField {
                                            name: "pool_id".into(),
                                            docs: ::alloc::vec::Vec::new(),
                                            ty: anchor_lang::idl::types::IdlType::Pubkey,
                                        },
                                        anchor_lang::idl::types::IdlField {
                                            name: "lp_amount_before".into(),
                                            docs: ::alloc::vec::Vec::new(),
                                            ty: anchor_lang::idl::types::IdlType::U64,
                                        },
                                        anchor_lang::idl::types::IdlField {
                                            name: "token_0_vault_before".into(),
                                            docs: <[_]>::into_vec(
                                                ::alloc::boxed::box_new([
                                                    "pool vault sub trade fees".into(),
                                                ]),
                                            ),
                                            ty: anchor_lang::idl::types::IdlType::U64,
                                        },
                                        anchor_lang::idl::types::IdlField {
                                            name: "token_1_vault_before".into(),
                                            docs: <[_]>::into_vec(
                                                ::alloc::boxed::box_new([
                                                    "pool vault sub trade fees".into(),
                                                ]),
                                            ),
                                            ty: anchor_lang::idl::types::IdlType::U64,
                                        },
                                        anchor_lang::idl::types::IdlField {
                                            name: "token_0_amount".into(),
                                            docs: <[_]>::into_vec(
                                                ::alloc::boxed::box_new([
                                                    "calculate result without transfer fee".into(),
                                                ]),
                                            ),
                                            ty: anchor_lang::idl::types::IdlType::U64,
                                        },
                                        anchor_lang::idl::types::IdlField {
                                            name: "token_1_amount".into(),
                                            docs: <[_]>::into_vec(
                                                ::alloc::boxed::box_new([
                                                    "calculate result without transfer fee".into(),
                                                ]),
                                            ),
                                            ty: anchor_lang::idl::types::IdlType::U64,
                                        },
                                        anchor_lang::idl::types::IdlField {
                                            name: "token_0_transfer_fee".into(),
                                            docs: ::alloc::vec::Vec::new(),
                                            ty: anchor_lang::idl::types::IdlType::U64,
                                        },
                                        anchor_lang::idl::types::IdlField {
                                            name: "token_1_transfer_fee".into(),
                                            docs: ::alloc::vec::Vec::new(),
                                            ty: anchor_lang::idl::types::IdlType::U64,
                                        },
                                        anchor_lang::idl::types::IdlField {
                                            name: "change_type".into(),
                                            docs: ::alloc::vec::Vec::new(),
                                            ty: anchor_lang::idl::types::IdlType::U8,
                                        },
                                    ]),
                                ),
                            ),
                        ),
                    },
                };
                let event = anchor_lang::idl::types::IdlEvent {
                    name: ty.name.clone(),
                    discriminator: Self::DISCRIMINATOR.into(),
                };
                types.insert(ty.name.clone(), ty);
                Some(event)
            }
        }
        /// Emitted when swap
        pub struct SwapEvent {
            pub pool_id: Pubkey,
            /// pool vault sub trade fees
            pub input_vault_before: u64,
            /// pool vault sub trade fees
            pub output_vault_before: u64,
            /// calculate result without transfer fee
            pub input_amount: u64,
            /// calculate result without transfer fee
            pub output_amount: u64,
            pub input_transfer_fee: u64,
            pub output_transfer_fee: u64,
            pub base_input: bool,
        }
        impl borsh::ser::BorshSerialize for SwapEvent
        where
            Pubkey: borsh::ser::BorshSerialize,
            u64: borsh::ser::BorshSerialize,
            u64: borsh::ser::BorshSerialize,
            u64: borsh::ser::BorshSerialize,
            u64: borsh::ser::BorshSerialize,
            u64: borsh::ser::BorshSerialize,
            u64: borsh::ser::BorshSerialize,
            bool: borsh::ser::BorshSerialize,
        {
            fn serialize<W: borsh::maybestd::io::Write>(
                &self,
                writer: &mut W,
            ) -> ::core::result::Result<(), borsh::maybestd::io::Error> {
                borsh::BorshSerialize::serialize(&self.pool_id, writer)?;
                borsh::BorshSerialize::serialize(&self.input_vault_before, writer)?;
                borsh::BorshSerialize::serialize(&self.output_vault_before, writer)?;
                borsh::BorshSerialize::serialize(&self.input_amount, writer)?;
                borsh::BorshSerialize::serialize(&self.output_amount, writer)?;
                borsh::BorshSerialize::serialize(&self.input_transfer_fee, writer)?;
                borsh::BorshSerialize::serialize(&self.output_transfer_fee, writer)?;
                borsh::BorshSerialize::serialize(&self.base_input, writer)?;
                Ok(())
            }
        }
        impl anchor_lang::idl::build::IdlBuild for SwapEvent {
            fn create_type() -> Option<anchor_lang::idl::types::IdlTypeDef> {
                Some(anchor_lang::idl::types::IdlTypeDef {
                    name: Self::get_full_path(),
                    docs: <[_]>::into_vec(
                        ::alloc::boxed::box_new(["Emitted when swap".into()]),
                    ),
                    serialization: anchor_lang::idl::types::IdlSerialization::default(),
                    repr: None,
                    generics: ::alloc::vec::Vec::new(),
                    ty: anchor_lang::idl::types::IdlTypeDefTy::Struct {
                        fields: Some(
                            anchor_lang::idl::types::IdlDefinedFields::Named(
                                <[_]>::into_vec(
                                    ::alloc::boxed::box_new([
                                        anchor_lang::idl::types::IdlField {
                                            name: "pool_id".into(),
                                            docs: ::alloc::vec::Vec::new(),
                                            ty: anchor_lang::idl::types::IdlType::Pubkey,
                                        },
                                        anchor_lang::idl::types::IdlField {
                                            name: "input_vault_before".into(),
                                            docs: <[_]>::into_vec(
                                                ::alloc::boxed::box_new([
                                                    "pool vault sub trade fees".into(),
                                                ]),
                                            ),
                                            ty: anchor_lang::idl::types::IdlType::U64,
                                        },
                                        anchor_lang::idl::types::IdlField {
                                            name: "output_vault_before".into(),
                                            docs: <[_]>::into_vec(
                                                ::alloc::boxed::box_new([
                                                    "pool vault sub trade fees".into(),
                                                ]),
                                            ),
                                            ty: anchor_lang::idl::types::IdlType::U64,
                                        },
                                        anchor_lang::idl::types::IdlField {
                                            name: "input_amount".into(),
                                            docs: <[_]>::into_vec(
                                                ::alloc::boxed::box_new([
                                                    "calculate result without transfer fee".into(),
                                                ]),
                                            ),
                                            ty: anchor_lang::idl::types::IdlType::U64,
                                        },
                                        anchor_lang::idl::types::IdlField {
                                            name: "output_amount".into(),
                                            docs: <[_]>::into_vec(
                                                ::alloc::boxed::box_new([
                                                    "calculate result without transfer fee".into(),
                                                ]),
                                            ),
                                            ty: anchor_lang::idl::types::IdlType::U64,
                                        },
                                        anchor_lang::idl::types::IdlField {
                                            name: "input_transfer_fee".into(),
                                            docs: ::alloc::vec::Vec::new(),
                                            ty: anchor_lang::idl::types::IdlType::U64,
                                        },
                                        anchor_lang::idl::types::IdlField {
                                            name: "output_transfer_fee".into(),
                                            docs: ::alloc::vec::Vec::new(),
                                            ty: anchor_lang::idl::types::IdlType::U64,
                                        },
                                        anchor_lang::idl::types::IdlField {
                                            name: "base_input".into(),
                                            docs: ::alloc::vec::Vec::new(),
                                            ty: anchor_lang::idl::types::IdlType::Bool,
                                        },
                                    ]),
                                ),
                            ),
                        ),
                    },
                })
            }
            fn insert_types(
                types: &mut std::collections::BTreeMap<
                    String,
                    anchor_lang::idl::types::IdlTypeDef,
                >,
            ) {}
            fn get_full_path() -> String {
                ::alloc::__export::must_use({
                    ::alloc::fmt::format(
                        format_args!(
                            "{0}::{1}",
                            "raydium_cp_swap::states::events",
                            "SwapEvent",
                        ),
                    )
                })
            }
        }
        impl borsh::de::BorshDeserialize for SwapEvent
        where
            Pubkey: borsh::BorshDeserialize,
            u64: borsh::BorshDeserialize,
            u64: borsh::BorshDeserialize,
            u64: borsh::BorshDeserialize,
            u64: borsh::BorshDeserialize,
            u64: borsh::BorshDeserialize,
            u64: borsh::BorshDeserialize,
            bool: borsh::BorshDeserialize,
        {
            fn deserialize_reader<R: borsh::maybestd::io::Read>(
                reader: &mut R,
            ) -> ::core::result::Result<Self, borsh::maybestd::io::Error> {
                Ok(Self {
                    pool_id: borsh::BorshDeserialize::deserialize_reader(reader)?,
                    input_vault_before: borsh::BorshDeserialize::deserialize_reader(
                        reader,
                    )?,
                    output_vault_before: borsh::BorshDeserialize::deserialize_reader(
                        reader,
                    )?,
                    input_amount: borsh::BorshDeserialize::deserialize_reader(reader)?,
                    output_amount: borsh::BorshDeserialize::deserialize_reader(reader)?,
                    input_transfer_fee: borsh::BorshDeserialize::deserialize_reader(
                        reader,
                    )?,
                    output_transfer_fee: borsh::BorshDeserialize::deserialize_reader(
                        reader,
                    )?,
                    base_input: borsh::BorshDeserialize::deserialize_reader(reader)?,
                })
            }
        }
        impl anchor_lang::Event for SwapEvent {
            fn data(&self) -> Vec<u8> {
                let mut data = Vec::with_capacity(256);
                data.extend_from_slice(SwapEvent::DISCRIMINATOR);
                self.serialize(&mut data).unwrap();
                data
            }
        }
        impl anchor_lang::Discriminator for SwapEvent {
            const DISCRIMINATOR: &'static [u8] = &[64, 198, 205, 232, 38, 8, 113, 226];
        }
        impl SwapEvent {
            pub fn __anchor_private_gen_idl_event(
                types: &mut std::collections::BTreeMap<
                    String,
                    anchor_lang::idl::types::IdlTypeDef,
                >,
            ) -> Option<anchor_lang::idl::types::IdlEvent> {
                let ty = anchor_lang::idl::types::IdlTypeDef {
                    name: Self::get_full_path(),
                    docs: <[_]>::into_vec(
                        ::alloc::boxed::box_new(["Emitted when swap".into()]),
                    ),
                    serialization: anchor_lang::idl::types::IdlSerialization::default(),
                    repr: None,
                    generics: ::alloc::vec::Vec::new(),
                    ty: anchor_lang::idl::types::IdlTypeDefTy::Struct {
                        fields: Some(
                            anchor_lang::idl::types::IdlDefinedFields::Named(
                                <[_]>::into_vec(
                                    ::alloc::boxed::box_new([
                                        anchor_lang::idl::types::IdlField {
                                            name: "pool_id".into(),
                                            docs: ::alloc::vec::Vec::new(),
                                            ty: anchor_lang::idl::types::IdlType::Pubkey,
                                        },
                                        anchor_lang::idl::types::IdlField {
                                            name: "input_vault_before".into(),
                                            docs: <[_]>::into_vec(
                                                ::alloc::boxed::box_new([
                                                    "pool vault sub trade fees".into(),
                                                ]),
                                            ),
                                            ty: anchor_lang::idl::types::IdlType::U64,
                                        },
                                        anchor_lang::idl::types::IdlField {
                                            name: "output_vault_before".into(),
                                            docs: <[_]>::into_vec(
                                                ::alloc::boxed::box_new([
                                                    "pool vault sub trade fees".into(),
                                                ]),
                                            ),
                                            ty: anchor_lang::idl::types::IdlType::U64,
                                        },
                                        anchor_lang::idl::types::IdlField {
                                            name: "input_amount".into(),
                                            docs: <[_]>::into_vec(
                                                ::alloc::boxed::box_new([
                                                    "calculate result without transfer fee".into(),
                                                ]),
                                            ),
                                            ty: anchor_lang::idl::types::IdlType::U64,
                                        },
                                        anchor_lang::idl::types::IdlField {
                                            name: "output_amount".into(),
                                            docs: <[_]>::into_vec(
                                                ::alloc::boxed::box_new([
                                                    "calculate result without transfer fee".into(),
                                                ]),
                                            ),
                                            ty: anchor_lang::idl::types::IdlType::U64,
                                        },
                                        anchor_lang::idl::types::IdlField {
                                            name: "input_transfer_fee".into(),
                                            docs: ::alloc::vec::Vec::new(),
                                            ty: anchor_lang::idl::types::IdlType::U64,
                                        },
                                        anchor_lang::idl::types::IdlField {
                                            name: "output_transfer_fee".into(),
                                            docs: ::alloc::vec::Vec::new(),
                                            ty: anchor_lang::idl::types::IdlType::U64,
                                        },
                                        anchor_lang::idl::types::IdlField {
                                            name: "base_input".into(),
                                            docs: ::alloc::vec::Vec::new(),
                                            ty: anchor_lang::idl::types::IdlType::Bool,
                                        },
                                    ]),
                                ),
                            ),
                        ),
                    },
                };
                let event = anchor_lang::idl::types::IdlEvent {
                    name: ty.name.clone(),
                    discriminator: Self::DISCRIMINATOR.into(),
                };
                types.insert(ty.name.clone(), ty);
                Some(event)
            }
        }
    }
    pub use events::*;
    pub mod oracle {
        /// Oracle provides price data useful for a wide variety of system designs
        ///
        use anchor_lang::prelude::*;
        use light_sdk::{
            compressible::{CompressionInfo, HasCompressionInfo},
            sha::LightHasher, CompressiblePack, LightDiscriminator,
        };
        use light_sdk_macros::Compressible;
        /// Seed to derive account address and signature
        pub const OBSERVATION_SEED: &str = "observation";
        pub const OBSERVATION_NUM: usize = 20;
        pub const OBSERVATION_UPDATE_DURATION_DEFAULT: u64 = 15;
        /// The element of observations in ObservationState
        pub struct Observation {
            /// The block timestamp of the observation
            pub block_timestamp: u64,
            /// the cumulative of token0 price during the duration time, Q32.32, the remaining 64 bit for overflow
            pub cumulative_token_0_price_x32: u128,
            /// the cumulative of token1 price during the duration time, Q32.32, the remaining 64 bit for overflow
            pub cumulative_token_1_price_x32: u128,
        }
        #[automatically_derived]
        impl ::core::default::Default for Observation {
            #[inline]
            fn default() -> Observation {
                Observation {
                    block_timestamp: ::core::default::Default::default(),
                    cumulative_token_0_price_x32: ::core::default::Default::default(),
                    cumulative_token_1_price_x32: ::core::default::Default::default(),
                }
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for Observation {
            #[inline]
            fn clone(&self) -> Observation {
                let _: ::core::clone::AssertParamIsClone<u64>;
                let _: ::core::clone::AssertParamIsClone<u128>;
                *self
            }
        }
        #[automatically_derived]
        impl ::core::marker::Copy for Observation {}
        impl borsh::ser::BorshSerialize for Observation
        where
            u64: borsh::ser::BorshSerialize,
            u128: borsh::ser::BorshSerialize,
            u128: borsh::ser::BorshSerialize,
        {
            fn serialize<W: borsh::maybestd::io::Write>(
                &self,
                writer: &mut W,
            ) -> ::core::result::Result<(), borsh::maybestd::io::Error> {
                borsh::BorshSerialize::serialize(&self.block_timestamp, writer)?;
                borsh::BorshSerialize::serialize(
                    &self.cumulative_token_0_price_x32,
                    writer,
                )?;
                borsh::BorshSerialize::serialize(
                    &self.cumulative_token_1_price_x32,
                    writer,
                )?;
                Ok(())
            }
        }
        impl anchor_lang::idl::build::IdlBuild for Observation {
            fn create_type() -> Option<anchor_lang::idl::types::IdlTypeDef> {
                Some(anchor_lang::idl::types::IdlTypeDef {
                    name: Self::get_full_path(),
                    docs: <[_]>::into_vec(
                        ::alloc::boxed::box_new([
                            "The element of observations in ObservationState".into(),
                        ]),
                    ),
                    serialization: anchor_lang::idl::types::IdlSerialization::default(),
                    repr: None,
                    generics: ::alloc::vec::Vec::new(),
                    ty: anchor_lang::idl::types::IdlTypeDefTy::Struct {
                        fields: Some(
                            anchor_lang::idl::types::IdlDefinedFields::Named(
                                <[_]>::into_vec(
                                    ::alloc::boxed::box_new([
                                        anchor_lang::idl::types::IdlField {
                                            name: "block_timestamp".into(),
                                            docs: <[_]>::into_vec(
                                                ::alloc::boxed::box_new([
                                                    "The block timestamp of the observation".into(),
                                                ]),
                                            ),
                                            ty: anchor_lang::idl::types::IdlType::U64,
                                        },
                                        anchor_lang::idl::types::IdlField {
                                            name: "cumulative_token_0_price_x32".into(),
                                            docs: <[_]>::into_vec(
                                                ::alloc::boxed::box_new([
                                                    "the cumulative of token0 price during the duration time, Q32.32, the remaining 64 bit for overflow"
                                                        .into(),
                                                ]),
                                            ),
                                            ty: anchor_lang::idl::types::IdlType::U128,
                                        },
                                        anchor_lang::idl::types::IdlField {
                                            name: "cumulative_token_1_price_x32".into(),
                                            docs: <[_]>::into_vec(
                                                ::alloc::boxed::box_new([
                                                    "the cumulative of token1 price during the duration time, Q32.32, the remaining 64 bit for overflow"
                                                        .into(),
                                                ]),
                                            ),
                                            ty: anchor_lang::idl::types::IdlType::U128,
                                        },
                                    ]),
                                ),
                            ),
                        ),
                    },
                })
            }
            fn insert_types(
                types: &mut std::collections::BTreeMap<
                    String,
                    anchor_lang::idl::types::IdlTypeDef,
                >,
            ) {}
            fn get_full_path() -> String {
                ::alloc::__export::must_use({
                    ::alloc::fmt::format(
                        format_args!(
                            "{0}::{1}",
                            "raydium_cp_swap::states::oracle",
                            "Observation",
                        ),
                    )
                })
            }
        }
        impl borsh::de::BorshDeserialize for Observation
        where
            u64: borsh::BorshDeserialize,
            u128: borsh::BorshDeserialize,
            u128: borsh::BorshDeserialize,
        {
            fn deserialize_reader<R: borsh::maybestd::io::Read>(
                reader: &mut R,
            ) -> ::core::result::Result<Self, borsh::maybestd::io::Error> {
                Ok(Self {
                    block_timestamp: borsh::BorshDeserialize::deserialize_reader(
                        reader,
                    )?,
                    cumulative_token_0_price_x32: borsh::BorshDeserialize::deserialize_reader(
                        reader,
                    )?,
                    cumulative_token_1_price_x32: borsh::BorshDeserialize::deserialize_reader(
                        reader,
                    )?,
                })
            }
        }
        #[automatically_derived]
        impl anchor_lang::Space for Observation {
            const INIT_SPACE: usize = 0 + 8 + 16 + 16;
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for Observation {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field3_finish(
                    f,
                    "Observation",
                    "block_timestamp",
                    &self.block_timestamp,
                    "cumulative_token_0_price_x32",
                    &self.cumulative_token_0_price_x32,
                    "cumulative_token_1_price_x32",
                    &&self.cumulative_token_1_price_x32,
                )
            }
        }
        /// Tip: The 'Compressible' macro derives compress/decompress methods for the
        /// account. CompressionInfo tracks the last_written_slot. Whenever a
        /// compressible account is written to, last_written_slot must be updated. If
        /// last_written_slot >= threshold (compression_delay), the account becomes
        /// eligible for compression. Eligible accounts can be compressed
        /// asynchronously.
        #[compress_as(observations = None)]
        pub struct ObservationState {
            /// Whether the ObservationState is initialized
            pub initialized: bool,
            /// the most-recently updated index of the observations array
            pub observation_index: u16,
            pub pool_id: Pubkey,
            /// observation array
            pub observations: Option<[Observation; OBSERVATION_NUM]>,
            /// #[skip] is required. Is Some when the account is decompressed and None
            /// when compressed.
            #[skip]
            pub compression_info: Option<CompressionInfo>,
            /// padding for feature update
            pub padding: [u64; 4],
        }
        impl ::light_hasher::to_byte_array::ToByteArray for ObservationState {
            const NUM_FIELDS: usize = 6usize;
            fn to_byte_array(
                &self,
            ) -> ::std::result::Result<[u8; 32], ::light_hasher::HasherError> {
                use borsh::BorshSerialize;
                use ::light_hasher::Hasher;
                let serialized = self
                    .try_to_vec()
                    .map_err(|_| ::light_hasher::HasherError::BorshError)?;
                let mut result = ::light_hasher::Sha256::hash(&serialized)?;
                result[0] = 0;
                Ok(result)
            }
        }
        impl ::light_hasher::DataHasher for ObservationState {
            fn hash<H>(
                &self,
            ) -> ::std::result::Result<[u8; 32], ::light_hasher::HasherError>
            where
                H: ::light_hasher::Hasher,
            {
                use ::light_hasher::Hasher;
                use borsh::BorshSerialize;
                let serialized = self
                    .try_to_vec()
                    .map_err(|_| ::light_hasher::HasherError::BorshError)?;
                let mut result = H::hash(&serialized)?;
                if H::ID != 0 {
                    result[0] = 0;
                }
                Ok(result)
            }
        }
        impl LightDiscriminator for ObservationState {
            const LIGHT_DISCRIMINATOR: [u8; 8] = [122, 174, 197, 53, 129, 9, 165, 132];
            const LIGHT_DISCRIMINATOR_SLICE: &'static [u8] = &Self::LIGHT_DISCRIMINATOR;
            fn discriminator() -> [u8; 8] {
                Self::LIGHT_DISCRIMINATOR
            }
        }
        impl light_sdk::compressible::HasCompressionInfo for ObservationState {
            fn compression_info(&self) -> &light_sdk::compressible::CompressionInfo {
                self.compression_info
                    .as_ref()
                    .expect("CompressionInfo must be Some on-chain")
            }
            fn compression_info_mut(
                &mut self,
            ) -> &mut light_sdk::compressible::CompressionInfo {
                self.compression_info
                    .as_mut()
                    .expect("CompressionInfo must be Some on-chain")
            }
            fn compression_info_mut_opt(
                &mut self,
            ) -> &mut Option<light_sdk::compressible::CompressionInfo> {
                &mut self.compression_info
            }
            fn set_compression_info_none(&mut self) {
                self.compression_info = None;
            }
        }
        impl light_sdk::account::Size for ObservationState {
            fn size(&self) -> usize {
                Self::LIGHT_DISCRIMINATOR.len() + Self::INIT_SPACE
            }
        }
        impl light_sdk::compressible::CompressAs for ObservationState {
            type Output = Self;
            fn compress_as(&self) -> std::borrow::Cow<'_, Self::Output> {
                std::borrow::Cow::Owned(Self {
                    initialized: self.initialized,
                    observation_index: self.observation_index,
                    pool_id: self.pool_id,
                    observations: None,
                    compression_info: None,
                    padding: self.padding.clone(),
                })
            }
        }
        impl light_sdk::compressible::compression_info::CompressedInitSpace
        for ObservationState {
            const COMPRESSED_INIT_SPACE: usize = Self::INIT_SPACE
                - (0 + (OBSERVATION_NUM as usize) * (<Observation>::INIT_SPACE)
                    + <CompressionInfo>::INIT_SPACE);
        }
        #[automatically_derived]
        impl anchor_lang::Space for ObservationState {
            const INIT_SPACE: usize = 0 + 1 + 2 + 32
                + (1
                    + (OBSERVATION_NUM
                        * <Observation as anchor_lang::Space>::INIT_SPACE))
                + (1 + <CompressionInfo as anchor_lang::Space>::INIT_SPACE) + (4 * 8);
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for ObservationState {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                let names: &'static _ = &[
                    "initialized",
                    "observation_index",
                    "pool_id",
                    "observations",
                    "compression_info",
                    "padding",
                ];
                let values: &[&dyn ::core::fmt::Debug] = &[
                    &self.initialized,
                    &self.observation_index,
                    &self.pool_id,
                    &self.observations,
                    &self.compression_info,
                    &&self.padding,
                ];
                ::core::fmt::Formatter::debug_struct_fields_finish(
                    f,
                    "ObservationState",
                    names,
                    values,
                )
            }
        }
        pub struct PackedObservationState {
            pub initialized: bool,
            pub observation_index: u16,
            pub pool_id: u8,
            pub observations: Option<[Observation; OBSERVATION_NUM]>,
            pub compression_info: Option<CompressionInfo>,
            pub padding: [u64; 4],
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for PackedObservationState {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                let names: &'static _ = &[
                    "initialized",
                    "observation_index",
                    "pool_id",
                    "observations",
                    "compression_info",
                    "padding",
                ];
                let values: &[&dyn ::core::fmt::Debug] = &[
                    &self.initialized,
                    &self.observation_index,
                    &self.pool_id,
                    &self.observations,
                    &self.compression_info,
                    &&self.padding,
                ];
                ::core::fmt::Formatter::debug_struct_fields_finish(
                    f,
                    "PackedObservationState",
                    names,
                    values,
                )
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for PackedObservationState {
            #[inline]
            fn clone(&self) -> PackedObservationState {
                PackedObservationState {
                    initialized: ::core::clone::Clone::clone(&self.initialized),
                    observation_index: ::core::clone::Clone::clone(
                        &self.observation_index,
                    ),
                    pool_id: ::core::clone::Clone::clone(&self.pool_id),
                    observations: ::core::clone::Clone::clone(&self.observations),
                    compression_info: ::core::clone::Clone::clone(
                        &self.compression_info,
                    ),
                    padding: ::core::clone::Clone::clone(&self.padding),
                }
            }
        }
        impl borsh::ser::BorshSerialize for PackedObservationState
        where
            bool: borsh::ser::BorshSerialize,
            u16: borsh::ser::BorshSerialize,
            u8: borsh::ser::BorshSerialize,
            Option<[Observation; OBSERVATION_NUM]>: borsh::ser::BorshSerialize,
            Option<CompressionInfo>: borsh::ser::BorshSerialize,
            [u64; 4]: borsh::ser::BorshSerialize,
        {
            fn serialize<W: borsh::maybestd::io::Write>(
                &self,
                writer: &mut W,
            ) -> ::core::result::Result<(), borsh::maybestd::io::Error> {
                borsh::BorshSerialize::serialize(&self.initialized, writer)?;
                borsh::BorshSerialize::serialize(&self.observation_index, writer)?;
                borsh::BorshSerialize::serialize(&self.pool_id, writer)?;
                borsh::BorshSerialize::serialize(&self.observations, writer)?;
                borsh::BorshSerialize::serialize(&self.compression_info, writer)?;
                borsh::BorshSerialize::serialize(&self.padding, writer)?;
                Ok(())
            }
        }
        impl anchor_lang::idl::build::IdlBuild for PackedObservationState {
            fn create_type() -> Option<anchor_lang::idl::types::IdlTypeDef> {
                Some(anchor_lang::idl::types::IdlTypeDef {
                    name: Self::get_full_path(),
                    docs: ::alloc::vec::Vec::new(),
                    serialization: anchor_lang::idl::types::IdlSerialization::default(),
                    repr: None,
                    generics: ::alloc::vec::Vec::new(),
                    ty: anchor_lang::idl::types::IdlTypeDefTy::Struct {
                        fields: Some(
                            anchor_lang::idl::types::IdlDefinedFields::Named(
                                <[_]>::into_vec(
                                    ::alloc::boxed::box_new([
                                        anchor_lang::idl::types::IdlField {
                                            name: "initialized".into(),
                                            docs: ::alloc::vec::Vec::new(),
                                            ty: anchor_lang::idl::types::IdlType::Bool,
                                        },
                                        anchor_lang::idl::types::IdlField {
                                            name: "observation_index".into(),
                                            docs: ::alloc::vec::Vec::new(),
                                            ty: anchor_lang::idl::types::IdlType::U16,
                                        },
                                        anchor_lang::idl::types::IdlField {
                                            name: "pool_id".into(),
                                            docs: ::alloc::vec::Vec::new(),
                                            ty: anchor_lang::idl::types::IdlType::U8,
                                        },
                                        anchor_lang::idl::types::IdlField {
                                            name: "observations".into(),
                                            docs: ::alloc::vec::Vec::new(),
                                            ty: anchor_lang::idl::types::IdlType::Option(
                                                Box::new(
                                                    anchor_lang::idl::types::IdlType::Array(
                                                        Box::new(anchor_lang::idl::types::IdlType::Defined {
                                                            name: <Observation>::get_full_path(),
                                                            generics: ::alloc::vec::Vec::new(),
                                                        }),
                                                        anchor_lang::idl::types::IdlArrayLen::Value(OBSERVATION_NUM),
                                                    ),
                                                ),
                                            ),
                                        },
                                        anchor_lang::idl::types::IdlField {
                                            name: "compression_info".into(),
                                            docs: ::alloc::vec::Vec::new(),
                                            ty: anchor_lang::idl::types::IdlType::Option(
                                                Box::new(anchor_lang::idl::types::IdlType::Defined {
                                                    name: <CompressionInfo>::get_full_path(),
                                                    generics: ::alloc::vec::Vec::new(),
                                                }),
                                            ),
                                        },
                                        anchor_lang::idl::types::IdlField {
                                            name: "padding".into(),
                                            docs: ::alloc::vec::Vec::new(),
                                            ty: anchor_lang::idl::types::IdlType::Array(
                                                Box::new(anchor_lang::idl::types::IdlType::U64),
                                                anchor_lang::idl::types::IdlArrayLen::Value(4),
                                            ),
                                        },
                                    ]),
                                ),
                            ),
                        ),
                    },
                })
            }
            fn insert_types(
                types: &mut std::collections::BTreeMap<
                    String,
                    anchor_lang::idl::types::IdlTypeDef,
                >,
            ) {
                if let Some(ty) = <Observation>::create_type() {
                    types.insert(<Observation>::get_full_path(), ty);
                    <Observation>::insert_types(types);
                }
                if let Some(ty) = <CompressionInfo>::create_type() {
                    types.insert(<CompressionInfo>::get_full_path(), ty);
                    <CompressionInfo>::insert_types(types);
                }
            }
            fn get_full_path() -> String {
                ::alloc::__export::must_use({
                    ::alloc::fmt::format(
                        format_args!(
                            "{0}::{1}",
                            "raydium_cp_swap::states::oracle",
                            "PackedObservationState",
                        ),
                    )
                })
            }
        }
        impl borsh::de::BorshDeserialize for PackedObservationState
        where
            bool: borsh::BorshDeserialize,
            u16: borsh::BorshDeserialize,
            u8: borsh::BorshDeserialize,
            Option<[Observation; OBSERVATION_NUM]>: borsh::BorshDeserialize,
            Option<CompressionInfo>: borsh::BorshDeserialize,
            [u64; 4]: borsh::BorshDeserialize,
        {
            fn deserialize_reader<R: borsh::maybestd::io::Read>(
                reader: &mut R,
            ) -> ::core::result::Result<Self, borsh::maybestd::io::Error> {
                Ok(Self {
                    initialized: borsh::BorshDeserialize::deserialize_reader(reader)?,
                    observation_index: borsh::BorshDeserialize::deserialize_reader(
                        reader,
                    )?,
                    pool_id: borsh::BorshDeserialize::deserialize_reader(reader)?,
                    observations: borsh::BorshDeserialize::deserialize_reader(reader)?,
                    compression_info: borsh::BorshDeserialize::deserialize_reader(
                        reader,
                    )?,
                    padding: borsh::BorshDeserialize::deserialize_reader(reader)?,
                })
            }
        }
        impl light_sdk::compressible::Pack for ObservationState {
            type Packed = PackedObservationState;
            #[inline(never)]
            fn pack(
                &self,
                remaining_accounts: &mut light_sdk::instruction::PackedAccounts,
            ) -> Self::Packed {
                PackedObservationState {
                    initialized: self.initialized,
                    observation_index: self.observation_index,
                    pool_id: remaining_accounts.insert_or_get(self.pool_id),
                    observations: self.observations.clone(),
                    compression_info: None,
                    padding: self.padding.clone(),
                }
            }
        }
        impl light_sdk::compressible::Unpack for ObservationState {
            type Unpacked = Self;
            #[inline(never)]
            fn unpack(
                &self,
                _remaining_accounts: &[anchor_lang::prelude::AccountInfo],
            ) -> std::result::Result<
                Self::Unpacked,
                anchor_lang::prelude::ProgramError,
            > {
                Ok(self.clone())
            }
        }
        impl light_sdk::compressible::Pack for PackedObservationState {
            type Packed = Self;
            #[inline(never)]
            fn pack(
                &self,
                _remaining_accounts: &mut light_sdk::instruction::PackedAccounts,
            ) -> Self::Packed {
                self.clone()
            }
        }
        impl light_sdk::compressible::Unpack for PackedObservationState {
            type Unpacked = ObservationState;
            #[inline(never)]
            fn unpack(
                &self,
                remaining_accounts: &[anchor_lang::prelude::AccountInfo],
            ) -> std::result::Result<
                Self::Unpacked,
                anchor_lang::prelude::ProgramError,
            > {
                Ok(ObservationState {
                    initialized: self.initialized,
                    observation_index: self.observation_index,
                    pool_id: *remaining_accounts[self.pool_id as usize].key,
                    observations: self.observations.clone(),
                    compression_info: None,
                    padding: self.padding.clone(),
                })
            }
        }
        impl borsh::ser::BorshSerialize for ObservationState
        where
            bool: borsh::ser::BorshSerialize,
            u16: borsh::ser::BorshSerialize,
            Pubkey: borsh::ser::BorshSerialize,
            Option<[Observation; OBSERVATION_NUM]>: borsh::ser::BorshSerialize,
            Option<CompressionInfo>: borsh::ser::BorshSerialize,
            [u64; 4]: borsh::ser::BorshSerialize,
        {
            fn serialize<W: borsh::maybestd::io::Write>(
                &self,
                writer: &mut W,
            ) -> ::core::result::Result<(), borsh::maybestd::io::Error> {
                borsh::BorshSerialize::serialize(&self.initialized, writer)?;
                borsh::BorshSerialize::serialize(&self.observation_index, writer)?;
                borsh::BorshSerialize::serialize(&self.pool_id, writer)?;
                borsh::BorshSerialize::serialize(&self.observations, writer)?;
                borsh::BorshSerialize::serialize(&self.compression_info, writer)?;
                borsh::BorshSerialize::serialize(&self.padding, writer)?;
                Ok(())
            }
        }
        impl anchor_lang::idl::build::IdlBuild for ObservationState {
            fn create_type() -> Option<anchor_lang::idl::types::IdlTypeDef> {
                Some(anchor_lang::idl::types::IdlTypeDef {
                    name: Self::get_full_path(),
                    docs: <[_]>::into_vec(
                        ::alloc::boxed::box_new([
                            "Tip: The 'Compressible' macro derives compress/decompress methods for the"
                                .into(),
                            "account. CompressionInfo tracks the last_written_slot. Whenever a"
                                .into(),
                            "compressible account is written to, last_written_slot must be updated. If"
                                .into(),
                            "last_written_slot >= threshold (compression_delay), the account becomes"
                                .into(),
                            "eligible for compression. Eligible accounts can be compressed"
                                .into(),
                            "asynchronously.".into(),
                        ]),
                    ),
                    serialization: anchor_lang::idl::types::IdlSerialization::default(),
                    repr: None,
                    generics: ::alloc::vec::Vec::new(),
                    ty: anchor_lang::idl::types::IdlTypeDefTy::Struct {
                        fields: Some(
                            anchor_lang::idl::types::IdlDefinedFields::Named(
                                <[_]>::into_vec(
                                    ::alloc::boxed::box_new([
                                        anchor_lang::idl::types::IdlField {
                                            name: "initialized".into(),
                                            docs: <[_]>::into_vec(
                                                ::alloc::boxed::box_new([
                                                    "Whether the ObservationState is initialized".into(),
                                                ]),
                                            ),
                                            ty: anchor_lang::idl::types::IdlType::Bool,
                                        },
                                        anchor_lang::idl::types::IdlField {
                                            name: "observation_index".into(),
                                            docs: <[_]>::into_vec(
                                                ::alloc::boxed::box_new([
                                                    "the most-recently updated index of the observations array"
                                                        .into(),
                                                ]),
                                            ),
                                            ty: anchor_lang::idl::types::IdlType::U16,
                                        },
                                        anchor_lang::idl::types::IdlField {
                                            name: "pool_id".into(),
                                            docs: ::alloc::vec::Vec::new(),
                                            ty: anchor_lang::idl::types::IdlType::Pubkey,
                                        },
                                        anchor_lang::idl::types::IdlField {
                                            name: "observations".into(),
                                            docs: <[_]>::into_vec(
                                                ::alloc::boxed::box_new(["observation array".into()]),
                                            ),
                                            ty: anchor_lang::idl::types::IdlType::Option(
                                                Box::new(
                                                    anchor_lang::idl::types::IdlType::Array(
                                                        Box::new(anchor_lang::idl::types::IdlType::Defined {
                                                            name: <Observation>::get_full_path(),
                                                            generics: ::alloc::vec::Vec::new(),
                                                        }),
                                                        anchor_lang::idl::types::IdlArrayLen::Value(OBSERVATION_NUM),
                                                    ),
                                                ),
                                            ),
                                        },
                                        anchor_lang::idl::types::IdlField {
                                            name: "compression_info".into(),
                                            docs: <[_]>::into_vec(
                                                ::alloc::boxed::box_new([
                                                    "#[skip] is required. Is Some when the account is decompressed and None"
                                                        .into(),
                                                    "when compressed.".into(),
                                                ]),
                                            ),
                                            ty: anchor_lang::idl::types::IdlType::Option(
                                                Box::new(anchor_lang::idl::types::IdlType::Defined {
                                                    name: <CompressionInfo>::get_full_path(),
                                                    generics: ::alloc::vec::Vec::new(),
                                                }),
                                            ),
                                        },
                                        anchor_lang::idl::types::IdlField {
                                            name: "padding".into(),
                                            docs: <[_]>::into_vec(
                                                ::alloc::boxed::box_new([
                                                    "padding for feature update".into(),
                                                ]),
                                            ),
                                            ty: anchor_lang::idl::types::IdlType::Array(
                                                Box::new(anchor_lang::idl::types::IdlType::U64),
                                                anchor_lang::idl::types::IdlArrayLen::Value(4),
                                            ),
                                        },
                                    ]),
                                ),
                            ),
                        ),
                    },
                })
            }
            fn insert_types(
                types: &mut std::collections::BTreeMap<
                    String,
                    anchor_lang::idl::types::IdlTypeDef,
                >,
            ) {
                if let Some(ty) = <Observation>::create_type() {
                    types.insert(<Observation>::get_full_path(), ty);
                    <Observation>::insert_types(types);
                }
                if let Some(ty) = <CompressionInfo>::create_type() {
                    types.insert(<CompressionInfo>::get_full_path(), ty);
                    <CompressionInfo>::insert_types(types);
                }
            }
            fn get_full_path() -> String {
                ::alloc::__export::must_use({
                    ::alloc::fmt::format(
                        format_args!(
                            "{0}::{1}",
                            "raydium_cp_swap::states::oracle",
                            "ObservationState",
                        ),
                    )
                })
            }
        }
        impl borsh::de::BorshDeserialize for ObservationState
        where
            bool: borsh::BorshDeserialize,
            u16: borsh::BorshDeserialize,
            Pubkey: borsh::BorshDeserialize,
            Option<[Observation; OBSERVATION_NUM]>: borsh::BorshDeserialize,
            Option<CompressionInfo>: borsh::BorshDeserialize,
            [u64; 4]: borsh::BorshDeserialize,
        {
            fn deserialize_reader<R: borsh::maybestd::io::Read>(
                reader: &mut R,
            ) -> ::core::result::Result<Self, borsh::maybestd::io::Error> {
                Ok(Self {
                    initialized: borsh::BorshDeserialize::deserialize_reader(reader)?,
                    observation_index: borsh::BorshDeserialize::deserialize_reader(
                        reader,
                    )?,
                    pool_id: borsh::BorshDeserialize::deserialize_reader(reader)?,
                    observations: borsh::BorshDeserialize::deserialize_reader(reader)?,
                    compression_info: borsh::BorshDeserialize::deserialize_reader(
                        reader,
                    )?,
                    padding: borsh::BorshDeserialize::deserialize_reader(reader)?,
                })
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for ObservationState {
            #[inline]
            fn clone(&self) -> ObservationState {
                ObservationState {
                    initialized: ::core::clone::Clone::clone(&self.initialized),
                    observation_index: ::core::clone::Clone::clone(
                        &self.observation_index,
                    ),
                    pool_id: ::core::clone::Clone::clone(&self.pool_id),
                    observations: ::core::clone::Clone::clone(&self.observations),
                    compression_info: ::core::clone::Clone::clone(
                        &self.compression_info,
                    ),
                    padding: ::core::clone::Clone::clone(&self.padding),
                }
            }
        }
        #[automatically_derived]
        impl anchor_lang::AccountSerialize for ObservationState {
            fn try_serialize<W: std::io::Write>(
                &self,
                writer: &mut W,
            ) -> anchor_lang::Result<()> {
                if writer.write_all(ObservationState::DISCRIMINATOR).is_err() {
                    return Err(
                        anchor_lang::error::ErrorCode::AccountDidNotSerialize.into(),
                    );
                }
                if AnchorSerialize::serialize(self, writer).is_err() {
                    return Err(
                        anchor_lang::error::ErrorCode::AccountDidNotSerialize.into(),
                    );
                }
                Ok(())
            }
        }
        #[automatically_derived]
        impl anchor_lang::AccountDeserialize for ObservationState {
            fn try_deserialize(buf: &mut &[u8]) -> anchor_lang::Result<Self> {
                if buf.len() < ObservationState::DISCRIMINATOR.len() {
                    return Err(
                        anchor_lang::error::ErrorCode::AccountDiscriminatorNotFound
                            .into(),
                    );
                }
                let given_disc = &buf[..ObservationState::DISCRIMINATOR.len()];
                if ObservationState::DISCRIMINATOR != given_disc {
                    return Err(
                        anchor_lang::error::Error::from(anchor_lang::error::AnchorError {
                                error_name: anchor_lang::error::ErrorCode::AccountDiscriminatorMismatch
                                    .name(),
                                error_code_number: anchor_lang::error::ErrorCode::AccountDiscriminatorMismatch
                                    .into(),
                                error_msg: anchor_lang::error::ErrorCode::AccountDiscriminatorMismatch
                                    .to_string(),
                                error_origin: Some(
                                    anchor_lang::error::ErrorOrigin::Source(anchor_lang::error::Source {
                                        filename: "programs/cp-swap/src/states/oracle.rs",
                                        line: 37u32,
                                    }),
                                ),
                                compared_values: None,
                            })
                            .with_account_name("ObservationState"),
                    );
                }
                Self::try_deserialize_unchecked(buf)
            }
            fn try_deserialize_unchecked(buf: &mut &[u8]) -> anchor_lang::Result<Self> {
                let mut data: &[u8] = &buf[ObservationState::DISCRIMINATOR.len()..];
                AnchorDeserialize::deserialize(&mut data)
                    .map_err(|_| {
                        anchor_lang::error::ErrorCode::AccountDidNotDeserialize.into()
                    })
            }
        }
        #[automatically_derived]
        impl anchor_lang::Discriminator for ObservationState {
            const DISCRIMINATOR: &'static [u8] = &[122, 174, 197, 53, 129, 9, 165, 132];
        }
        #[automatically_derived]
        impl anchor_lang::Owner for ObservationState {
            fn owner() -> Pubkey {
                crate::ID
            }
        }
        impl Default for ObservationState {
            #[inline]
            fn default() -> ObservationState {
                ObservationState {
                    initialized: false,
                    observation_index: 0,
                    pool_id: Pubkey::default(),
                    observations: None,
                    compression_info: None,
                    padding: [0u64; 4],
                }
            }
        }
        impl ObservationState {
            /// Writable at most once per second. Index represents the most recently written element.
            /// If the index is at the end of the allowable array length (100 - 1), the next index will turn to 0.
            ///
            /// # Arguments
            ///
            /// * `self` - The ObservationState account to write in
            /// * `block_timestamp` - The current timestamp of to update
            /// * `token_0_price_x32` - The token_0_price_x32 at the time of the new observation
            /// * `token_1_price_x32` - The token_1_price_x32 at the time of the new observation
            /// * `observation_index` - The last update index of element in the oracle array
            ///
            /// # Return
            /// * `next_observation_index` - The new index of element to update in the oracle array
            ///
            pub fn update(
                &mut self,
                block_timestamp: u64,
                token_0_price_x32: u128,
                token_1_price_x32: u128,
            ) {
                let observation_index = self.observation_index;
                if !self.initialized {
                    let observations = self
                        .observations
                        .get_or_insert_with(|| {
                            [Observation::default(); OBSERVATION_NUM]
                        });
                    self.initialized = true;
                    observations[observation_index as usize].block_timestamp = block_timestamp;
                    observations[observation_index as usize]
                        .cumulative_token_0_price_x32 = 0;
                    observations[observation_index as usize]
                        .cumulative_token_1_price_x32 = 0;
                    self.compression_info = Some(
                        CompressionInfo::new_decompressed().unwrap(),
                    );
                } else {
                    let observations = &mut self.observations.as_mut().unwrap();
                    let last_observation = observations[observation_index as usize];
                    let delta_time = block_timestamp
                        .saturating_sub(last_observation.block_timestamp);
                    if delta_time < OBSERVATION_UPDATE_DURATION_DEFAULT {
                        return;
                    }
                    let delta_token_0_price_x32 = token_0_price_x32
                        .checked_mul(delta_time.into())
                        .unwrap();
                    let delta_token_1_price_x32 = token_1_price_x32
                        .checked_mul(delta_time.into())
                        .unwrap();
                    let next_observation_index = if observation_index as usize
                        == OBSERVATION_NUM - 1
                    {
                        0
                    } else {
                        observation_index + 1
                    };
                    observations[next_observation_index as usize].block_timestamp = block_timestamp;
                    observations[next_observation_index as usize]
                        .cumulative_token_0_price_x32 = last_observation
                        .cumulative_token_0_price_x32
                        .wrapping_add(delta_token_0_price_x32);
                    observations[next_observation_index as usize]
                        .cumulative_token_1_price_x32 = last_observation
                        .cumulative_token_1_price_x32
                        .wrapping_add(delta_token_1_price_x32);
                    self.observation_index = next_observation_index;
                    self.compression_info_mut().bump_last_written_slot().unwrap();
                }
            }
        }
        /// Returns the block timestamp truncated to 32 bits, i.e. mod 2**32
        ///
        pub fn block_timestamp() -> u64 {
            Clock::get().unwrap().unix_timestamp as u64
        }
    }
    pub use oracle::*;
}
pub mod utils {
    pub mod compression {
        use crate::instructions::InitializeCompressionParams;
        use crate::states::*;
        use anchor_lang::prelude::*;
        use light_compressed_account::address::derive_address;
        use light_sdk::compressible::prepare_accounts_for_compression_on_init;
        use light_sdk::cpi::CpiAccountsSmall;
        use light_sdk::cpi::CpiInputs;
        use light_sdk_types::cpi_context_write::CpiContextWriteAccounts;
        use crate::LIGHT_CPI_SIGNER;
        pub const POOL_STATE_CREATION_INDEX: u8 = 0;
        pub const OBSERVATION_STATE_CREATION_INDEX: u8 = 1;
        pub const LP_MINT_CREATION_INDEX: u8 = 2;
        pub fn compress_pool_and_observation_pdas<'a, 'b, 'info>(
            cpi_accounts: &CpiAccountsSmall<'b, 'info>,
            pool_state: &Account<'info, PoolState>,
            observation_state: &Account<'info, ObservationState>,
            compression_params: &InitializeCompressionParams,
            rent_recipient: &AccountInfo<'info>,
            address_space: &[Pubkey],
        ) -> Result<()> {
            let pool_new_address_params = compression_params
                .pool_address_tree_info
                .into_new_address_params_assigned_packed(
                    pool_state.key().to_bytes(),
                    true,
                    Some(POOL_STATE_CREATION_INDEX),
                );
            let observation_new_address_params = compression_params
                .observation_address_tree_info
                .into_new_address_params_assigned_packed(
                    observation_state.key().to_bytes(),
                    true,
                    Some(OBSERVATION_STATE_CREATION_INDEX),
                );
            let pool_compressed_address = derive_address(
                &pool_state.key().to_bytes(),
                &cpi_accounts
                    .get_tree_address(
                        pool_new_address_params.address_merkle_tree_account_index,
                    )
                    .unwrap()
                    .key
                    .to_bytes(),
                &crate::ID.to_bytes(),
            );
            let observation_compressed_address = derive_address(
                &observation_state.key().to_bytes(),
                &cpi_accounts
                    .get_tree_address(
                        observation_new_address_params.address_merkle_tree_account_index,
                    )
                    .unwrap()
                    .key
                    .to_bytes(),
                &crate::ID.to_bytes(),
            );
            let mut all_compressed_infos = Vec::with_capacity(2);
            let pool_state_compressed_info = prepare_accounts_for_compression_on_init::<
                PoolState,
            >(
                &[pool_state],
                &[pool_compressed_address],
                &[pool_new_address_params],
                &[compression_params.output_state_tree_index],
                &cpi_accounts,
            )?;
            all_compressed_infos.extend(pool_state_compressed_info);
            let observation_compressed_infos = prepare_accounts_for_compression_on_init::<
                ObservationState,
            >(
                &[observation_state],
                &[observation_compressed_address],
                &[observation_new_address_params],
                &[compression_params.output_state_tree_index],
                &cpi_accounts,
            )?;
            all_compressed_infos.extend(observation_compressed_infos);
            let cpi_inputs = CpiInputs::new_first_cpi(
                all_compressed_infos,
                <[_]>::into_vec(
                    ::alloc::boxed::box_new([
                        pool_new_address_params,
                        observation_new_address_params,
                    ]),
                ),
            );
            let cpi_context = cpi_accounts.cpi_context().unwrap();
            let cpi_context_accounts = CpiContextWriteAccounts {
                fee_payer: cpi_accounts.fee_payer(),
                authority: cpi_accounts.authority().unwrap(),
                cpi_context,
                cpi_signer: LIGHT_CPI_SIGNER,
            };
            cpi_inputs.invoke_light_system_program_cpi_context(cpi_context_accounts)?;
            Ok(())
        }
    }
    pub mod ctoken {
        use crate::{
            instructions::InitializeCompressionParams, states::POOL_LP_MINT_SEED,
            utils::LP_MINT_CREATION_INDEX,
        };
        use anchor_lang::{prelude::*, solana_program::program::invoke_signed};
        use light_compressed_token_sdk::{
            instructions::{
                create_compressed_mint::instruction::derive_compressed_mint_from_spl_mint,
                create_mint_action_cpi,
                transfer2::{transfer_interface, transfer_interface_signed},
                CreateMintInputs, MintActionInputs, MintActionType,
            },
            CompressedProof,
        };
        use light_ctoken_types::{
            instructions::mint_action::CompressedMintWithContext,
            instructions::mint_action::CpiContext as CompressedCpiContext,
        };
        use light_sdk::cpi::CpiAccountsSmall;
        pub fn transfer_ctoken_from_user_to_pool_vault<'a>(
            authority: AccountInfo<'a>,
            from: AccountInfo<'a>,
            to_vault: AccountInfo<'a>,
            amount: u64,
        ) -> Result<()> {
            if amount == 0 {
                return Ok(());
            }
            transfer_interface(
                &from,
                &to_vault,
                &authority,
                amount,
                &authority,
                &authority,
                None,
                None,
                None,
                None,
            )?;
            Ok(())
        }
        pub fn transfer_ctoken_from_pool_vault_to_user<'a>(
            authority: AccountInfo<'a>,
            from_vault: AccountInfo<'a>,
            to: AccountInfo<'a>,
            amount: u64,
            signer_seeds: &[&[&[u8]]],
        ) -> Result<()> {
            if amount == 0 {
                return Ok(());
            }
            transfer_interface_signed(
                &from_vault,
                &to,
                &authority,
                amount,
                &authority,
                &authority,
                None,
                None,
                None,
                None,
                signer_seeds,
            )?;
            Ok(())
        }
        pub fn get_bumps(
            token_0_mint: Pubkey,
            token_1_mint: Pubkey,
            compressed_token_program: Pubkey,
        ) -> (u8, u8) {
            let compressed_token_0_pool_bump = Pubkey::find_program_address(
                    &[b"pool".as_ref(), token_0_mint.as_ref()],
                    &compressed_token_program,
                )
                .1;
            let compressed_token_1_pool_bump = Pubkey::find_program_address(
                    &[b"pool".as_ref(), token_1_mint.as_ref()],
                    &compressed_token_program,
                )
                .1;
            (compressed_token_0_pool_bump, compressed_token_1_pool_bump)
        }
        pub fn create_and_mint_lp<'a, 'b, 'info>(
            creator: AccountInfo<'info>,
            authority: AccountInfo<'info>,
            lp_mint_key: &Pubkey,
            lp_vault: AccountInfo<'info>,
            creator_lp_token: AccountInfo<'info>,
            lp_mint_signer: AccountInfo<'info>,
            pool_state_key: &Pubkey,
            compressed_token_program_cpi_authority: AccountInfo<'info>,
            compressed_token_program: AccountInfo<'info>,
            lp_mint_signer_bump: u8,
            compression_params: &InitializeCompressionParams,
            cpi_accounts: &CpiAccountsSmall<'b, 'info>,
            user_lp_amount: u64,
            vault_lp_amount: u64,
            pool_auth_bump: u8,
        ) -> Result<()> {
            let output_state_queue_idx: u8 = 0;
            let address_tree_idx: u8 = 1;
            let output_state_queue = *cpi_accounts
                .tree_accounts()
                .unwrap()[output_state_queue_idx as usize]
                .key;
            let address_tree_pubkey = *cpi_accounts
                .tree_accounts()
                .unwrap()[address_tree_idx as usize]
                .key;
            let mint_compressed_address = derive_compressed_mint_from_spl_mint(
                lp_mint_key,
                &address_tree_pubkey,
            );
            let compressed_mint_with_context = CompressedMintWithContext::new(
                mint_compressed_address,
                compression_params.lp_mint_address_tree_info.root_index,
                9,
                Some(authority.key().into()),
                Some(authority.key().into()),
                lp_mint_key.into(),
            );
            let actions = <[_]>::into_vec(
                ::alloc::boxed::box_new([
                    MintActionType::MintToCToken {
                        account: creator_lp_token.key(),
                        amount: user_lp_amount,
                    },
                    MintActionType::MintToCToken {
                        account: lp_vault.key(),
                        amount: vault_lp_amount,
                    },
                ]),
            );
            let inputs = CreateMintInputs {
                compressed_mint_inputs: compressed_mint_with_context,
                mint_seed: lp_mint_signer.key(),
                mint_bump: compression_params.lp_mint_bump,
                authority: authority.key().into(),
                payer: creator.key(),
                proof: compression_params.proof.0.map(|p| CompressedProof::from(p)),
                address_tree: address_tree_pubkey,
                output_queue: output_state_queue,
                actions,
            };
            let mint_action_instruction: anchor_lang::solana_program::instruction::Instruction = create_mint_action_cpi(
                    MintActionInputs::new_create_mint(inputs),
                    Some(
                        CompressedCpiContext::last_cpi_create_mint(
                            address_tree_idx,
                            output_state_queue_idx,
                            LP_MINT_CREATION_INDEX,
                        ),
                    ),
                    Some(cpi_accounts.cpi_context().unwrap().key()),
                )
                .map_err(|e| ProgramError::from(e))?;
            let mut account_infos = cpi_accounts.to_account_infos();
            account_infos
                .extend([
                    compressed_token_program_cpi_authority,
                    compressed_token_program,
                    authority,
                    lp_mint_signer,
                    creator,
                    lp_vault,
                    creator_lp_token,
                ]);
            invoke_signed(
                &mint_action_instruction,
                &account_infos,
                &[
                    &[
                        POOL_LP_MINT_SEED.as_bytes(),
                        pool_state_key.as_ref(),
                        &[lp_mint_signer_bump],
                    ],
                    &[crate::AUTH_SEED.as_bytes(), &[pool_auth_bump]],
                ],
            )?;
            Ok(())
        }
    }
    pub mod math {
        ///! 128 and 256 bit numbers
        ///! U128 is more efficient that u128
        ///! https://github.com/solana-labs/solana/issues/19549
        use uint::construct_uint;
        /// Little-endian large integer type
        #[repr(C)]
        pub struct U128(pub [u64; 2]);
        #[automatically_derived]
        impl ::core::marker::Copy for U128 {}
        #[automatically_derived]
        impl ::core::clone::Clone for U128 {
            #[inline]
            fn clone(&self) -> U128 {
                let _: ::core::clone::AssertParamIsClone<[u64; 2]>;
                *self
            }
        }
        #[automatically_derived]
        impl ::core::cmp::Eq for U128 {
            #[inline]
            #[doc(hidden)]
            #[coverage(off)]
            fn assert_receiver_is_total_eq(&self) -> () {
                let _: ::core::cmp::AssertParamIsEq<[u64; 2]>;
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for U128 {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for U128 {
            #[inline]
            fn eq(&self, other: &U128) -> bool {
                self.0 == other.0
            }
        }
        #[automatically_derived]
        impl ::core::hash::Hash for U128 {
            #[inline]
            fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                ::core::hash::Hash::hash(&self.0, state)
            }
        }
        /// Get a reference to the underlying little-endian words.
        impl AsRef<[u64]> for U128 {
            #[inline]
            fn as_ref(&self) -> &[u64] {
                &self.0
            }
        }
        impl<'a> From<&'a U128> for U128 {
            fn from(x: &'a U128) -> U128 {
                *x
            }
        }
        impl U128 {
            const WORD_BITS: usize = 64;
            /// Maximum value.
            pub const MAX: U128 = U128([u64::max_value(); 2]);
            /// Converts a string slice in a given base to an integer. Only supports radixes of 10
            /// and 16.
            pub fn from_str_radix(
                txt: &str,
                radix: u32,
            ) -> Result<Self, ::uint::FromStrRadixErr> {
                let parsed = match radix {
                    10 => Self::from_dec_str(txt)?,
                    16 => core::str::FromStr::from_str(txt)?,
                    _ => return Err(::uint::FromStrRadixErr::unsupported()),
                };
                Ok(parsed)
            }
            /// Convert from a decimal string.
            pub fn from_dec_str(
                value: &str,
            ) -> ::uint::core_::result::Result<Self, ::uint::FromDecStrErr> {
                let mut res = Self::default();
                for b in value.bytes().map(|b| b.wrapping_sub(b'0')) {
                    if b > 9 {
                        return Err(::uint::FromDecStrErr::InvalidCharacter);
                    }
                    let (r, overflow) = res.overflowing_mul_u64(10);
                    if overflow > 0 {
                        return Err(::uint::FromDecStrErr::InvalidLength);
                    }
                    let (r, overflow) = r.overflowing_add(b.into());
                    if overflow {
                        return Err(::uint::FromDecStrErr::InvalidLength);
                    }
                    res = r;
                }
                Ok(res)
            }
            /// Conversion to u32
            #[inline]
            pub const fn low_u32(&self) -> u32 {
                let &U128(ref arr) = self;
                arr[0] as u32
            }
            /// Low word (u64)
            #[inline]
            pub const fn low_u64(&self) -> u64 {
                let &U128(ref arr) = self;
                arr[0]
            }
            /// Conversion to u32 with overflow checking
            ///
            /// # Panics
            ///
            /// Panics if the number is larger than 2^32.
            #[inline]
            pub fn as_u32(&self) -> u32 {
                let &U128(ref arr) = self;
                if !self.fits_word() || arr[0] > u32::max_value() as u64 {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!("Integer overflow when casting to u32"),
                        );
                    }
                }
                self.as_u64() as u32
            }
            /// Conversion to u64 with overflow checking
            ///
            /// # Panics
            ///
            /// Panics if the number is larger than u64::max_value().
            #[inline]
            pub fn as_u64(&self) -> u64 {
                let &U128(ref arr) = self;
                if !self.fits_word() {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!("Integer overflow when casting to u64"),
                        );
                    }
                }
                arr[0]
            }
            /// Conversion to usize with overflow checking
            ///
            /// # Panics
            ///
            /// Panics if the number is larger than usize::max_value().
            #[inline]
            pub fn as_usize(&self) -> usize {
                let &U128(ref arr) = self;
                if !self.fits_word() || arr[0] > usize::max_value() as u64 {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!("Integer overflow when casting to usize"),
                        );
                    }
                }
                arr[0] as usize
            }
            /// Whether this is zero.
            #[inline]
            pub const fn is_zero(&self) -> bool {
                let &U128(ref arr) = self;
                let mut i = 0;
                while i < 2 {
                    if arr[i] != 0 {
                        return false;
                    } else {
                        i += 1;
                    }
                }
                return true;
            }
            #[inline]
            fn fits_word(&self) -> bool {
                let &U128(ref arr) = self;
                for i in 1..2 {
                    if arr[i] != 0 {
                        return false;
                    }
                }
                return true;
            }
            /// Return the least number of bits needed to represent the number
            #[inline]
            pub fn bits(&self) -> usize {
                let &U128(ref arr) = self;
                for i in 1..2 {
                    if arr[2 - i] > 0 {
                        return (0x40 * (2 - i + 1))
                            - arr[2 - i].leading_zeros() as usize;
                    }
                }
                0x40 - arr[0].leading_zeros() as usize
            }
            /// Return if specific bit is set.
            ///
            /// # Panics
            ///
            /// Panics if `index` exceeds the bit width of the number.
            #[inline]
            pub const fn bit(&self, index: usize) -> bool {
                let &U128(ref arr) = self;
                arr[index / 64] & (1 << (index % 64)) != 0
            }
            /// Returns the number of leading zeros in the binary representation of self.
            pub fn leading_zeros(&self) -> u32 {
                let mut r = 0;
                for i in 0..2 {
                    let w = self.0[2 - i - 1];
                    if w == 0 {
                        r += 64;
                    } else {
                        r += w.leading_zeros();
                        break;
                    }
                }
                r
            }
            /// Returns the number of trailing zeros in the binary representation of self.
            pub fn trailing_zeros(&self) -> u32 {
                let mut r = 0;
                for i in 0..2 {
                    let w = self.0[i];
                    if w == 0 {
                        r += 64;
                    } else {
                        r += w.trailing_zeros();
                        break;
                    }
                }
                r
            }
            /// Return specific byte. Byte 0 is the least significant value (ie~ little endian).
            ///
            /// # Panics
            ///
            /// Panics if `index` exceeds the byte width of the number.
            #[inline]
            pub const fn byte(&self, index: usize) -> u8 {
                let &U128(ref arr) = self;
                (arr[index / 8] >> (((index % 8)) * 8)) as u8
            }
            /// Convert to big-endian bytes.
            #[inline]
            pub fn to_big_endian(&self) -> [u8; 2 * 8] {
                let mut bytes = [0u8; 2 * 8];
                self.write_as_big_endian(&mut bytes);
                bytes
            }
            /// Write to the slice in big-endian format.
            #[inline]
            pub fn write_as_big_endian(&self, bytes: &mut [u8]) {
                use ::uint::byteorder::{ByteOrder, BigEndian};
                if true {
                    {
                        match 2 * 8 == bytes.len() {
                            true => {}
                            _ => {
                                ::core::panicking::panic(
                                    "assertion failed: 2 * 8 == bytes.len()",
                                )
                            }
                        }
                    };
                }
                for i in 0..2 {
                    BigEndian::write_u64(&mut bytes[8 * i..], self.0[2 - i - 1]);
                }
            }
            /// Convert to little-endian bytes.
            #[inline]
            pub fn to_little_endian(&self) -> [u8; 2 * 8] {
                let mut bytes = [0u8; 2 * 8];
                self.write_as_little_endian(&mut bytes);
                bytes
            }
            #[inline]
            pub fn write_as_little_endian(&self, bytes: &mut [u8]) {
                use ::uint::byteorder::{ByteOrder, LittleEndian};
                if true {
                    {
                        match 2 * 8 == bytes.len() {
                            true => {}
                            _ => {
                                ::core::panicking::panic(
                                    "assertion failed: 2 * 8 == bytes.len()",
                                )
                            }
                        }
                    };
                }
                for i in 0..2 {
                    LittleEndian::write_u64(&mut bytes[8 * i..], self.0[i]);
                }
            }
            /// Create `10**n` as this type.
            ///
            /// # Panics
            ///
            /// Panics if the result overflows the type.
            #[inline]
            pub fn exp10(n: usize) -> Self {
                match n {
                    0 => Self::from(1u64),
                    _ => Self::exp10(n - 1) * 10u32,
                }
            }
            /// Zero (additive identity) of this type.
            #[inline]
            pub const fn zero() -> Self {
                Self([0; 2])
            }
            /// One (multiplicative identity) of this type.
            #[inline]
            pub const fn one() -> Self {
                let mut words = [0; 2];
                words[0] = 1u64;
                Self(words)
            }
            /// The maximum value which can be inhabited by this type.
            #[inline]
            pub const fn max_value() -> Self {
                Self::MAX
            }
            fn full_shl(self, shift: u32) -> [u64; 2 + 1] {
                if true {
                    {
                        match shift < Self::WORD_BITS as u32 {
                            true => {}
                            _ => {
                                ::core::panicking::panic(
                                    "assertion failed: shift < Self::WORD_BITS as u32",
                                )
                            }
                        }
                    };
                }
                let mut u = [0u64; 2 + 1];
                let u_lo = self.0[0] << shift;
                let u_hi = self >> (Self::WORD_BITS as u32 - shift);
                u[0] = u_lo;
                u[1..].copy_from_slice(&u_hi.0[..]);
                u
            }
            fn full_shr(u: [u64; 2 + 1], shift: u32) -> Self {
                if true {
                    {
                        match shift < Self::WORD_BITS as u32 {
                            true => {}
                            _ => {
                                ::core::panicking::panic(
                                    "assertion failed: shift < Self::WORD_BITS as u32",
                                )
                            }
                        }
                    };
                }
                let mut res = Self::zero();
                for i in 0..2 {
                    res.0[i] = u[i] >> shift;
                }
                if shift > 0 {
                    for i in 1..=2 {
                        res.0[i - 1] |= u[i] << (Self::WORD_BITS as u32 - shift);
                    }
                }
                res
            }
            fn full_mul_u64(self, by: u64) -> [u64; 2 + 1] {
                let (prod, carry) = self.overflowing_mul_u64(by);
                let mut res = [0u64; 2 + 1];
                res[..2].copy_from_slice(&prod.0[..]);
                res[2] = carry;
                res
            }
            fn div_mod_small(mut self, other: u64) -> (Self, Self) {
                let mut rem = 0u64;
                self.0
                    .iter_mut()
                    .rev()
                    .for_each(|d| {
                        let (q, r) = Self::div_mod_word(rem, *d, other);
                        *d = q;
                        rem = r;
                    });
                (self, rem.into())
            }
            fn div_mod_knuth(self, mut v: Self, n: usize, m: usize) -> (Self, Self) {
                if true {
                    {
                        match self.bits() >= v.bits() && !v.fits_word() {
                            true => {}
                            _ => {
                                ::core::panicking::panic(
                                    "assertion failed: self.bits() >= v.bits() && !v.fits_word()",
                                )
                            }
                        }
                    };
                }
                if true {
                    {
                        match n + m <= 2 {
                            true => {}
                            _ => ::core::panicking::panic("assertion failed: n + m <= 2"),
                        }
                    };
                }
                let shift = v.0[n - 1].leading_zeros();
                v <<= shift;
                let mut u = self.full_shl(shift);
                let mut q = Self::zero();
                let v_n_1 = v.0[n - 1];
                let v_n_2 = v.0[n - 2];
                for j in (0..=m).rev() {
                    let u_jn = u[j + n];
                    let mut q_hat = if u_jn < v_n_1 {
                        let (mut q_hat, mut r_hat) = Self::div_mod_word(
                            u_jn,
                            u[j + n - 1],
                            v_n_1,
                        );
                        loop {
                            let (hi, lo) = Self::split_u128(
                                u128::from(q_hat) * u128::from(v_n_2),
                            );
                            if (hi, lo) <= (r_hat, u[j + n - 2]) {
                                break;
                            }
                            q_hat -= 1;
                            let (new_r_hat, overflow) = r_hat.overflowing_add(v_n_1);
                            r_hat = new_r_hat;
                            if overflow {
                                break;
                            }
                        }
                        q_hat
                    } else {
                        u64::max_value()
                    };
                    let q_hat_v = v.full_mul_u64(q_hat);
                    let c = Self::sub_slice(&mut u[j..], &q_hat_v[..n + 1]);
                    if c {
                        q_hat -= 1;
                        let c = Self::add_slice(&mut u[j..], &v.0[..n]);
                        u[j + n] = u[j + n].wrapping_add(u64::from(c));
                    }
                    q.0[j] = q_hat;
                }
                let remainder = Self::full_shr(u, shift);
                (q, remainder)
            }
            fn words(bits: usize) -> usize {
                if true {
                    {
                        match bits > 0 {
                            true => {}
                            _ => ::core::panicking::panic("assertion failed: bits > 0"),
                        }
                    };
                }
                1 + (bits - 1) / Self::WORD_BITS
            }
            /// Returns a pair `(self / other, self % other)`.
            ///
            /// # Panics
            ///
            /// Panics if `other` is zero.
            pub fn div_mod(mut self, mut other: Self) -> (Self, Self) {
                use ::uint::core_::cmp::Ordering;
                let my_bits = self.bits();
                let your_bits = other.bits();
                {
                    match your_bits != 0 {
                        true => {}
                        _ => {
                            ::core::panicking::panic_fmt(
                                format_args!("division by zero"),
                            );
                        }
                    }
                };
                if my_bits < your_bits {
                    return (Self::zero(), self);
                }
                if your_bits <= Self::WORD_BITS {
                    return self.div_mod_small(other.low_u64());
                }
                let (n, m) = {
                    let my_words = Self::words(my_bits);
                    let your_words = Self::words(your_bits);
                    (your_words, my_words - your_words)
                };
                self.div_mod_knuth(other, n, m)
            }
            /// Compute the highest `n` such that `n * n <= self`.
            pub fn integer_sqrt(&self) -> Self {
                let one = Self::one();
                if self <= &one {
                    return *self;
                }
                let shift: u32 = (self.bits() as u32 + 1) / 2;
                let mut x_prev = one << shift;
                loop {
                    let x = (x_prev + self / x_prev) >> 1;
                    if x >= x_prev {
                        return x_prev;
                    }
                    x_prev = x;
                }
            }
            /// Fast exponentiation by squaring
            /// https://en.wikipedia.org/wiki/Exponentiation_by_squaring
            ///
            /// # Panics
            ///
            /// Panics if the result overflows the type.
            pub fn pow(self, expon: Self) -> Self {
                if expon.is_zero() {
                    return Self::one();
                }
                let is_even = |x: &Self| x.low_u64() & 1 == 0;
                let u_one = Self::one();
                let mut y = u_one;
                let mut n = expon;
                let mut x = self;
                while n > u_one {
                    if is_even(&n) {
                        x = x * x;
                        n >>= 1usize;
                    } else {
                        y = x * y;
                        x = x * x;
                        n.0[2 - 1] &= (!0u64) >> 1;
                        n >>= 1usize;
                    }
                }
                x * y
            }
            /// Fast exponentiation by squaring. Returns result and overflow flag.
            pub fn overflowing_pow(self, expon: Self) -> (Self, bool) {
                if expon.is_zero() {
                    return (Self::one(), false);
                }
                let is_even = |x: &Self| x.low_u64() & 1 == 0;
                let u_one = Self::one();
                let mut y = u_one;
                let mut n = expon;
                let mut x = self;
                let mut overflow = false;
                while n > u_one {
                    if is_even(&n) {
                        x = {
                            let (overflow_x, overflow_overflow) = x.overflowing_mul(x);
                            overflow |= overflow_overflow;
                            overflow_x
                        };
                        n >>= 1usize;
                    } else {
                        y = {
                            let (overflow_x, overflow_overflow) = x.overflowing_mul(y);
                            overflow |= overflow_overflow;
                            overflow_x
                        };
                        x = {
                            let (overflow_x, overflow_overflow) = x.overflowing_mul(x);
                            overflow |= overflow_overflow;
                            overflow_x
                        };
                        n = (n - u_one) >> 1usize;
                    }
                }
                let res = {
                    let (overflow_x, overflow_overflow) = x.overflowing_mul(y);
                    overflow |= overflow_overflow;
                    overflow_x
                };
                (res, overflow)
            }
            /// Checked exponentiation. Returns `None` if overflow occurred.
            pub fn checked_pow(self, expon: U128) -> Option<U128> {
                match self.overflowing_pow(expon) {
                    (_, true) => None,
                    (val, _) => Some(val),
                }
            }
            /// Addition which overflows and returns a flag if it does.
            #[inline(always)]
            pub fn overflowing_add(self, other: U128) -> (U128, bool) {
                {
                    use ::uint::core_ as core;
                    let U128(ref me) = self;
                    let U128(ref you) = other;
                    let mut ret = [0u64; 2];
                    let mut carry = 0u64;
                    #[allow(unknown_lints, eq_op)]
                    const _: [(); 0
                        - !{
                            const ASSERT: bool = core::isize::MAX as usize
                                / core::mem::size_of::<u64>() > 2;
                            ASSERT
                        } as usize] = [];
                    use ::uint::unroll;
                    #[allow(non_upper_case_globals)] #[allow(unused_comparisons)]
                    {
                        {
                            const i: usize = 0;
                            {
                                if i >= 0 {
                                    use core::ptr;
                                    if carry != 0 {
                                        let (res1, overflow1) = (u64::overflowing_add)(
                                            me[i],
                                            you[i],
                                        );
                                        let (res2, overflow2) = (u64::overflowing_add)(res1, carry);
                                        ret[i] = res2;
                                        carry = (overflow1 as u8 + overflow2 as u8) as u64;
                                    } else {
                                        let (res, overflow) = (u64::overflowing_add)(me[i], you[i]);
                                        ret[i] = res;
                                        carry = overflow as u64;
                                    }
                                }
                            }
                        }
                        {
                            const i: usize = 0 + 1;
                            {
                                if i >= 0 {
                                    use core::ptr;
                                    if carry != 0 {
                                        let (res1, overflow1) = (u64::overflowing_add)(
                                            me[i],
                                            you[i],
                                        );
                                        let (res2, overflow2) = (u64::overflowing_add)(res1, carry);
                                        ret[i] = res2;
                                        carry = (overflow1 as u8 + overflow2 as u8) as u64;
                                    } else {
                                        let (res, overflow) = (u64::overflowing_add)(me[i], you[i]);
                                        ret[i] = res;
                                        carry = overflow as u64;
                                    }
                                }
                            }
                        };
                    }
                    (U128(ret), carry > 0)
                }
            }
            /// Addition which saturates at the maximum value (Self::MAX).
            pub fn saturating_add(self, other: U128) -> U128 {
                match self.overflowing_add(other) {
                    (_, true) => U128::MAX,
                    (val, false) => val,
                }
            }
            /// Checked addition. Returns `None` if overflow occurred.
            pub fn checked_add(self, other: U128) -> Option<U128> {
                match self.overflowing_add(other) {
                    (_, true) => None,
                    (val, _) => Some(val),
                }
            }
            /// Subtraction which underflows and returns a flag if it does.
            #[inline(always)]
            pub fn overflowing_sub(self, other: U128) -> (U128, bool) {
                {
                    use ::uint::core_ as core;
                    let U128(ref me) = self;
                    let U128(ref you) = other;
                    let mut ret = [0u64; 2];
                    let mut carry = 0u64;
                    #[allow(unknown_lints, eq_op)]
                    const _: [(); 0
                        - !{
                            const ASSERT: bool = core::isize::MAX as usize
                                / core::mem::size_of::<u64>() > 2;
                            ASSERT
                        } as usize] = [];
                    use ::uint::unroll;
                    #[allow(non_upper_case_globals)] #[allow(unused_comparisons)]
                    {
                        {
                            const i: usize = 0;
                            {
                                if i >= 0 {
                                    use core::ptr;
                                    if carry != 0 {
                                        let (res1, overflow1) = (u64::overflowing_sub)(
                                            me[i],
                                            you[i],
                                        );
                                        let (res2, overflow2) = (u64::overflowing_sub)(res1, carry);
                                        ret[i] = res2;
                                        carry = (overflow1 as u8 + overflow2 as u8) as u64;
                                    } else {
                                        let (res, overflow) = (u64::overflowing_sub)(me[i], you[i]);
                                        ret[i] = res;
                                        carry = overflow as u64;
                                    }
                                }
                            }
                        }
                        {
                            const i: usize = 0 + 1;
                            {
                                if i >= 0 {
                                    use core::ptr;
                                    if carry != 0 {
                                        let (res1, overflow1) = (u64::overflowing_sub)(
                                            me[i],
                                            you[i],
                                        );
                                        let (res2, overflow2) = (u64::overflowing_sub)(res1, carry);
                                        ret[i] = res2;
                                        carry = (overflow1 as u8 + overflow2 as u8) as u64;
                                    } else {
                                        let (res, overflow) = (u64::overflowing_sub)(me[i], you[i]);
                                        ret[i] = res;
                                        carry = overflow as u64;
                                    }
                                }
                            }
                        };
                    }
                    (U128(ret), carry > 0)
                }
            }
            /// Subtraction which saturates at zero.
            pub fn saturating_sub(self, other: U128) -> U128 {
                match self.overflowing_sub(other) {
                    (_, true) => U128::zero(),
                    (val, false) => val,
                }
            }
            /// Checked subtraction. Returns `None` if overflow occurred.
            pub fn checked_sub(self, other: U128) -> Option<U128> {
                match self.overflowing_sub(other) {
                    (_, true) => None,
                    (val, _) => Some(val),
                }
            }
            /// Computes the absolute difference between self and other.
            pub fn abs_diff(self, other: U128) -> U128 {
                if self > other {
                    self.overflowing_sub(other).0
                } else {
                    other.overflowing_sub(self).0
                }
            }
            /// Multiply with overflow, returning a flag if it does.
            #[inline(always)]
            pub fn overflowing_mul(self, other: U128) -> (U128, bool) {
                {
                    let ret: [u64; 2 * 2] = {
                        {
                            #![allow(unused_assignments)]
                            let U128(ref me) = self;
                            let U128(ref you) = other;
                            let mut ret = [0u64; 2 * 2];
                            use ::uint::unroll;
                            #[allow(non_upper_case_globals)] #[allow(unused_comparisons)]
                            {
                                {
                                    const i: usize = 0;
                                    {
                                        if i >= 0 {
                                            let mut carry = 0u64;
                                            let b = you[i];
                                            #[allow(non_upper_case_globals)]
                                            #[allow(unused_comparisons)]
                                            {
                                                {
                                                    const j: usize = 0;
                                                    {
                                                        if j >= 0 {
                                                            if (|_, _| true)(me[j], carry) {
                                                                let a = me[j];
                                                                let (hi, low) = Self::split_u128(a as u128 * b as u128);
                                                                let overflow = {
                                                                    let existing_low = &mut ret[i + j];
                                                                    let (low, o) = low.overflowing_add(*existing_low);
                                                                    *existing_low = low;
                                                                    o
                                                                };
                                                                carry = {
                                                                    let existing_hi = &mut ret[i + j + 1];
                                                                    let hi = hi + overflow as u64;
                                                                    let (hi, o0) = hi.overflowing_add(carry);
                                                                    let (hi, o1) = hi.overflowing_add(*existing_hi);
                                                                    *existing_hi = hi;
                                                                    (o0 | o1) as u64
                                                                };
                                                            }
                                                        }
                                                    }
                                                }
                                                {
                                                    const j: usize = 0 + 1;
                                                    {
                                                        if j >= 0 {
                                                            if (|_, _| true)(me[j], carry) {
                                                                let a = me[j];
                                                                let (hi, low) = Self::split_u128(a as u128 * b as u128);
                                                                let overflow = {
                                                                    let existing_low = &mut ret[i + j];
                                                                    let (low, o) = low.overflowing_add(*existing_low);
                                                                    *existing_low = low;
                                                                    o
                                                                };
                                                                carry = {
                                                                    let existing_hi = &mut ret[i + j + 1];
                                                                    let hi = hi + overflow as u64;
                                                                    let (hi, o0) = hi.overflowing_add(carry);
                                                                    let (hi, o1) = hi.overflowing_add(*existing_hi);
                                                                    *existing_hi = hi;
                                                                    (o0 | o1) as u64
                                                                };
                                                            }
                                                        }
                                                    }
                                                };
                                            }
                                        }
                                    }
                                }
                                {
                                    const i: usize = 0 + 1;
                                    {
                                        if i >= 0 {
                                            let mut carry = 0u64;
                                            let b = you[i];
                                            #[allow(non_upper_case_globals)]
                                            #[allow(unused_comparisons)]
                                            {
                                                {
                                                    const j: usize = 0;
                                                    {
                                                        if j >= 0 {
                                                            if (|_, _| true)(me[j], carry) {
                                                                let a = me[j];
                                                                let (hi, low) = Self::split_u128(a as u128 * b as u128);
                                                                let overflow = {
                                                                    let existing_low = &mut ret[i + j];
                                                                    let (low, o) = low.overflowing_add(*existing_low);
                                                                    *existing_low = low;
                                                                    o
                                                                };
                                                                carry = {
                                                                    let existing_hi = &mut ret[i + j + 1];
                                                                    let hi = hi + overflow as u64;
                                                                    let (hi, o0) = hi.overflowing_add(carry);
                                                                    let (hi, o1) = hi.overflowing_add(*existing_hi);
                                                                    *existing_hi = hi;
                                                                    (o0 | o1) as u64
                                                                };
                                                            }
                                                        }
                                                    }
                                                }
                                                {
                                                    const j: usize = 0 + 1;
                                                    {
                                                        if j >= 0 {
                                                            if (|_, _| true)(me[j], carry) {
                                                                let a = me[j];
                                                                let (hi, low) = Self::split_u128(a as u128 * b as u128);
                                                                let overflow = {
                                                                    let existing_low = &mut ret[i + j];
                                                                    let (low, o) = low.overflowing_add(*existing_low);
                                                                    *existing_low = low;
                                                                    o
                                                                };
                                                                carry = {
                                                                    let existing_hi = &mut ret[i + j + 1];
                                                                    let hi = hi + overflow as u64;
                                                                    let (hi, o0) = hi.overflowing_add(carry);
                                                                    let (hi, o1) = hi.overflowing_add(*existing_hi);
                                                                    *existing_hi = hi;
                                                                    (o0 | o1) as u64
                                                                };
                                                            }
                                                        }
                                                    }
                                                };
                                            }
                                        }
                                    }
                                };
                            }
                            ret
                        }
                    };
                    let ret: [[u64; 2]; 2] = unsafe {
                        ::uint::core_::mem::transmute(ret)
                    };
                    #[inline(always)]
                    fn any_nonzero(arr: &[u64; 2]) -> bool {
                        use ::uint::unroll;
                        #[allow(non_upper_case_globals)] #[allow(unused_comparisons)]
                        {
                            {
                                const i: usize = 0;
                                {
                                    if i >= 0 {
                                        if arr[i] != 0 {
                                            return true;
                                        }
                                    }
                                }
                            }
                            {
                                const i: usize = 0 + 1;
                                {
                                    if i >= 0 {
                                        if arr[i] != 0 {
                                            return true;
                                        }
                                    }
                                }
                            };
                        }
                        false
                    }
                    (U128(ret[0]), any_nonzero(&ret[1]))
                }
            }
            /// Multiplication which saturates at the maximum value..
            pub fn saturating_mul(self, other: U128) -> U128 {
                match self.overflowing_mul(other) {
                    (_, true) => U128::MAX,
                    (val, false) => val,
                }
            }
            /// Checked multiplication. Returns `None` if overflow occurred.
            pub fn checked_mul(self, other: U128) -> Option<U128> {
                match self.overflowing_mul(other) {
                    (_, true) => None,
                    (val, _) => Some(val),
                }
            }
            /// Checked division. Returns `None` if `other == 0`.
            pub fn checked_div(self, other: U128) -> Option<U128> {
                if other.is_zero() { None } else { Some(self / other) }
            }
            /// Checked modulus. Returns `None` if `other == 0`.
            pub fn checked_rem(self, other: U128) -> Option<U128> {
                if other.is_zero() { None } else { Some(self % other) }
            }
            /// Negation with overflow.
            pub fn overflowing_neg(self) -> (U128, bool) {
                if self.is_zero() { (self, false) } else { (!self + 1, true) }
            }
            /// Checked negation. Returns `None` unless `self == 0`.
            pub fn checked_neg(self) -> Option<U128> {
                match self.overflowing_neg() {
                    (_, true) => None,
                    (zero, false) => Some(zero),
                }
            }
            #[inline(always)]
            fn div_mod_word(hi: u64, lo: u64, y: u64) -> (u64, u64) {
                if true {
                    {
                        match hi < y {
                            true => {}
                            _ => ::core::panicking::panic("assertion failed: hi < y"),
                        }
                    };
                }
                let x = (u128::from(hi) << 64) + u128::from(lo);
                let y = u128::from(y);
                ((x / y) as u64, (x % y) as u64)
            }
            #[inline(always)]
            fn add_slice(a: &mut [u64], b: &[u64]) -> bool {
                Self::binop_slice(a, b, u64::overflowing_add)
            }
            #[inline(always)]
            fn sub_slice(a: &mut [u64], b: &[u64]) -> bool {
                Self::binop_slice(a, b, u64::overflowing_sub)
            }
            #[inline(always)]
            fn binop_slice(
                a: &mut [u64],
                b: &[u64],
                binop: impl Fn(u64, u64) -> (u64, bool) + Copy,
            ) -> bool {
                let mut c = false;
                a.iter_mut()
                    .zip(b.iter())
                    .for_each(|(x, y)| {
                        let (res, carry) = Self::binop_carry(*x, *y, c, binop);
                        *x = res;
                        c = carry;
                    });
                c
            }
            #[inline(always)]
            fn binop_carry(
                a: u64,
                b: u64,
                c: bool,
                binop: impl Fn(u64, u64) -> (u64, bool),
            ) -> (u64, bool) {
                let (res1, overflow1) = b.overflowing_add(u64::from(c));
                let (res2, overflow2) = binop(a, res1);
                (res2, overflow1 || overflow2)
            }
            #[inline(always)]
            const fn mul_u64(a: u64, b: u64, carry: u64) -> (u64, u64) {
                let (hi, lo) = Self::split_u128(a as u128 * b as u128 + carry as u128);
                (lo, hi)
            }
            #[inline(always)]
            const fn split(a: u64) -> (u64, u64) {
                (a >> 32, a & 0xFFFF_FFFF)
            }
            #[inline(always)]
            const fn split_u128(a: u128) -> (u64, u64) {
                ((a >> 64) as _, (a & 0xFFFFFFFFFFFFFFFF) as _)
            }
            /// Overflowing multiplication by u64.
            /// Returns the result and carry.
            fn overflowing_mul_u64(mut self, other: u64) -> (Self, u64) {
                let mut carry = 0u64;
                for d in self.0.iter_mut() {
                    let (res, c) = Self::mul_u64(*d, other, carry);
                    *d = res;
                    carry = c;
                }
                (self, carry)
            }
            /// Converts from big endian representation bytes in memory.
            pub fn from_big_endian(slice: &[u8]) -> Self {
                use ::uint::byteorder::{ByteOrder, BigEndian};
                {
                    match 2 * 8 >= slice.len() {
                        true => {}
                        _ => {
                            ::core::panicking::panic(
                                "assertion failed: 2 * 8 >= slice.len()",
                            )
                        }
                    }
                };
                let mut padded = [0u8; 2 * 8];
                padded[2 * 8 - slice.len()..2 * 8].copy_from_slice(&slice);
                let mut ret = [0; 2];
                for i in 0..2 {
                    ret[2 - i - 1] = BigEndian::read_u64(&padded[8 * i..]);
                }
                U128(ret)
            }
            /// Converts from little endian representation bytes in memory.
            pub fn from_little_endian(slice: &[u8]) -> Self {
                use ::uint::byteorder::{ByteOrder, LittleEndian};
                {
                    match 2 * 8 >= slice.len() {
                        true => {}
                        _ => {
                            ::core::panicking::panic(
                                "assertion failed: 2 * 8 >= slice.len()",
                            )
                        }
                    }
                };
                let mut padded = [0u8; 2 * 8];
                padded[0..slice.len()].copy_from_slice(&slice);
                let mut ret = [0; 2];
                for i in 0..2 {
                    ret[i] = LittleEndian::read_u64(&padded[8 * i..]);
                }
                U128(ret)
            }
            fn fmt_hex(
                &self,
                f: &mut ::uint::core_::fmt::Formatter,
                is_lower: bool,
            ) -> ::uint::core_::fmt::Result {
                let &U128(ref data) = self;
                if self.is_zero() {
                    return f.pad_integral(true, "0x", "0");
                }
                let mut latch = false;
                let mut buf = [0_u8; 2 * 16];
                let mut i = 0;
                for ch in data.iter().rev() {
                    for x in 0..16 {
                        let nibble = (ch & (15u64 << ((15 - x) * 4) as u64))
                            >> (((15 - x) * 4) as u64);
                        if !latch {
                            latch = nibble != 0;
                        }
                        if latch {
                            let nibble = match nibble {
                                0..=9 => nibble as u8 + b'0',
                                _ if is_lower => nibble as u8 - 10 + b'a',
                                _ => nibble as u8 - 10 + b'A',
                            };
                            buf[i] = nibble;
                            i += 1;
                        }
                    }
                }
                let s = unsafe { ::uint::core_::str::from_utf8_unchecked(&buf[0..i]) };
                f.pad_integral(true, "0x", s)
            }
        }
        impl ::uint::core_::default::Default for U128 {
            fn default() -> Self {
                U128::zero()
            }
        }
        impl ::uint::core_::convert::From<u64> for U128 {
            fn from(value: u64) -> U128 {
                let mut ret = [0; 2];
                ret[0] = value;
                U128(ret)
            }
        }
        impl From<u8> for U128 {
            fn from(value: u8) -> U128 {
                From::from(value as u64)
            }
        }
        impl From<u16> for U128 {
            fn from(value: u16) -> U128 {
                From::from(value as u64)
            }
        }
        impl From<u32> for U128 {
            fn from(value: u32) -> U128 {
                From::from(value as u64)
            }
        }
        impl From<usize> for U128 {
            fn from(value: usize) -> U128 {
                From::from(value as u64)
            }
        }
        impl ::uint::core_::convert::From<i64> for U128 {
            fn from(value: i64) -> U128 {
                match value >= 0 {
                    true => From::from(value as u64),
                    false => {
                        {
                            ::core::panicking::panic_fmt(
                                format_args!(
                                    "Unsigned integer can\'t be created from negative value",
                                ),
                            );
                        };
                    }
                }
            }
        }
        impl From<i8> for U128 {
            fn from(value: i8) -> U128 {
                From::from(value as i64)
            }
        }
        impl From<i16> for U128 {
            fn from(value: i16) -> U128 {
                From::from(value as i64)
            }
        }
        impl From<i32> for U128 {
            fn from(value: i32) -> U128 {
                From::from(value as i64)
            }
        }
        impl From<isize> for U128 {
            fn from(value: isize) -> U128 {
                From::from(value as i64)
            }
        }
        impl ::uint::core_::convert::TryFrom<U128> for u8 {
            type Error = &'static str;
            #[inline]
            fn try_from(u: U128) -> ::uint::core_::result::Result<u8, &'static str> {
                let U128(arr) = u;
                if !u.fits_word() || arr[0] > <u8>::max_value() as u64 {
                    Err("integer overflow when casting to u8")
                } else {
                    Ok(arr[0] as u8)
                }
            }
        }
        impl ::uint::core_::convert::TryFrom<U128> for u16 {
            type Error = &'static str;
            #[inline]
            fn try_from(u: U128) -> ::uint::core_::result::Result<u16, &'static str> {
                let U128(arr) = u;
                if !u.fits_word() || arr[0] > <u16>::max_value() as u64 {
                    Err("integer overflow when casting to u16")
                } else {
                    Ok(arr[0] as u16)
                }
            }
        }
        impl ::uint::core_::convert::TryFrom<U128> for u32 {
            type Error = &'static str;
            #[inline]
            fn try_from(u: U128) -> ::uint::core_::result::Result<u32, &'static str> {
                let U128(arr) = u;
                if !u.fits_word() || arr[0] > <u32>::max_value() as u64 {
                    Err("integer overflow when casting to u32")
                } else {
                    Ok(arr[0] as u32)
                }
            }
        }
        impl ::uint::core_::convert::TryFrom<U128> for usize {
            type Error = &'static str;
            #[inline]
            fn try_from(u: U128) -> ::uint::core_::result::Result<usize, &'static str> {
                let U128(arr) = u;
                if !u.fits_word() || arr[0] > <usize>::max_value() as u64 {
                    Err("integer overflow when casting to usize")
                } else {
                    Ok(arr[0] as usize)
                }
            }
        }
        impl ::uint::core_::convert::TryFrom<U128> for u64 {
            type Error = &'static str;
            #[inline]
            fn try_from(u: U128) -> ::uint::core_::result::Result<u64, &'static str> {
                let U128(arr) = u;
                if !u.fits_word() || arr[0] > <u64>::max_value() as u64 {
                    Err("integer overflow when casting to u64")
                } else {
                    Ok(arr[0] as u64)
                }
            }
        }
        impl ::uint::core_::convert::TryFrom<U128> for i8 {
            type Error = &'static str;
            #[inline]
            fn try_from(u: U128) -> ::uint::core_::result::Result<i8, &'static str> {
                let U128(arr) = u;
                if !u.fits_word() || arr[0] > <i8>::max_value() as u64 {
                    Err("integer overflow when casting to i8")
                } else {
                    Ok(arr[0] as i8)
                }
            }
        }
        impl ::uint::core_::convert::TryFrom<U128> for i16 {
            type Error = &'static str;
            #[inline]
            fn try_from(u: U128) -> ::uint::core_::result::Result<i16, &'static str> {
                let U128(arr) = u;
                if !u.fits_word() || arr[0] > <i16>::max_value() as u64 {
                    Err("integer overflow when casting to i16")
                } else {
                    Ok(arr[0] as i16)
                }
            }
        }
        impl ::uint::core_::convert::TryFrom<U128> for i32 {
            type Error = &'static str;
            #[inline]
            fn try_from(u: U128) -> ::uint::core_::result::Result<i32, &'static str> {
                let U128(arr) = u;
                if !u.fits_word() || arr[0] > <i32>::max_value() as u64 {
                    Err("integer overflow when casting to i32")
                } else {
                    Ok(arr[0] as i32)
                }
            }
        }
        impl ::uint::core_::convert::TryFrom<U128> for isize {
            type Error = &'static str;
            #[inline]
            fn try_from(u: U128) -> ::uint::core_::result::Result<isize, &'static str> {
                let U128(arr) = u;
                if !u.fits_word() || arr[0] > <isize>::max_value() as u64 {
                    Err("integer overflow when casting to isize")
                } else {
                    Ok(arr[0] as isize)
                }
            }
        }
        impl ::uint::core_::convert::TryFrom<U128> for i64 {
            type Error = &'static str;
            #[inline]
            fn try_from(u: U128) -> ::uint::core_::result::Result<i64, &'static str> {
                let U128(arr) = u;
                if !u.fits_word() || arr[0] > <i64>::max_value() as u64 {
                    Err("integer overflow when casting to i64")
                } else {
                    Ok(arr[0] as i64)
                }
            }
        }
        impl<T> ::uint::core_::ops::Add<T> for U128
        where
            T: Into<U128>,
        {
            type Output = U128;
            fn add(self, other: T) -> U128 {
                let (result, overflow) = self.overflowing_add(other.into());
                if overflow {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!("arithmetic operation overflow"),
                        );
                    }
                }
                result
            }
        }
        impl<'a, T> ::uint::core_::ops::Add<T> for &'a U128
        where
            T: Into<U128>,
        {
            type Output = U128;
            fn add(self, other: T) -> U128 {
                *self + other
            }
        }
        impl ::uint::core_::ops::AddAssign<U128> for U128 {
            fn add_assign(&mut self, other: U128) {
                let (result, overflow) = self.overflowing_add(other);
                if overflow {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!("arithmetic operation overflow"),
                        );
                    }
                }
                *self = result;
            }
        }
        impl<T> ::uint::core_::ops::Sub<T> for U128
        where
            T: Into<U128>,
        {
            type Output = U128;
            #[inline]
            fn sub(self, other: T) -> U128 {
                let (result, overflow) = self.overflowing_sub(other.into());
                if overflow {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!("arithmetic operation overflow"),
                        );
                    }
                }
                result
            }
        }
        impl<'a, T> ::uint::core_::ops::Sub<T> for &'a U128
        where
            T: Into<U128>,
        {
            type Output = U128;
            fn sub(self, other: T) -> U128 {
                *self - other
            }
        }
        impl ::uint::core_::ops::SubAssign<U128> for U128 {
            fn sub_assign(&mut self, other: U128) {
                let (result, overflow) = self.overflowing_sub(other);
                if overflow {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!("arithmetic operation overflow"),
                        );
                    }
                }
                *self = result;
            }
        }
        impl ::uint::core_::ops::Mul<U128> for U128 {
            type Output = U128;
            fn mul(self, other: U128) -> U128 {
                let bignum: U128 = other.into();
                let (result, overflow) = self.overflowing_mul(bignum);
                if overflow {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!("arithmetic operation overflow"),
                        );
                    }
                }
                result
            }
        }
        impl<'a> ::uint::core_::ops::Mul<&'a U128> for U128 {
            type Output = U128;
            fn mul(self, other: &'a U128) -> U128 {
                let bignum: U128 = (*other).into();
                let (result, overflow) = self.overflowing_mul(bignum);
                if overflow {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!("arithmetic operation overflow"),
                        );
                    }
                }
                result
            }
        }
        impl<'a> ::uint::core_::ops::Mul<&'a U128> for &'a U128 {
            type Output = U128;
            fn mul(self, other: &'a U128) -> U128 {
                let bignum: U128 = (*other).into();
                let (result, overflow) = self.overflowing_mul(bignum);
                if overflow {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!("arithmetic operation overflow"),
                        );
                    }
                }
                result
            }
        }
        impl<'a> ::uint::core_::ops::Mul<U128> for &'a U128 {
            type Output = U128;
            fn mul(self, other: U128) -> U128 {
                let bignum: U128 = other.into();
                let (result, overflow) = self.overflowing_mul(bignum);
                if overflow {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!("arithmetic operation overflow"),
                        );
                    }
                }
                result
            }
        }
        impl ::uint::core_::ops::MulAssign<U128> for U128 {
            fn mul_assign(&mut self, other: U128) {
                let result = *self * other;
                *self = result;
            }
        }
        impl ::uint::core_::ops::Mul<u8> for U128 {
            type Output = U128;
            fn mul(self, other: u8) -> U128 {
                let (result, carry) = self.overflowing_mul_u64(other as u64);
                if carry > 0 {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!("arithmetic operation overflow"),
                        );
                    }
                }
                result
            }
        }
        impl<'a> ::uint::core_::ops::Mul<&'a u8> for U128 {
            type Output = U128;
            fn mul(self, other: &'a u8) -> U128 {
                let (result, carry) = self.overflowing_mul_u64(*other as u64);
                if carry > 0 {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!("arithmetic operation overflow"),
                        );
                    }
                }
                result
            }
        }
        impl<'a> ::uint::core_::ops::Mul<&'a u8> for &'a U128 {
            type Output = U128;
            fn mul(self, other: &'a u8) -> U128 {
                let (result, carry) = self.overflowing_mul_u64(*other as u64);
                if carry > 0 {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!("arithmetic operation overflow"),
                        );
                    }
                }
                result
            }
        }
        impl<'a> ::uint::core_::ops::Mul<u8> for &'a U128 {
            type Output = U128;
            fn mul(self, other: u8) -> U128 {
                let (result, carry) = self.overflowing_mul_u64(other as u64);
                if carry > 0 {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!("arithmetic operation overflow"),
                        );
                    }
                }
                result
            }
        }
        impl ::uint::core_::ops::MulAssign<u8> for U128 {
            fn mul_assign(&mut self, other: u8) {
                let result = *self * (other as u64);
                *self = result;
            }
        }
        impl ::uint::core_::ops::Mul<u16> for U128 {
            type Output = U128;
            fn mul(self, other: u16) -> U128 {
                let (result, carry) = self.overflowing_mul_u64(other as u64);
                if carry > 0 {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!("arithmetic operation overflow"),
                        );
                    }
                }
                result
            }
        }
        impl<'a> ::uint::core_::ops::Mul<&'a u16> for U128 {
            type Output = U128;
            fn mul(self, other: &'a u16) -> U128 {
                let (result, carry) = self.overflowing_mul_u64(*other as u64);
                if carry > 0 {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!("arithmetic operation overflow"),
                        );
                    }
                }
                result
            }
        }
        impl<'a> ::uint::core_::ops::Mul<&'a u16> for &'a U128 {
            type Output = U128;
            fn mul(self, other: &'a u16) -> U128 {
                let (result, carry) = self.overflowing_mul_u64(*other as u64);
                if carry > 0 {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!("arithmetic operation overflow"),
                        );
                    }
                }
                result
            }
        }
        impl<'a> ::uint::core_::ops::Mul<u16> for &'a U128 {
            type Output = U128;
            fn mul(self, other: u16) -> U128 {
                let (result, carry) = self.overflowing_mul_u64(other as u64);
                if carry > 0 {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!("arithmetic operation overflow"),
                        );
                    }
                }
                result
            }
        }
        impl ::uint::core_::ops::MulAssign<u16> for U128 {
            fn mul_assign(&mut self, other: u16) {
                let result = *self * (other as u64);
                *self = result;
            }
        }
        impl ::uint::core_::ops::Mul<u32> for U128 {
            type Output = U128;
            fn mul(self, other: u32) -> U128 {
                let (result, carry) = self.overflowing_mul_u64(other as u64);
                if carry > 0 {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!("arithmetic operation overflow"),
                        );
                    }
                }
                result
            }
        }
        impl<'a> ::uint::core_::ops::Mul<&'a u32> for U128 {
            type Output = U128;
            fn mul(self, other: &'a u32) -> U128 {
                let (result, carry) = self.overflowing_mul_u64(*other as u64);
                if carry > 0 {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!("arithmetic operation overflow"),
                        );
                    }
                }
                result
            }
        }
        impl<'a> ::uint::core_::ops::Mul<&'a u32> for &'a U128 {
            type Output = U128;
            fn mul(self, other: &'a u32) -> U128 {
                let (result, carry) = self.overflowing_mul_u64(*other as u64);
                if carry > 0 {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!("arithmetic operation overflow"),
                        );
                    }
                }
                result
            }
        }
        impl<'a> ::uint::core_::ops::Mul<u32> for &'a U128 {
            type Output = U128;
            fn mul(self, other: u32) -> U128 {
                let (result, carry) = self.overflowing_mul_u64(other as u64);
                if carry > 0 {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!("arithmetic operation overflow"),
                        );
                    }
                }
                result
            }
        }
        impl ::uint::core_::ops::MulAssign<u32> for U128 {
            fn mul_assign(&mut self, other: u32) {
                let result = *self * (other as u64);
                *self = result;
            }
        }
        impl ::uint::core_::ops::Mul<u64> for U128 {
            type Output = U128;
            fn mul(self, other: u64) -> U128 {
                let (result, carry) = self.overflowing_mul_u64(other as u64);
                if carry > 0 {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!("arithmetic operation overflow"),
                        );
                    }
                }
                result
            }
        }
        impl<'a> ::uint::core_::ops::Mul<&'a u64> for U128 {
            type Output = U128;
            fn mul(self, other: &'a u64) -> U128 {
                let (result, carry) = self.overflowing_mul_u64(*other as u64);
                if carry > 0 {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!("arithmetic operation overflow"),
                        );
                    }
                }
                result
            }
        }
        impl<'a> ::uint::core_::ops::Mul<&'a u64> for &'a U128 {
            type Output = U128;
            fn mul(self, other: &'a u64) -> U128 {
                let (result, carry) = self.overflowing_mul_u64(*other as u64);
                if carry > 0 {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!("arithmetic operation overflow"),
                        );
                    }
                }
                result
            }
        }
        impl<'a> ::uint::core_::ops::Mul<u64> for &'a U128 {
            type Output = U128;
            fn mul(self, other: u64) -> U128 {
                let (result, carry) = self.overflowing_mul_u64(other as u64);
                if carry > 0 {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!("arithmetic operation overflow"),
                        );
                    }
                }
                result
            }
        }
        impl ::uint::core_::ops::MulAssign<u64> for U128 {
            fn mul_assign(&mut self, other: u64) {
                let result = *self * (other as u64);
                *self = result;
            }
        }
        impl ::uint::core_::ops::Mul<usize> for U128 {
            type Output = U128;
            fn mul(self, other: usize) -> U128 {
                let (result, carry) = self.overflowing_mul_u64(other as u64);
                if carry > 0 {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!("arithmetic operation overflow"),
                        );
                    }
                }
                result
            }
        }
        impl<'a> ::uint::core_::ops::Mul<&'a usize> for U128 {
            type Output = U128;
            fn mul(self, other: &'a usize) -> U128 {
                let (result, carry) = self.overflowing_mul_u64(*other as u64);
                if carry > 0 {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!("arithmetic operation overflow"),
                        );
                    }
                }
                result
            }
        }
        impl<'a> ::uint::core_::ops::Mul<&'a usize> for &'a U128 {
            type Output = U128;
            fn mul(self, other: &'a usize) -> U128 {
                let (result, carry) = self.overflowing_mul_u64(*other as u64);
                if carry > 0 {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!("arithmetic operation overflow"),
                        );
                    }
                }
                result
            }
        }
        impl<'a> ::uint::core_::ops::Mul<usize> for &'a U128 {
            type Output = U128;
            fn mul(self, other: usize) -> U128 {
                let (result, carry) = self.overflowing_mul_u64(other as u64);
                if carry > 0 {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!("arithmetic operation overflow"),
                        );
                    }
                }
                result
            }
        }
        impl ::uint::core_::ops::MulAssign<usize> for U128 {
            fn mul_assign(&mut self, other: usize) {
                let result = *self * (other as u64);
                *self = result;
            }
        }
        impl ::uint::core_::ops::Mul<i8> for U128 {
            type Output = U128;
            fn mul(self, other: i8) -> U128 {
                let (result, carry) = self.overflowing_mul_u64(other as u64);
                if carry > 0 {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!("arithmetic operation overflow"),
                        );
                    }
                }
                result
            }
        }
        impl<'a> ::uint::core_::ops::Mul<&'a i8> for U128 {
            type Output = U128;
            fn mul(self, other: &'a i8) -> U128 {
                let (result, carry) = self.overflowing_mul_u64(*other as u64);
                if carry > 0 {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!("arithmetic operation overflow"),
                        );
                    }
                }
                result
            }
        }
        impl<'a> ::uint::core_::ops::Mul<&'a i8> for &'a U128 {
            type Output = U128;
            fn mul(self, other: &'a i8) -> U128 {
                let (result, carry) = self.overflowing_mul_u64(*other as u64);
                if carry > 0 {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!("arithmetic operation overflow"),
                        );
                    }
                }
                result
            }
        }
        impl<'a> ::uint::core_::ops::Mul<i8> for &'a U128 {
            type Output = U128;
            fn mul(self, other: i8) -> U128 {
                let (result, carry) = self.overflowing_mul_u64(other as u64);
                if carry > 0 {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!("arithmetic operation overflow"),
                        );
                    }
                }
                result
            }
        }
        impl ::uint::core_::ops::MulAssign<i8> for U128 {
            fn mul_assign(&mut self, other: i8) {
                let result = *self * (other as u64);
                *self = result;
            }
        }
        impl ::uint::core_::ops::Mul<i16> for U128 {
            type Output = U128;
            fn mul(self, other: i16) -> U128 {
                let (result, carry) = self.overflowing_mul_u64(other as u64);
                if carry > 0 {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!("arithmetic operation overflow"),
                        );
                    }
                }
                result
            }
        }
        impl<'a> ::uint::core_::ops::Mul<&'a i16> for U128 {
            type Output = U128;
            fn mul(self, other: &'a i16) -> U128 {
                let (result, carry) = self.overflowing_mul_u64(*other as u64);
                if carry > 0 {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!("arithmetic operation overflow"),
                        );
                    }
                }
                result
            }
        }
        impl<'a> ::uint::core_::ops::Mul<&'a i16> for &'a U128 {
            type Output = U128;
            fn mul(self, other: &'a i16) -> U128 {
                let (result, carry) = self.overflowing_mul_u64(*other as u64);
                if carry > 0 {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!("arithmetic operation overflow"),
                        );
                    }
                }
                result
            }
        }
        impl<'a> ::uint::core_::ops::Mul<i16> for &'a U128 {
            type Output = U128;
            fn mul(self, other: i16) -> U128 {
                let (result, carry) = self.overflowing_mul_u64(other as u64);
                if carry > 0 {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!("arithmetic operation overflow"),
                        );
                    }
                }
                result
            }
        }
        impl ::uint::core_::ops::MulAssign<i16> for U128 {
            fn mul_assign(&mut self, other: i16) {
                let result = *self * (other as u64);
                *self = result;
            }
        }
        impl ::uint::core_::ops::Mul<i32> for U128 {
            type Output = U128;
            fn mul(self, other: i32) -> U128 {
                let (result, carry) = self.overflowing_mul_u64(other as u64);
                if carry > 0 {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!("arithmetic operation overflow"),
                        );
                    }
                }
                result
            }
        }
        impl<'a> ::uint::core_::ops::Mul<&'a i32> for U128 {
            type Output = U128;
            fn mul(self, other: &'a i32) -> U128 {
                let (result, carry) = self.overflowing_mul_u64(*other as u64);
                if carry > 0 {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!("arithmetic operation overflow"),
                        );
                    }
                }
                result
            }
        }
        impl<'a> ::uint::core_::ops::Mul<&'a i32> for &'a U128 {
            type Output = U128;
            fn mul(self, other: &'a i32) -> U128 {
                let (result, carry) = self.overflowing_mul_u64(*other as u64);
                if carry > 0 {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!("arithmetic operation overflow"),
                        );
                    }
                }
                result
            }
        }
        impl<'a> ::uint::core_::ops::Mul<i32> for &'a U128 {
            type Output = U128;
            fn mul(self, other: i32) -> U128 {
                let (result, carry) = self.overflowing_mul_u64(other as u64);
                if carry > 0 {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!("arithmetic operation overflow"),
                        );
                    }
                }
                result
            }
        }
        impl ::uint::core_::ops::MulAssign<i32> for U128 {
            fn mul_assign(&mut self, other: i32) {
                let result = *self * (other as u64);
                *self = result;
            }
        }
        impl ::uint::core_::ops::Mul<i64> for U128 {
            type Output = U128;
            fn mul(self, other: i64) -> U128 {
                let (result, carry) = self.overflowing_mul_u64(other as u64);
                if carry > 0 {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!("arithmetic operation overflow"),
                        );
                    }
                }
                result
            }
        }
        impl<'a> ::uint::core_::ops::Mul<&'a i64> for U128 {
            type Output = U128;
            fn mul(self, other: &'a i64) -> U128 {
                let (result, carry) = self.overflowing_mul_u64(*other as u64);
                if carry > 0 {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!("arithmetic operation overflow"),
                        );
                    }
                }
                result
            }
        }
        impl<'a> ::uint::core_::ops::Mul<&'a i64> for &'a U128 {
            type Output = U128;
            fn mul(self, other: &'a i64) -> U128 {
                let (result, carry) = self.overflowing_mul_u64(*other as u64);
                if carry > 0 {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!("arithmetic operation overflow"),
                        );
                    }
                }
                result
            }
        }
        impl<'a> ::uint::core_::ops::Mul<i64> for &'a U128 {
            type Output = U128;
            fn mul(self, other: i64) -> U128 {
                let (result, carry) = self.overflowing_mul_u64(other as u64);
                if carry > 0 {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!("arithmetic operation overflow"),
                        );
                    }
                }
                result
            }
        }
        impl ::uint::core_::ops::MulAssign<i64> for U128 {
            fn mul_assign(&mut self, other: i64) {
                let result = *self * (other as u64);
                *self = result;
            }
        }
        impl ::uint::core_::ops::Mul<isize> for U128 {
            type Output = U128;
            fn mul(self, other: isize) -> U128 {
                let (result, carry) = self.overflowing_mul_u64(other as u64);
                if carry > 0 {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!("arithmetic operation overflow"),
                        );
                    }
                }
                result
            }
        }
        impl<'a> ::uint::core_::ops::Mul<&'a isize> for U128 {
            type Output = U128;
            fn mul(self, other: &'a isize) -> U128 {
                let (result, carry) = self.overflowing_mul_u64(*other as u64);
                if carry > 0 {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!("arithmetic operation overflow"),
                        );
                    }
                }
                result
            }
        }
        impl<'a> ::uint::core_::ops::Mul<&'a isize> for &'a U128 {
            type Output = U128;
            fn mul(self, other: &'a isize) -> U128 {
                let (result, carry) = self.overflowing_mul_u64(*other as u64);
                if carry > 0 {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!("arithmetic operation overflow"),
                        );
                    }
                }
                result
            }
        }
        impl<'a> ::uint::core_::ops::Mul<isize> for &'a U128 {
            type Output = U128;
            fn mul(self, other: isize) -> U128 {
                let (result, carry) = self.overflowing_mul_u64(other as u64);
                if carry > 0 {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!("arithmetic operation overflow"),
                        );
                    }
                }
                result
            }
        }
        impl ::uint::core_::ops::MulAssign<isize> for U128 {
            fn mul_assign(&mut self, other: isize) {
                let result = *self * (other as u64);
                *self = result;
            }
        }
        impl<T> ::uint::core_::ops::Div<T> for U128
        where
            T: Into<U128>,
        {
            type Output = U128;
            fn div(self, other: T) -> U128 {
                let other: Self = other.into();
                self.div_mod(other).0
            }
        }
        impl<'a, T> ::uint::core_::ops::Div<T> for &'a U128
        where
            T: Into<U128>,
        {
            type Output = U128;
            fn div(self, other: T) -> U128 {
                *self / other
            }
        }
        impl<T> ::uint::core_::ops::DivAssign<T> for U128
        where
            T: Into<U128>,
        {
            fn div_assign(&mut self, other: T) {
                *self = *self / other.into();
            }
        }
        impl<T> ::uint::core_::ops::Rem<T> for U128
        where
            T: Into<U128> + Copy,
        {
            type Output = U128;
            fn rem(self, other: T) -> U128 {
                let mut sub_copy = self;
                sub_copy %= other;
                sub_copy
            }
        }
        impl<'a, T> ::uint::core_::ops::Rem<T> for &'a U128
        where
            T: Into<U128> + Copy,
        {
            type Output = U128;
            fn rem(self, other: T) -> U128 {
                *self % other
            }
        }
        impl<T> ::uint::core_::ops::RemAssign<T> for U128
        where
            T: Into<U128> + Copy,
        {
            fn rem_assign(&mut self, other: T) {
                let other: Self = other.into();
                let rem = self.div_mod(other).1;
                *self = rem;
            }
        }
        impl ::uint::core_::ops::BitAnd<U128> for U128 {
            type Output = U128;
            #[inline]
            fn bitand(self, other: U128) -> U128 {
                let U128(ref arr1) = self;
                let U128(ref arr2) = other;
                let mut ret = [0u64; 2];
                for i in 0..2 {
                    ret[i] = arr1[i] & arr2[i];
                }
                U128(ret)
            }
        }
        impl ::uint::core_::ops::BitAndAssign<U128> for U128 {
            fn bitand_assign(&mut self, rhs: U128) {
                *self = *self & rhs;
            }
        }
        impl ::uint::core_::ops::BitXor<U128> for U128 {
            type Output = U128;
            #[inline]
            fn bitxor(self, other: U128) -> U128 {
                let U128(ref arr1) = self;
                let U128(ref arr2) = other;
                let mut ret = [0u64; 2];
                for i in 0..2 {
                    ret[i] = arr1[i] ^ arr2[i];
                }
                U128(ret)
            }
        }
        impl ::uint::core_::ops::BitXorAssign<U128> for U128 {
            fn bitxor_assign(&mut self, rhs: U128) {
                *self = *self ^ rhs;
            }
        }
        impl ::uint::core_::ops::BitOr<U128> for U128 {
            type Output = U128;
            #[inline]
            fn bitor(self, other: U128) -> U128 {
                let U128(ref arr1) = self;
                let U128(ref arr2) = other;
                let mut ret = [0u64; 2];
                for i in 0..2 {
                    ret[i] = arr1[i] | arr2[i];
                }
                U128(ret)
            }
        }
        impl ::uint::core_::ops::BitOrAssign<U128> for U128 {
            fn bitor_assign(&mut self, rhs: U128) {
                *self = *self | rhs;
            }
        }
        impl ::uint::core_::ops::Not for U128 {
            type Output = U128;
            #[inline]
            fn not(self) -> U128 {
                let U128(ref arr) = self;
                let mut ret = [0u64; 2];
                for i in 0..2 {
                    ret[i] = !arr[i];
                }
                U128(ret)
            }
        }
        impl<T> ::uint::core_::ops::Shl<T> for U128
        where
            T: Into<U128>,
        {
            type Output = U128;
            fn shl(self, shift: T) -> U128 {
                let shift = shift.into().as_usize();
                let U128(ref original) = self;
                let mut ret = [0u64; 2];
                let word_shift = shift / 64;
                let bit_shift = shift % 64;
                for i in word_shift..2 {
                    ret[i] = original[i - word_shift] << bit_shift;
                }
                if bit_shift > 0 {
                    for i in word_shift + 1..2 {
                        ret[i] += original[i - 1 - word_shift] >> (64 - bit_shift);
                    }
                }
                U128(ret)
            }
        }
        impl<'a, T> ::uint::core_::ops::Shl<T> for &'a U128
        where
            T: Into<U128>,
        {
            type Output = U128;
            fn shl(self, shift: T) -> U128 {
                *self << shift
            }
        }
        impl<T> ::uint::core_::ops::ShlAssign<T> for U128
        where
            T: Into<U128>,
        {
            fn shl_assign(&mut self, shift: T) {
                *self = *self << shift;
            }
        }
        impl<T> ::uint::core_::ops::Shr<T> for U128
        where
            T: Into<U128>,
        {
            type Output = U128;
            fn shr(self, shift: T) -> U128 {
                let shift = shift.into().as_usize();
                let U128(ref original) = self;
                let mut ret = [0u64; 2];
                let word_shift = shift / 64;
                let bit_shift = shift % 64;
                for i in word_shift..2 {
                    ret[i - word_shift] = original[i] >> bit_shift;
                }
                if bit_shift > 0 {
                    for i in word_shift + 1..2 {
                        ret[i - word_shift - 1] += original[i] << (64 - bit_shift);
                    }
                }
                U128(ret)
            }
        }
        impl<'a, T> ::uint::core_::ops::Shr<T> for &'a U128
        where
            T: Into<U128>,
        {
            type Output = U128;
            fn shr(self, shift: T) -> U128 {
                *self >> shift
            }
        }
        impl<T> ::uint::core_::ops::ShrAssign<T> for U128
        where
            T: Into<U128>,
        {
            fn shr_assign(&mut self, shift: T) {
                *self = *self >> shift;
            }
        }
        impl ::uint::core_::cmp::Ord for U128 {
            fn cmp(&self, other: &U128) -> ::uint::core_::cmp::Ordering {
                self.as_ref().iter().rev().cmp(other.as_ref().iter().rev())
            }
        }
        impl ::uint::core_::cmp::PartialOrd for U128 {
            fn partial_cmp(&self, other: &U128) -> Option<::uint::core_::cmp::Ordering> {
                Some(self.cmp(other))
            }
        }
        impl ::uint::core_::fmt::Debug for U128 {
            fn fmt(
                &self,
                f: &mut ::uint::core_::fmt::Formatter,
            ) -> ::uint::core_::fmt::Result {
                ::uint::core_::fmt::Display::fmt(self, f)
            }
        }
        impl ::uint::core_::fmt::Display for U128 {
            fn fmt(
                &self,
                f: &mut ::uint::core_::fmt::Formatter,
            ) -> ::uint::core_::fmt::Result {
                if self.is_zero() {
                    return f.write_fmt(format_args!("0"));
                }
                let mut buf = [0_u8; 2 * 20];
                let mut i = buf.len() - 1;
                let mut current = *self;
                let ten = U128::from(10);
                loop {
                    let digit = (current % ten).low_u64() as u8;
                    buf[i] = digit + b'0';
                    current /= ten;
                    if current.is_zero() {
                        break;
                    }
                    i -= 1;
                }
                let s = unsafe { ::uint::core_::str::from_utf8_unchecked(&buf[i..]) };
                f.pad_integral(true, "", s)
            }
        }
        impl ::uint::core_::fmt::LowerHex for U128 {
            fn fmt(
                &self,
                f: &mut ::uint::core_::fmt::Formatter,
            ) -> ::uint::core_::fmt::Result {
                self.fmt_hex(f, true)
            }
        }
        impl ::uint::core_::fmt::UpperHex for U128 {
            fn fmt(
                &self,
                f: &mut ::uint::core_::fmt::Formatter,
            ) -> ::uint::core_::fmt::Result {
                self.fmt_hex(f, false)
            }
        }
        impl ::uint::core_::str::FromStr for U128 {
            type Err = ::uint::FromHexError;
            fn from_str(value: &str) -> ::uint::core_::result::Result<U128, Self::Err> {
                let value = value.strip_prefix("0x").unwrap_or(value);
                const BYTES_LEN: usize = 2 * 8;
                const MAX_ENCODED_LEN: usize = BYTES_LEN * 2;
                let mut bytes = [0_u8; BYTES_LEN];
                let encoded = value.as_bytes();
                if encoded.len() > MAX_ENCODED_LEN {
                    return Err(::uint::hex::FromHexError::InvalidStringLength.into());
                }
                if encoded.len() % 2 == 0 {
                    let out = &mut bytes[BYTES_LEN - encoded.len() / 2..];
                    ::uint::hex::decode_to_slice(encoded, out).map_err(Self::Err::from)?;
                } else {
                    let mut s = [b'0'; MAX_ENCODED_LEN];
                    s[MAX_ENCODED_LEN - encoded.len()..].copy_from_slice(encoded);
                    let encoded = &s[MAX_ENCODED_LEN - encoded.len() - 1..];
                    let out = &mut bytes[BYTES_LEN - encoded.len() / 2..];
                    ::uint::hex::decode_to_slice(encoded, out).map_err(Self::Err::from)?;
                }
                Ok(Self::from_big_endian(&bytes))
            }
        }
        impl ::uint::core_::convert::From<&'static str> for U128 {
            fn from(s: &'static str) -> Self {
                s.parse().unwrap()
            }
        }
        impl ::uint::core_::convert::From<u128> for U128 {
            fn from(value: u128) -> U128 {
                let mut ret = [0; 2];
                ret[0] = value as u64;
                ret[1] = (value >> 64) as u64;
                U128(ret)
            }
        }
        impl ::uint::core_::convert::From<i128> for U128 {
            fn from(value: i128) -> U128 {
                match value >= 0 {
                    true => From::from(value as u128),
                    false => {
                        {
                            ::core::panicking::panic_fmt(
                                format_args!(
                                    "Unsigned integer can\'t be created from negative value",
                                ),
                            );
                        };
                    }
                }
            }
        }
        impl U128 {
            /// Low 2 words (u128)
            #[inline]
            pub const fn low_u128(&self) -> u128 {
                let &U128(ref arr) = self;
                ((arr[1] as u128) << 64) + arr[0] as u128
            }
            /// Conversion to u128 with overflow checking
            ///
            /// # Panics
            ///
            /// Panics if the number is larger than 2^128.
            #[inline]
            pub fn as_u128(&self) -> u128 {
                let &U128(ref arr) = self;
                for i in 2..2 {
                    if arr[i] != 0 {
                        {
                            ::core::panicking::panic_fmt(
                                format_args!("Integer overflow when casting to u128"),
                            );
                        }
                    }
                }
                self.low_u128()
            }
        }
        impl ::uint::core_::convert::TryFrom<U128> for u128 {
            type Error = &'static str;
            #[inline]
            fn try_from(u: U128) -> ::uint::core_::result::Result<u128, &'static str> {
                let U128(arr) = u;
                for i in 2..2 {
                    if arr[i] != 0 {
                        return Err("integer overflow when casting to u128");
                    }
                }
                Ok(((arr[1] as u128) << 64) + arr[0] as u128)
            }
        }
        impl ::uint::core_::convert::TryFrom<U128> for i128 {
            type Error = &'static str;
            #[inline]
            fn try_from(u: U128) -> ::uint::core_::result::Result<i128, &'static str> {
                let err_str = "integer overflow when casting to i128";
                let i = u128::try_from(u).map_err(|_| err_str)?;
                if i > i128::max_value() as u128 { Err(err_str) } else { Ok(i as i128) }
            }
        }
        /// Little-endian large integer type
        #[repr(C)]
        pub struct U256(pub [u64; 4]);
        #[automatically_derived]
        impl ::core::marker::Copy for U256 {}
        #[automatically_derived]
        impl ::core::clone::Clone for U256 {
            #[inline]
            fn clone(&self) -> U256 {
                let _: ::core::clone::AssertParamIsClone<[u64; 4]>;
                *self
            }
        }
        #[automatically_derived]
        impl ::core::cmp::Eq for U256 {
            #[inline]
            #[doc(hidden)]
            #[coverage(off)]
            fn assert_receiver_is_total_eq(&self) -> () {
                let _: ::core::cmp::AssertParamIsEq<[u64; 4]>;
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for U256 {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for U256 {
            #[inline]
            fn eq(&self, other: &U256) -> bool {
                self.0 == other.0
            }
        }
        #[automatically_derived]
        impl ::core::hash::Hash for U256 {
            #[inline]
            fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                ::core::hash::Hash::hash(&self.0, state)
            }
        }
        /// Get a reference to the underlying little-endian words.
        impl AsRef<[u64]> for U256 {
            #[inline]
            fn as_ref(&self) -> &[u64] {
                &self.0
            }
        }
        impl<'a> From<&'a U256> for U256 {
            fn from(x: &'a U256) -> U256 {
                *x
            }
        }
        impl U256 {
            const WORD_BITS: usize = 64;
            /// Maximum value.
            pub const MAX: U256 = U256([u64::max_value(); 4]);
            /// Converts a string slice in a given base to an integer. Only supports radixes of 10
            /// and 16.
            pub fn from_str_radix(
                txt: &str,
                radix: u32,
            ) -> Result<Self, ::uint::FromStrRadixErr> {
                let parsed = match radix {
                    10 => Self::from_dec_str(txt)?,
                    16 => core::str::FromStr::from_str(txt)?,
                    _ => return Err(::uint::FromStrRadixErr::unsupported()),
                };
                Ok(parsed)
            }
            /// Convert from a decimal string.
            pub fn from_dec_str(
                value: &str,
            ) -> ::uint::core_::result::Result<Self, ::uint::FromDecStrErr> {
                let mut res = Self::default();
                for b in value.bytes().map(|b| b.wrapping_sub(b'0')) {
                    if b > 9 {
                        return Err(::uint::FromDecStrErr::InvalidCharacter);
                    }
                    let (r, overflow) = res.overflowing_mul_u64(10);
                    if overflow > 0 {
                        return Err(::uint::FromDecStrErr::InvalidLength);
                    }
                    let (r, overflow) = r.overflowing_add(b.into());
                    if overflow {
                        return Err(::uint::FromDecStrErr::InvalidLength);
                    }
                    res = r;
                }
                Ok(res)
            }
            /// Conversion to u32
            #[inline]
            pub const fn low_u32(&self) -> u32 {
                let &U256(ref arr) = self;
                arr[0] as u32
            }
            /// Low word (u64)
            #[inline]
            pub const fn low_u64(&self) -> u64 {
                let &U256(ref arr) = self;
                arr[0]
            }
            /// Conversion to u32 with overflow checking
            ///
            /// # Panics
            ///
            /// Panics if the number is larger than 2^32.
            #[inline]
            pub fn as_u32(&self) -> u32 {
                let &U256(ref arr) = self;
                if !self.fits_word() || arr[0] > u32::max_value() as u64 {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!("Integer overflow when casting to u32"),
                        );
                    }
                }
                self.as_u64() as u32
            }
            /// Conversion to u64 with overflow checking
            ///
            /// # Panics
            ///
            /// Panics if the number is larger than u64::max_value().
            #[inline]
            pub fn as_u64(&self) -> u64 {
                let &U256(ref arr) = self;
                if !self.fits_word() {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!("Integer overflow when casting to u64"),
                        );
                    }
                }
                arr[0]
            }
            /// Conversion to usize with overflow checking
            ///
            /// # Panics
            ///
            /// Panics if the number is larger than usize::max_value().
            #[inline]
            pub fn as_usize(&self) -> usize {
                let &U256(ref arr) = self;
                if !self.fits_word() || arr[0] > usize::max_value() as u64 {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!("Integer overflow when casting to usize"),
                        );
                    }
                }
                arr[0] as usize
            }
            /// Whether this is zero.
            #[inline]
            pub const fn is_zero(&self) -> bool {
                let &U256(ref arr) = self;
                let mut i = 0;
                while i < 4 {
                    if arr[i] != 0 {
                        return false;
                    } else {
                        i += 1;
                    }
                }
                return true;
            }
            #[inline]
            fn fits_word(&self) -> bool {
                let &U256(ref arr) = self;
                for i in 1..4 {
                    if arr[i] != 0 {
                        return false;
                    }
                }
                return true;
            }
            /// Return the least number of bits needed to represent the number
            #[inline]
            pub fn bits(&self) -> usize {
                let &U256(ref arr) = self;
                for i in 1..4 {
                    if arr[4 - i] > 0 {
                        return (0x40 * (4 - i + 1))
                            - arr[4 - i].leading_zeros() as usize;
                    }
                }
                0x40 - arr[0].leading_zeros() as usize
            }
            /// Return if specific bit is set.
            ///
            /// # Panics
            ///
            /// Panics if `index` exceeds the bit width of the number.
            #[inline]
            pub const fn bit(&self, index: usize) -> bool {
                let &U256(ref arr) = self;
                arr[index / 64] & (1 << (index % 64)) != 0
            }
            /// Returns the number of leading zeros in the binary representation of self.
            pub fn leading_zeros(&self) -> u32 {
                let mut r = 0;
                for i in 0..4 {
                    let w = self.0[4 - i - 1];
                    if w == 0 {
                        r += 64;
                    } else {
                        r += w.leading_zeros();
                        break;
                    }
                }
                r
            }
            /// Returns the number of trailing zeros in the binary representation of self.
            pub fn trailing_zeros(&self) -> u32 {
                let mut r = 0;
                for i in 0..4 {
                    let w = self.0[i];
                    if w == 0 {
                        r += 64;
                    } else {
                        r += w.trailing_zeros();
                        break;
                    }
                }
                r
            }
            /// Return specific byte. Byte 0 is the least significant value (ie~ little endian).
            ///
            /// # Panics
            ///
            /// Panics if `index` exceeds the byte width of the number.
            #[inline]
            pub const fn byte(&self, index: usize) -> u8 {
                let &U256(ref arr) = self;
                (arr[index / 8] >> (((index % 8)) * 8)) as u8
            }
            /// Convert to big-endian bytes.
            #[inline]
            pub fn to_big_endian(&self) -> [u8; 4 * 8] {
                let mut bytes = [0u8; 4 * 8];
                self.write_as_big_endian(&mut bytes);
                bytes
            }
            /// Write to the slice in big-endian format.
            #[inline]
            pub fn write_as_big_endian(&self, bytes: &mut [u8]) {
                use ::uint::byteorder::{ByteOrder, BigEndian};
                if true {
                    {
                        match 4 * 8 == bytes.len() {
                            true => {}
                            _ => {
                                ::core::panicking::panic(
                                    "assertion failed: 4 * 8 == bytes.len()",
                                )
                            }
                        }
                    };
                }
                for i in 0..4 {
                    BigEndian::write_u64(&mut bytes[8 * i..], self.0[4 - i - 1]);
                }
            }
            /// Convert to little-endian bytes.
            #[inline]
            pub fn to_little_endian(&self) -> [u8; 4 * 8] {
                let mut bytes = [0u8; 4 * 8];
                self.write_as_little_endian(&mut bytes);
                bytes
            }
            #[inline]
            pub fn write_as_little_endian(&self, bytes: &mut [u8]) {
                use ::uint::byteorder::{ByteOrder, LittleEndian};
                if true {
                    {
                        match 4 * 8 == bytes.len() {
                            true => {}
                            _ => {
                                ::core::panicking::panic(
                                    "assertion failed: 4 * 8 == bytes.len()",
                                )
                            }
                        }
                    };
                }
                for i in 0..4 {
                    LittleEndian::write_u64(&mut bytes[8 * i..], self.0[i]);
                }
            }
            /// Create `10**n` as this type.
            ///
            /// # Panics
            ///
            /// Panics if the result overflows the type.
            #[inline]
            pub fn exp10(n: usize) -> Self {
                match n {
                    0 => Self::from(1u64),
                    _ => Self::exp10(n - 1) * 10u32,
                }
            }
            /// Zero (additive identity) of this type.
            #[inline]
            pub const fn zero() -> Self {
                Self([0; 4])
            }
            /// One (multiplicative identity) of this type.
            #[inline]
            pub const fn one() -> Self {
                let mut words = [0; 4];
                words[0] = 1u64;
                Self(words)
            }
            /// The maximum value which can be inhabited by this type.
            #[inline]
            pub const fn max_value() -> Self {
                Self::MAX
            }
            fn full_shl(self, shift: u32) -> [u64; 4 + 1] {
                if true {
                    {
                        match shift < Self::WORD_BITS as u32 {
                            true => {}
                            _ => {
                                ::core::panicking::panic(
                                    "assertion failed: shift < Self::WORD_BITS as u32",
                                )
                            }
                        }
                    };
                }
                let mut u = [0u64; 4 + 1];
                let u_lo = self.0[0] << shift;
                let u_hi = self >> (Self::WORD_BITS as u32 - shift);
                u[0] = u_lo;
                u[1..].copy_from_slice(&u_hi.0[..]);
                u
            }
            fn full_shr(u: [u64; 4 + 1], shift: u32) -> Self {
                if true {
                    {
                        match shift < Self::WORD_BITS as u32 {
                            true => {}
                            _ => {
                                ::core::panicking::panic(
                                    "assertion failed: shift < Self::WORD_BITS as u32",
                                )
                            }
                        }
                    };
                }
                let mut res = Self::zero();
                for i in 0..4 {
                    res.0[i] = u[i] >> shift;
                }
                if shift > 0 {
                    for i in 1..=4 {
                        res.0[i - 1] |= u[i] << (Self::WORD_BITS as u32 - shift);
                    }
                }
                res
            }
            fn full_mul_u64(self, by: u64) -> [u64; 4 + 1] {
                let (prod, carry) = self.overflowing_mul_u64(by);
                let mut res = [0u64; 4 + 1];
                res[..4].copy_from_slice(&prod.0[..]);
                res[4] = carry;
                res
            }
            fn div_mod_small(mut self, other: u64) -> (Self, Self) {
                let mut rem = 0u64;
                self.0
                    .iter_mut()
                    .rev()
                    .for_each(|d| {
                        let (q, r) = Self::div_mod_word(rem, *d, other);
                        *d = q;
                        rem = r;
                    });
                (self, rem.into())
            }
            fn div_mod_knuth(self, mut v: Self, n: usize, m: usize) -> (Self, Self) {
                if true {
                    {
                        match self.bits() >= v.bits() && !v.fits_word() {
                            true => {}
                            _ => {
                                ::core::panicking::panic(
                                    "assertion failed: self.bits() >= v.bits() && !v.fits_word()",
                                )
                            }
                        }
                    };
                }
                if true {
                    {
                        match n + m <= 4 {
                            true => {}
                            _ => ::core::panicking::panic("assertion failed: n + m <= 4"),
                        }
                    };
                }
                let shift = v.0[n - 1].leading_zeros();
                v <<= shift;
                let mut u = self.full_shl(shift);
                let mut q = Self::zero();
                let v_n_1 = v.0[n - 1];
                let v_n_2 = v.0[n - 2];
                for j in (0..=m).rev() {
                    let u_jn = u[j + n];
                    let mut q_hat = if u_jn < v_n_1 {
                        let (mut q_hat, mut r_hat) = Self::div_mod_word(
                            u_jn,
                            u[j + n - 1],
                            v_n_1,
                        );
                        loop {
                            let (hi, lo) = Self::split_u128(
                                u128::from(q_hat) * u128::from(v_n_2),
                            );
                            if (hi, lo) <= (r_hat, u[j + n - 2]) {
                                break;
                            }
                            q_hat -= 1;
                            let (new_r_hat, overflow) = r_hat.overflowing_add(v_n_1);
                            r_hat = new_r_hat;
                            if overflow {
                                break;
                            }
                        }
                        q_hat
                    } else {
                        u64::max_value()
                    };
                    let q_hat_v = v.full_mul_u64(q_hat);
                    let c = Self::sub_slice(&mut u[j..], &q_hat_v[..n + 1]);
                    if c {
                        q_hat -= 1;
                        let c = Self::add_slice(&mut u[j..], &v.0[..n]);
                        u[j + n] = u[j + n].wrapping_add(u64::from(c));
                    }
                    q.0[j] = q_hat;
                }
                let remainder = Self::full_shr(u, shift);
                (q, remainder)
            }
            fn words(bits: usize) -> usize {
                if true {
                    {
                        match bits > 0 {
                            true => {}
                            _ => ::core::panicking::panic("assertion failed: bits > 0"),
                        }
                    };
                }
                1 + (bits - 1) / Self::WORD_BITS
            }
            /// Returns a pair `(self / other, self % other)`.
            ///
            /// # Panics
            ///
            /// Panics if `other` is zero.
            pub fn div_mod(mut self, mut other: Self) -> (Self, Self) {
                use ::uint::core_::cmp::Ordering;
                let my_bits = self.bits();
                let your_bits = other.bits();
                {
                    match your_bits != 0 {
                        true => {}
                        _ => {
                            ::core::panicking::panic_fmt(
                                format_args!("division by zero"),
                            );
                        }
                    }
                };
                if my_bits < your_bits {
                    return (Self::zero(), self);
                }
                if your_bits <= Self::WORD_BITS {
                    return self.div_mod_small(other.low_u64());
                }
                let (n, m) = {
                    let my_words = Self::words(my_bits);
                    let your_words = Self::words(your_bits);
                    (your_words, my_words - your_words)
                };
                self.div_mod_knuth(other, n, m)
            }
            /// Compute the highest `n` such that `n * n <= self`.
            pub fn integer_sqrt(&self) -> Self {
                let one = Self::one();
                if self <= &one {
                    return *self;
                }
                let shift: u32 = (self.bits() as u32 + 1) / 2;
                let mut x_prev = one << shift;
                loop {
                    let x = (x_prev + self / x_prev) >> 1;
                    if x >= x_prev {
                        return x_prev;
                    }
                    x_prev = x;
                }
            }
            /// Fast exponentiation by squaring
            /// https://en.wikipedia.org/wiki/Exponentiation_by_squaring
            ///
            /// # Panics
            ///
            /// Panics if the result overflows the type.
            pub fn pow(self, expon: Self) -> Self {
                if expon.is_zero() {
                    return Self::one();
                }
                let is_even = |x: &Self| x.low_u64() & 1 == 0;
                let u_one = Self::one();
                let mut y = u_one;
                let mut n = expon;
                let mut x = self;
                while n > u_one {
                    if is_even(&n) {
                        x = x * x;
                        n >>= 1usize;
                    } else {
                        y = x * y;
                        x = x * x;
                        n.0[4 - 1] &= (!0u64) >> 1;
                        n >>= 1usize;
                    }
                }
                x * y
            }
            /// Fast exponentiation by squaring. Returns result and overflow flag.
            pub fn overflowing_pow(self, expon: Self) -> (Self, bool) {
                if expon.is_zero() {
                    return (Self::one(), false);
                }
                let is_even = |x: &Self| x.low_u64() & 1 == 0;
                let u_one = Self::one();
                let mut y = u_one;
                let mut n = expon;
                let mut x = self;
                let mut overflow = false;
                while n > u_one {
                    if is_even(&n) {
                        x = {
                            let (overflow_x, overflow_overflow) = x.overflowing_mul(x);
                            overflow |= overflow_overflow;
                            overflow_x
                        };
                        n >>= 1usize;
                    } else {
                        y = {
                            let (overflow_x, overflow_overflow) = x.overflowing_mul(y);
                            overflow |= overflow_overflow;
                            overflow_x
                        };
                        x = {
                            let (overflow_x, overflow_overflow) = x.overflowing_mul(x);
                            overflow |= overflow_overflow;
                            overflow_x
                        };
                        n = (n - u_one) >> 1usize;
                    }
                }
                let res = {
                    let (overflow_x, overflow_overflow) = x.overflowing_mul(y);
                    overflow |= overflow_overflow;
                    overflow_x
                };
                (res, overflow)
            }
            /// Checked exponentiation. Returns `None` if overflow occurred.
            pub fn checked_pow(self, expon: U256) -> Option<U256> {
                match self.overflowing_pow(expon) {
                    (_, true) => None,
                    (val, _) => Some(val),
                }
            }
            /// Addition which overflows and returns a flag if it does.
            #[inline(always)]
            pub fn overflowing_add(self, other: U256) -> (U256, bool) {
                {
                    use ::uint::core_ as core;
                    let U256(ref me) = self;
                    let U256(ref you) = other;
                    let mut ret = [0u64; 4];
                    let mut carry = 0u64;
                    #[allow(unknown_lints, eq_op)]
                    const _: [(); 0
                        - !{
                            const ASSERT: bool = core::isize::MAX as usize
                                / core::mem::size_of::<u64>() > 4;
                            ASSERT
                        } as usize] = [];
                    use ::uint::unroll;
                    #[allow(non_upper_case_globals)] #[allow(unused_comparisons)]
                    {
                        {
                            const i: usize = 0;
                            {
                                if i >= 0 {
                                    use core::ptr;
                                    if carry != 0 {
                                        let (res1, overflow1) = (u64::overflowing_add)(
                                            me[i],
                                            you[i],
                                        );
                                        let (res2, overflow2) = (u64::overflowing_add)(res1, carry);
                                        ret[i] = res2;
                                        carry = (overflow1 as u8 + overflow2 as u8) as u64;
                                    } else {
                                        let (res, overflow) = (u64::overflowing_add)(me[i], you[i]);
                                        ret[i] = res;
                                        carry = overflow as u64;
                                    }
                                }
                            }
                        }
                        {
                            const i: usize = 0 + 1;
                            {
                                if i >= 0 {
                                    use core::ptr;
                                    if carry != 0 {
                                        let (res1, overflow1) = (u64::overflowing_add)(
                                            me[i],
                                            you[i],
                                        );
                                        let (res2, overflow2) = (u64::overflowing_add)(res1, carry);
                                        ret[i] = res2;
                                        carry = (overflow1 as u8 + overflow2 as u8) as u64;
                                    } else {
                                        let (res, overflow) = (u64::overflowing_add)(me[i], you[i]);
                                        ret[i] = res;
                                        carry = overflow as u64;
                                    }
                                }
                            }
                        }
                        {
                            const i: usize = 0 + 2;
                            {
                                if i >= 0 {
                                    use core::ptr;
                                    if carry != 0 {
                                        let (res1, overflow1) = (u64::overflowing_add)(
                                            me[i],
                                            you[i],
                                        );
                                        let (res2, overflow2) = (u64::overflowing_add)(res1, carry);
                                        ret[i] = res2;
                                        carry = (overflow1 as u8 + overflow2 as u8) as u64;
                                    } else {
                                        let (res, overflow) = (u64::overflowing_add)(me[i], you[i]);
                                        ret[i] = res;
                                        carry = overflow as u64;
                                    }
                                }
                            }
                        }
                        {
                            const i: usize = 0 + 3;
                            {
                                if i >= 0 {
                                    use core::ptr;
                                    if carry != 0 {
                                        let (res1, overflow1) = (u64::overflowing_add)(
                                            me[i],
                                            you[i],
                                        );
                                        let (res2, overflow2) = (u64::overflowing_add)(res1, carry);
                                        ret[i] = res2;
                                        carry = (overflow1 as u8 + overflow2 as u8) as u64;
                                    } else {
                                        let (res, overflow) = (u64::overflowing_add)(me[i], you[i]);
                                        ret[i] = res;
                                        carry = overflow as u64;
                                    }
                                }
                            }
                        };
                    }
                    (U256(ret), carry > 0)
                }
            }
            /// Addition which saturates at the maximum value (Self::MAX).
            pub fn saturating_add(self, other: U256) -> U256 {
                match self.overflowing_add(other) {
                    (_, true) => U256::MAX,
                    (val, false) => val,
                }
            }
            /// Checked addition. Returns `None` if overflow occurred.
            pub fn checked_add(self, other: U256) -> Option<U256> {
                match self.overflowing_add(other) {
                    (_, true) => None,
                    (val, _) => Some(val),
                }
            }
            /// Subtraction which underflows and returns a flag if it does.
            #[inline(always)]
            pub fn overflowing_sub(self, other: U256) -> (U256, bool) {
                {
                    use ::uint::core_ as core;
                    let U256(ref me) = self;
                    let U256(ref you) = other;
                    let mut ret = [0u64; 4];
                    let mut carry = 0u64;
                    #[allow(unknown_lints, eq_op)]
                    const _: [(); 0
                        - !{
                            const ASSERT: bool = core::isize::MAX as usize
                                / core::mem::size_of::<u64>() > 4;
                            ASSERT
                        } as usize] = [];
                    use ::uint::unroll;
                    #[allow(non_upper_case_globals)] #[allow(unused_comparisons)]
                    {
                        {
                            const i: usize = 0;
                            {
                                if i >= 0 {
                                    use core::ptr;
                                    if carry != 0 {
                                        let (res1, overflow1) = (u64::overflowing_sub)(
                                            me[i],
                                            you[i],
                                        );
                                        let (res2, overflow2) = (u64::overflowing_sub)(res1, carry);
                                        ret[i] = res2;
                                        carry = (overflow1 as u8 + overflow2 as u8) as u64;
                                    } else {
                                        let (res, overflow) = (u64::overflowing_sub)(me[i], you[i]);
                                        ret[i] = res;
                                        carry = overflow as u64;
                                    }
                                }
                            }
                        }
                        {
                            const i: usize = 0 + 1;
                            {
                                if i >= 0 {
                                    use core::ptr;
                                    if carry != 0 {
                                        let (res1, overflow1) = (u64::overflowing_sub)(
                                            me[i],
                                            you[i],
                                        );
                                        let (res2, overflow2) = (u64::overflowing_sub)(res1, carry);
                                        ret[i] = res2;
                                        carry = (overflow1 as u8 + overflow2 as u8) as u64;
                                    } else {
                                        let (res, overflow) = (u64::overflowing_sub)(me[i], you[i]);
                                        ret[i] = res;
                                        carry = overflow as u64;
                                    }
                                }
                            }
                        }
                        {
                            const i: usize = 0 + 2;
                            {
                                if i >= 0 {
                                    use core::ptr;
                                    if carry != 0 {
                                        let (res1, overflow1) = (u64::overflowing_sub)(
                                            me[i],
                                            you[i],
                                        );
                                        let (res2, overflow2) = (u64::overflowing_sub)(res1, carry);
                                        ret[i] = res2;
                                        carry = (overflow1 as u8 + overflow2 as u8) as u64;
                                    } else {
                                        let (res, overflow) = (u64::overflowing_sub)(me[i], you[i]);
                                        ret[i] = res;
                                        carry = overflow as u64;
                                    }
                                }
                            }
                        }
                        {
                            const i: usize = 0 + 3;
                            {
                                if i >= 0 {
                                    use core::ptr;
                                    if carry != 0 {
                                        let (res1, overflow1) = (u64::overflowing_sub)(
                                            me[i],
                                            you[i],
                                        );
                                        let (res2, overflow2) = (u64::overflowing_sub)(res1, carry);
                                        ret[i] = res2;
                                        carry = (overflow1 as u8 + overflow2 as u8) as u64;
                                    } else {
                                        let (res, overflow) = (u64::overflowing_sub)(me[i], you[i]);
                                        ret[i] = res;
                                        carry = overflow as u64;
                                    }
                                }
                            }
                        };
                    }
                    (U256(ret), carry > 0)
                }
            }
            /// Subtraction which saturates at zero.
            pub fn saturating_sub(self, other: U256) -> U256 {
                match self.overflowing_sub(other) {
                    (_, true) => U256::zero(),
                    (val, false) => val,
                }
            }
            /// Checked subtraction. Returns `None` if overflow occurred.
            pub fn checked_sub(self, other: U256) -> Option<U256> {
                match self.overflowing_sub(other) {
                    (_, true) => None,
                    (val, _) => Some(val),
                }
            }
            /// Computes the absolute difference between self and other.
            pub fn abs_diff(self, other: U256) -> U256 {
                if self > other {
                    self.overflowing_sub(other).0
                } else {
                    other.overflowing_sub(self).0
                }
            }
            /// Multiply with overflow, returning a flag if it does.
            #[inline(always)]
            pub fn overflowing_mul(self, other: U256) -> (U256, bool) {
                {
                    let ret: [u64; 4 * 2] = {
                        {
                            #![allow(unused_assignments)]
                            let U256(ref me) = self;
                            let U256(ref you) = other;
                            let mut ret = [0u64; 4 * 2];
                            use ::uint::unroll;
                            #[allow(non_upper_case_globals)] #[allow(unused_comparisons)]
                            {
                                {
                                    const i: usize = 0;
                                    {
                                        if i >= 0 {
                                            let mut carry = 0u64;
                                            let b = you[i];
                                            #[allow(non_upper_case_globals)]
                                            #[allow(unused_comparisons)]
                                            {
                                                {
                                                    const j: usize = 0;
                                                    {
                                                        if j >= 0 {
                                                            if (|_, _| true)(me[j], carry) {
                                                                let a = me[j];
                                                                let (hi, low) = Self::split_u128(a as u128 * b as u128);
                                                                let overflow = {
                                                                    let existing_low = &mut ret[i + j];
                                                                    let (low, o) = low.overflowing_add(*existing_low);
                                                                    *existing_low = low;
                                                                    o
                                                                };
                                                                carry = {
                                                                    let existing_hi = &mut ret[i + j + 1];
                                                                    let hi = hi + overflow as u64;
                                                                    let (hi, o0) = hi.overflowing_add(carry);
                                                                    let (hi, o1) = hi.overflowing_add(*existing_hi);
                                                                    *existing_hi = hi;
                                                                    (o0 | o1) as u64
                                                                };
                                                            }
                                                        }
                                                    }
                                                }
                                                {
                                                    const j: usize = 0 + 1;
                                                    {
                                                        if j >= 0 {
                                                            if (|_, _| true)(me[j], carry) {
                                                                let a = me[j];
                                                                let (hi, low) = Self::split_u128(a as u128 * b as u128);
                                                                let overflow = {
                                                                    let existing_low = &mut ret[i + j];
                                                                    let (low, o) = low.overflowing_add(*existing_low);
                                                                    *existing_low = low;
                                                                    o
                                                                };
                                                                carry = {
                                                                    let existing_hi = &mut ret[i + j + 1];
                                                                    let hi = hi + overflow as u64;
                                                                    let (hi, o0) = hi.overflowing_add(carry);
                                                                    let (hi, o1) = hi.overflowing_add(*existing_hi);
                                                                    *existing_hi = hi;
                                                                    (o0 | o1) as u64
                                                                };
                                                            }
                                                        }
                                                    }
                                                }
                                                {
                                                    const j: usize = 0 + 2;
                                                    {
                                                        if j >= 0 {
                                                            if (|_, _| true)(me[j], carry) {
                                                                let a = me[j];
                                                                let (hi, low) = Self::split_u128(a as u128 * b as u128);
                                                                let overflow = {
                                                                    let existing_low = &mut ret[i + j];
                                                                    let (low, o) = low.overflowing_add(*existing_low);
                                                                    *existing_low = low;
                                                                    o
                                                                };
                                                                carry = {
                                                                    let existing_hi = &mut ret[i + j + 1];
                                                                    let hi = hi + overflow as u64;
                                                                    let (hi, o0) = hi.overflowing_add(carry);
                                                                    let (hi, o1) = hi.overflowing_add(*existing_hi);
                                                                    *existing_hi = hi;
                                                                    (o0 | o1) as u64
                                                                };
                                                            }
                                                        }
                                                    }
                                                }
                                                {
                                                    const j: usize = 0 + 3;
                                                    {
                                                        if j >= 0 {
                                                            if (|_, _| true)(me[j], carry) {
                                                                let a = me[j];
                                                                let (hi, low) = Self::split_u128(a as u128 * b as u128);
                                                                let overflow = {
                                                                    let existing_low = &mut ret[i + j];
                                                                    let (low, o) = low.overflowing_add(*existing_low);
                                                                    *existing_low = low;
                                                                    o
                                                                };
                                                                carry = {
                                                                    let existing_hi = &mut ret[i + j + 1];
                                                                    let hi = hi + overflow as u64;
                                                                    let (hi, o0) = hi.overflowing_add(carry);
                                                                    let (hi, o1) = hi.overflowing_add(*existing_hi);
                                                                    *existing_hi = hi;
                                                                    (o0 | o1) as u64
                                                                };
                                                            }
                                                        }
                                                    }
                                                };
                                            }
                                        }
                                    }
                                }
                                {
                                    const i: usize = 0 + 1;
                                    {
                                        if i >= 0 {
                                            let mut carry = 0u64;
                                            let b = you[i];
                                            #[allow(non_upper_case_globals)]
                                            #[allow(unused_comparisons)]
                                            {
                                                {
                                                    const j: usize = 0;
                                                    {
                                                        if j >= 0 {
                                                            if (|_, _| true)(me[j], carry) {
                                                                let a = me[j];
                                                                let (hi, low) = Self::split_u128(a as u128 * b as u128);
                                                                let overflow = {
                                                                    let existing_low = &mut ret[i + j];
                                                                    let (low, o) = low.overflowing_add(*existing_low);
                                                                    *existing_low = low;
                                                                    o
                                                                };
                                                                carry = {
                                                                    let existing_hi = &mut ret[i + j + 1];
                                                                    let hi = hi + overflow as u64;
                                                                    let (hi, o0) = hi.overflowing_add(carry);
                                                                    let (hi, o1) = hi.overflowing_add(*existing_hi);
                                                                    *existing_hi = hi;
                                                                    (o0 | o1) as u64
                                                                };
                                                            }
                                                        }
                                                    }
                                                }
                                                {
                                                    const j: usize = 0 + 1;
                                                    {
                                                        if j >= 0 {
                                                            if (|_, _| true)(me[j], carry) {
                                                                let a = me[j];
                                                                let (hi, low) = Self::split_u128(a as u128 * b as u128);
                                                                let overflow = {
                                                                    let existing_low = &mut ret[i + j];
                                                                    let (low, o) = low.overflowing_add(*existing_low);
                                                                    *existing_low = low;
                                                                    o
                                                                };
                                                                carry = {
                                                                    let existing_hi = &mut ret[i + j + 1];
                                                                    let hi = hi + overflow as u64;
                                                                    let (hi, o0) = hi.overflowing_add(carry);
                                                                    let (hi, o1) = hi.overflowing_add(*existing_hi);
                                                                    *existing_hi = hi;
                                                                    (o0 | o1) as u64
                                                                };
                                                            }
                                                        }
                                                    }
                                                }
                                                {
                                                    const j: usize = 0 + 2;
                                                    {
                                                        if j >= 0 {
                                                            if (|_, _| true)(me[j], carry) {
                                                                let a = me[j];
                                                                let (hi, low) = Self::split_u128(a as u128 * b as u128);
                                                                let overflow = {
                                                                    let existing_low = &mut ret[i + j];
                                                                    let (low, o) = low.overflowing_add(*existing_low);
                                                                    *existing_low = low;
                                                                    o
                                                                };
                                                                carry = {
                                                                    let existing_hi = &mut ret[i + j + 1];
                                                                    let hi = hi + overflow as u64;
                                                                    let (hi, o0) = hi.overflowing_add(carry);
                                                                    let (hi, o1) = hi.overflowing_add(*existing_hi);
                                                                    *existing_hi = hi;
                                                                    (o0 | o1) as u64
                                                                };
                                                            }
                                                        }
                                                    }
                                                }
                                                {
                                                    const j: usize = 0 + 3;
                                                    {
                                                        if j >= 0 {
                                                            if (|_, _| true)(me[j], carry) {
                                                                let a = me[j];
                                                                let (hi, low) = Self::split_u128(a as u128 * b as u128);
                                                                let overflow = {
                                                                    let existing_low = &mut ret[i + j];
                                                                    let (low, o) = low.overflowing_add(*existing_low);
                                                                    *existing_low = low;
                                                                    o
                                                                };
                                                                carry = {
                                                                    let existing_hi = &mut ret[i + j + 1];
                                                                    let hi = hi + overflow as u64;
                                                                    let (hi, o0) = hi.overflowing_add(carry);
                                                                    let (hi, o1) = hi.overflowing_add(*existing_hi);
                                                                    *existing_hi = hi;
                                                                    (o0 | o1) as u64
                                                                };
                                                            }
                                                        }
                                                    }
                                                };
                                            }
                                        }
                                    }
                                }
                                {
                                    const i: usize = 0 + 2;
                                    {
                                        if i >= 0 {
                                            let mut carry = 0u64;
                                            let b = you[i];
                                            #[allow(non_upper_case_globals)]
                                            #[allow(unused_comparisons)]
                                            {
                                                {
                                                    const j: usize = 0;
                                                    {
                                                        if j >= 0 {
                                                            if (|_, _| true)(me[j], carry) {
                                                                let a = me[j];
                                                                let (hi, low) = Self::split_u128(a as u128 * b as u128);
                                                                let overflow = {
                                                                    let existing_low = &mut ret[i + j];
                                                                    let (low, o) = low.overflowing_add(*existing_low);
                                                                    *existing_low = low;
                                                                    o
                                                                };
                                                                carry = {
                                                                    let existing_hi = &mut ret[i + j + 1];
                                                                    let hi = hi + overflow as u64;
                                                                    let (hi, o0) = hi.overflowing_add(carry);
                                                                    let (hi, o1) = hi.overflowing_add(*existing_hi);
                                                                    *existing_hi = hi;
                                                                    (o0 | o1) as u64
                                                                };
                                                            }
                                                        }
                                                    }
                                                }
                                                {
                                                    const j: usize = 0 + 1;
                                                    {
                                                        if j >= 0 {
                                                            if (|_, _| true)(me[j], carry) {
                                                                let a = me[j];
                                                                let (hi, low) = Self::split_u128(a as u128 * b as u128);
                                                                let overflow = {
                                                                    let existing_low = &mut ret[i + j];
                                                                    let (low, o) = low.overflowing_add(*existing_low);
                                                                    *existing_low = low;
                                                                    o
                                                                };
                                                                carry = {
                                                                    let existing_hi = &mut ret[i + j + 1];
                                                                    let hi = hi + overflow as u64;
                                                                    let (hi, o0) = hi.overflowing_add(carry);
                                                                    let (hi, o1) = hi.overflowing_add(*existing_hi);
                                                                    *existing_hi = hi;
                                                                    (o0 | o1) as u64
                                                                };
                                                            }
                                                        }
                                                    }
                                                }
                                                {
                                                    const j: usize = 0 + 2;
                                                    {
                                                        if j >= 0 {
                                                            if (|_, _| true)(me[j], carry) {
                                                                let a = me[j];
                                                                let (hi, low) = Self::split_u128(a as u128 * b as u128);
                                                                let overflow = {
                                                                    let existing_low = &mut ret[i + j];
                                                                    let (low, o) = low.overflowing_add(*existing_low);
                                                                    *existing_low = low;
                                                                    o
                                                                };
                                                                carry = {
                                                                    let existing_hi = &mut ret[i + j + 1];
                                                                    let hi = hi + overflow as u64;
                                                                    let (hi, o0) = hi.overflowing_add(carry);
                                                                    let (hi, o1) = hi.overflowing_add(*existing_hi);
                                                                    *existing_hi = hi;
                                                                    (o0 | o1) as u64
                                                                };
                                                            }
                                                        }
                                                    }
                                                }
                                                {
                                                    const j: usize = 0 + 3;
                                                    {
                                                        if j >= 0 {
                                                            if (|_, _| true)(me[j], carry) {
                                                                let a = me[j];
                                                                let (hi, low) = Self::split_u128(a as u128 * b as u128);
                                                                let overflow = {
                                                                    let existing_low = &mut ret[i + j];
                                                                    let (low, o) = low.overflowing_add(*existing_low);
                                                                    *existing_low = low;
                                                                    o
                                                                };
                                                                carry = {
                                                                    let existing_hi = &mut ret[i + j + 1];
                                                                    let hi = hi + overflow as u64;
                                                                    let (hi, o0) = hi.overflowing_add(carry);
                                                                    let (hi, o1) = hi.overflowing_add(*existing_hi);
                                                                    *existing_hi = hi;
                                                                    (o0 | o1) as u64
                                                                };
                                                            }
                                                        }
                                                    }
                                                };
                                            }
                                        }
                                    }
                                }
                                {
                                    const i: usize = 0 + 3;
                                    {
                                        if i >= 0 {
                                            let mut carry = 0u64;
                                            let b = you[i];
                                            #[allow(non_upper_case_globals)]
                                            #[allow(unused_comparisons)]
                                            {
                                                {
                                                    const j: usize = 0;
                                                    {
                                                        if j >= 0 {
                                                            if (|_, _| true)(me[j], carry) {
                                                                let a = me[j];
                                                                let (hi, low) = Self::split_u128(a as u128 * b as u128);
                                                                let overflow = {
                                                                    let existing_low = &mut ret[i + j];
                                                                    let (low, o) = low.overflowing_add(*existing_low);
                                                                    *existing_low = low;
                                                                    o
                                                                };
                                                                carry = {
                                                                    let existing_hi = &mut ret[i + j + 1];
                                                                    let hi = hi + overflow as u64;
                                                                    let (hi, o0) = hi.overflowing_add(carry);
                                                                    let (hi, o1) = hi.overflowing_add(*existing_hi);
                                                                    *existing_hi = hi;
                                                                    (o0 | o1) as u64
                                                                };
                                                            }
                                                        }
                                                    }
                                                }
                                                {
                                                    const j: usize = 0 + 1;
                                                    {
                                                        if j >= 0 {
                                                            if (|_, _| true)(me[j], carry) {
                                                                let a = me[j];
                                                                let (hi, low) = Self::split_u128(a as u128 * b as u128);
                                                                let overflow = {
                                                                    let existing_low = &mut ret[i + j];
                                                                    let (low, o) = low.overflowing_add(*existing_low);
                                                                    *existing_low = low;
                                                                    o
                                                                };
                                                                carry = {
                                                                    let existing_hi = &mut ret[i + j + 1];
                                                                    let hi = hi + overflow as u64;
                                                                    let (hi, o0) = hi.overflowing_add(carry);
                                                                    let (hi, o1) = hi.overflowing_add(*existing_hi);
                                                                    *existing_hi = hi;
                                                                    (o0 | o1) as u64
                                                                };
                                                            }
                                                        }
                                                    }
                                                }
                                                {
                                                    const j: usize = 0 + 2;
                                                    {
                                                        if j >= 0 {
                                                            if (|_, _| true)(me[j], carry) {
                                                                let a = me[j];
                                                                let (hi, low) = Self::split_u128(a as u128 * b as u128);
                                                                let overflow = {
                                                                    let existing_low = &mut ret[i + j];
                                                                    let (low, o) = low.overflowing_add(*existing_low);
                                                                    *existing_low = low;
                                                                    o
                                                                };
                                                                carry = {
                                                                    let existing_hi = &mut ret[i + j + 1];
                                                                    let hi = hi + overflow as u64;
                                                                    let (hi, o0) = hi.overflowing_add(carry);
                                                                    let (hi, o1) = hi.overflowing_add(*existing_hi);
                                                                    *existing_hi = hi;
                                                                    (o0 | o1) as u64
                                                                };
                                                            }
                                                        }
                                                    }
                                                }
                                                {
                                                    const j: usize = 0 + 3;
                                                    {
                                                        if j >= 0 {
                                                            if (|_, _| true)(me[j], carry) {
                                                                let a = me[j];
                                                                let (hi, low) = Self::split_u128(a as u128 * b as u128);
                                                                let overflow = {
                                                                    let existing_low = &mut ret[i + j];
                                                                    let (low, o) = low.overflowing_add(*existing_low);
                                                                    *existing_low = low;
                                                                    o
                                                                };
                                                                carry = {
                                                                    let existing_hi = &mut ret[i + j + 1];
                                                                    let hi = hi + overflow as u64;
                                                                    let (hi, o0) = hi.overflowing_add(carry);
                                                                    let (hi, o1) = hi.overflowing_add(*existing_hi);
                                                                    *existing_hi = hi;
                                                                    (o0 | o1) as u64
                                                                };
                                                            }
                                                        }
                                                    }
                                                };
                                            }
                                        }
                                    }
                                };
                            }
                            ret
                        }
                    };
                    let ret: [[u64; 4]; 2] = unsafe {
                        ::uint::core_::mem::transmute(ret)
                    };
                    #[inline(always)]
                    fn any_nonzero(arr: &[u64; 4]) -> bool {
                        use ::uint::unroll;
                        #[allow(non_upper_case_globals)] #[allow(unused_comparisons)]
                        {
                            {
                                const i: usize = 0;
                                {
                                    if i >= 0 {
                                        if arr[i] != 0 {
                                            return true;
                                        }
                                    }
                                }
                            }
                            {
                                const i: usize = 0 + 1;
                                {
                                    if i >= 0 {
                                        if arr[i] != 0 {
                                            return true;
                                        }
                                    }
                                }
                            }
                            {
                                const i: usize = 0 + 2;
                                {
                                    if i >= 0 {
                                        if arr[i] != 0 {
                                            return true;
                                        }
                                    }
                                }
                            }
                            {
                                const i: usize = 0 + 3;
                                {
                                    if i >= 0 {
                                        if arr[i] != 0 {
                                            return true;
                                        }
                                    }
                                }
                            };
                        }
                        false
                    }
                    (U256(ret[0]), any_nonzero(&ret[1]))
                }
            }
            /// Multiplication which saturates at the maximum value..
            pub fn saturating_mul(self, other: U256) -> U256 {
                match self.overflowing_mul(other) {
                    (_, true) => U256::MAX,
                    (val, false) => val,
                }
            }
            /// Checked multiplication. Returns `None` if overflow occurred.
            pub fn checked_mul(self, other: U256) -> Option<U256> {
                match self.overflowing_mul(other) {
                    (_, true) => None,
                    (val, _) => Some(val),
                }
            }
            /// Checked division. Returns `None` if `other == 0`.
            pub fn checked_div(self, other: U256) -> Option<U256> {
                if other.is_zero() { None } else { Some(self / other) }
            }
            /// Checked modulus. Returns `None` if `other == 0`.
            pub fn checked_rem(self, other: U256) -> Option<U256> {
                if other.is_zero() { None } else { Some(self % other) }
            }
            /// Negation with overflow.
            pub fn overflowing_neg(self) -> (U256, bool) {
                if self.is_zero() { (self, false) } else { (!self + 1, true) }
            }
            /// Checked negation. Returns `None` unless `self == 0`.
            pub fn checked_neg(self) -> Option<U256> {
                match self.overflowing_neg() {
                    (_, true) => None,
                    (zero, false) => Some(zero),
                }
            }
            #[inline(always)]
            fn div_mod_word(hi: u64, lo: u64, y: u64) -> (u64, u64) {
                if true {
                    {
                        match hi < y {
                            true => {}
                            _ => ::core::panicking::panic("assertion failed: hi < y"),
                        }
                    };
                }
                let x = (u128::from(hi) << 64) + u128::from(lo);
                let y = u128::from(y);
                ((x / y) as u64, (x % y) as u64)
            }
            #[inline(always)]
            fn add_slice(a: &mut [u64], b: &[u64]) -> bool {
                Self::binop_slice(a, b, u64::overflowing_add)
            }
            #[inline(always)]
            fn sub_slice(a: &mut [u64], b: &[u64]) -> bool {
                Self::binop_slice(a, b, u64::overflowing_sub)
            }
            #[inline(always)]
            fn binop_slice(
                a: &mut [u64],
                b: &[u64],
                binop: impl Fn(u64, u64) -> (u64, bool) + Copy,
            ) -> bool {
                let mut c = false;
                a.iter_mut()
                    .zip(b.iter())
                    .for_each(|(x, y)| {
                        let (res, carry) = Self::binop_carry(*x, *y, c, binop);
                        *x = res;
                        c = carry;
                    });
                c
            }
            #[inline(always)]
            fn binop_carry(
                a: u64,
                b: u64,
                c: bool,
                binop: impl Fn(u64, u64) -> (u64, bool),
            ) -> (u64, bool) {
                let (res1, overflow1) = b.overflowing_add(u64::from(c));
                let (res2, overflow2) = binop(a, res1);
                (res2, overflow1 || overflow2)
            }
            #[inline(always)]
            const fn mul_u64(a: u64, b: u64, carry: u64) -> (u64, u64) {
                let (hi, lo) = Self::split_u128(a as u128 * b as u128 + carry as u128);
                (lo, hi)
            }
            #[inline(always)]
            const fn split(a: u64) -> (u64, u64) {
                (a >> 32, a & 0xFFFF_FFFF)
            }
            #[inline(always)]
            const fn split_u128(a: u128) -> (u64, u64) {
                ((a >> 64) as _, (a & 0xFFFFFFFFFFFFFFFF) as _)
            }
            /// Overflowing multiplication by u64.
            /// Returns the result and carry.
            fn overflowing_mul_u64(mut self, other: u64) -> (Self, u64) {
                let mut carry = 0u64;
                for d in self.0.iter_mut() {
                    let (res, c) = Self::mul_u64(*d, other, carry);
                    *d = res;
                    carry = c;
                }
                (self, carry)
            }
            /// Converts from big endian representation bytes in memory.
            pub fn from_big_endian(slice: &[u8]) -> Self {
                use ::uint::byteorder::{ByteOrder, BigEndian};
                {
                    match 4 * 8 >= slice.len() {
                        true => {}
                        _ => {
                            ::core::panicking::panic(
                                "assertion failed: 4 * 8 >= slice.len()",
                            )
                        }
                    }
                };
                let mut padded = [0u8; 4 * 8];
                padded[4 * 8 - slice.len()..4 * 8].copy_from_slice(&slice);
                let mut ret = [0; 4];
                for i in 0..4 {
                    ret[4 - i - 1] = BigEndian::read_u64(&padded[8 * i..]);
                }
                U256(ret)
            }
            /// Converts from little endian representation bytes in memory.
            pub fn from_little_endian(slice: &[u8]) -> Self {
                use ::uint::byteorder::{ByteOrder, LittleEndian};
                {
                    match 4 * 8 >= slice.len() {
                        true => {}
                        _ => {
                            ::core::panicking::panic(
                                "assertion failed: 4 * 8 >= slice.len()",
                            )
                        }
                    }
                };
                let mut padded = [0u8; 4 * 8];
                padded[0..slice.len()].copy_from_slice(&slice);
                let mut ret = [0; 4];
                for i in 0..4 {
                    ret[i] = LittleEndian::read_u64(&padded[8 * i..]);
                }
                U256(ret)
            }
            fn fmt_hex(
                &self,
                f: &mut ::uint::core_::fmt::Formatter,
                is_lower: bool,
            ) -> ::uint::core_::fmt::Result {
                let &U256(ref data) = self;
                if self.is_zero() {
                    return f.pad_integral(true, "0x", "0");
                }
                let mut latch = false;
                let mut buf = [0_u8; 4 * 16];
                let mut i = 0;
                for ch in data.iter().rev() {
                    for x in 0..16 {
                        let nibble = (ch & (15u64 << ((15 - x) * 4) as u64))
                            >> (((15 - x) * 4) as u64);
                        if !latch {
                            latch = nibble != 0;
                        }
                        if latch {
                            let nibble = match nibble {
                                0..=9 => nibble as u8 + b'0',
                                _ if is_lower => nibble as u8 - 10 + b'a',
                                _ => nibble as u8 - 10 + b'A',
                            };
                            buf[i] = nibble;
                            i += 1;
                        }
                    }
                }
                let s = unsafe { ::uint::core_::str::from_utf8_unchecked(&buf[0..i]) };
                f.pad_integral(true, "0x", s)
            }
        }
        impl ::uint::core_::default::Default for U256 {
            fn default() -> Self {
                U256::zero()
            }
        }
        impl ::uint::core_::convert::From<u64> for U256 {
            fn from(value: u64) -> U256 {
                let mut ret = [0; 4];
                ret[0] = value;
                U256(ret)
            }
        }
        impl From<u8> for U256 {
            fn from(value: u8) -> U256 {
                From::from(value as u64)
            }
        }
        impl From<u16> for U256 {
            fn from(value: u16) -> U256 {
                From::from(value as u64)
            }
        }
        impl From<u32> for U256 {
            fn from(value: u32) -> U256 {
                From::from(value as u64)
            }
        }
        impl From<usize> for U256 {
            fn from(value: usize) -> U256 {
                From::from(value as u64)
            }
        }
        impl ::uint::core_::convert::From<i64> for U256 {
            fn from(value: i64) -> U256 {
                match value >= 0 {
                    true => From::from(value as u64),
                    false => {
                        {
                            ::core::panicking::panic_fmt(
                                format_args!(
                                    "Unsigned integer can\'t be created from negative value",
                                ),
                            );
                        };
                    }
                }
            }
        }
        impl From<i8> for U256 {
            fn from(value: i8) -> U256 {
                From::from(value as i64)
            }
        }
        impl From<i16> for U256 {
            fn from(value: i16) -> U256 {
                From::from(value as i64)
            }
        }
        impl From<i32> for U256 {
            fn from(value: i32) -> U256 {
                From::from(value as i64)
            }
        }
        impl From<isize> for U256 {
            fn from(value: isize) -> U256 {
                From::from(value as i64)
            }
        }
        impl ::uint::core_::convert::TryFrom<U256> for u8 {
            type Error = &'static str;
            #[inline]
            fn try_from(u: U256) -> ::uint::core_::result::Result<u8, &'static str> {
                let U256(arr) = u;
                if !u.fits_word() || arr[0] > <u8>::max_value() as u64 {
                    Err("integer overflow when casting to u8")
                } else {
                    Ok(arr[0] as u8)
                }
            }
        }
        impl ::uint::core_::convert::TryFrom<U256> for u16 {
            type Error = &'static str;
            #[inline]
            fn try_from(u: U256) -> ::uint::core_::result::Result<u16, &'static str> {
                let U256(arr) = u;
                if !u.fits_word() || arr[0] > <u16>::max_value() as u64 {
                    Err("integer overflow when casting to u16")
                } else {
                    Ok(arr[0] as u16)
                }
            }
        }
        impl ::uint::core_::convert::TryFrom<U256> for u32 {
            type Error = &'static str;
            #[inline]
            fn try_from(u: U256) -> ::uint::core_::result::Result<u32, &'static str> {
                let U256(arr) = u;
                if !u.fits_word() || arr[0] > <u32>::max_value() as u64 {
                    Err("integer overflow when casting to u32")
                } else {
                    Ok(arr[0] as u32)
                }
            }
        }
        impl ::uint::core_::convert::TryFrom<U256> for usize {
            type Error = &'static str;
            #[inline]
            fn try_from(u: U256) -> ::uint::core_::result::Result<usize, &'static str> {
                let U256(arr) = u;
                if !u.fits_word() || arr[0] > <usize>::max_value() as u64 {
                    Err("integer overflow when casting to usize")
                } else {
                    Ok(arr[0] as usize)
                }
            }
        }
        impl ::uint::core_::convert::TryFrom<U256> for u64 {
            type Error = &'static str;
            #[inline]
            fn try_from(u: U256) -> ::uint::core_::result::Result<u64, &'static str> {
                let U256(arr) = u;
                if !u.fits_word() || arr[0] > <u64>::max_value() as u64 {
                    Err("integer overflow when casting to u64")
                } else {
                    Ok(arr[0] as u64)
                }
            }
        }
        impl ::uint::core_::convert::TryFrom<U256> for i8 {
            type Error = &'static str;
            #[inline]
            fn try_from(u: U256) -> ::uint::core_::result::Result<i8, &'static str> {
                let U256(arr) = u;
                if !u.fits_word() || arr[0] > <i8>::max_value() as u64 {
                    Err("integer overflow when casting to i8")
                } else {
                    Ok(arr[0] as i8)
                }
            }
        }
        impl ::uint::core_::convert::TryFrom<U256> for i16 {
            type Error = &'static str;
            #[inline]
            fn try_from(u: U256) -> ::uint::core_::result::Result<i16, &'static str> {
                let U256(arr) = u;
                if !u.fits_word() || arr[0] > <i16>::max_value() as u64 {
                    Err("integer overflow when casting to i16")
                } else {
                    Ok(arr[0] as i16)
                }
            }
        }
        impl ::uint::core_::convert::TryFrom<U256> for i32 {
            type Error = &'static str;
            #[inline]
            fn try_from(u: U256) -> ::uint::core_::result::Result<i32, &'static str> {
                let U256(arr) = u;
                if !u.fits_word() || arr[0] > <i32>::max_value() as u64 {
                    Err("integer overflow when casting to i32")
                } else {
                    Ok(arr[0] as i32)
                }
            }
        }
        impl ::uint::core_::convert::TryFrom<U256> for isize {
            type Error = &'static str;
            #[inline]
            fn try_from(u: U256) -> ::uint::core_::result::Result<isize, &'static str> {
                let U256(arr) = u;
                if !u.fits_word() || arr[0] > <isize>::max_value() as u64 {
                    Err("integer overflow when casting to isize")
                } else {
                    Ok(arr[0] as isize)
                }
            }
        }
        impl ::uint::core_::convert::TryFrom<U256> for i64 {
            type Error = &'static str;
            #[inline]
            fn try_from(u: U256) -> ::uint::core_::result::Result<i64, &'static str> {
                let U256(arr) = u;
                if !u.fits_word() || arr[0] > <i64>::max_value() as u64 {
                    Err("integer overflow when casting to i64")
                } else {
                    Ok(arr[0] as i64)
                }
            }
        }
        impl<T> ::uint::core_::ops::Add<T> for U256
        where
            T: Into<U256>,
        {
            type Output = U256;
            fn add(self, other: T) -> U256 {
                let (result, overflow) = self.overflowing_add(other.into());
                if overflow {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!("arithmetic operation overflow"),
                        );
                    }
                }
                result
            }
        }
        impl<'a, T> ::uint::core_::ops::Add<T> for &'a U256
        where
            T: Into<U256>,
        {
            type Output = U256;
            fn add(self, other: T) -> U256 {
                *self + other
            }
        }
        impl ::uint::core_::ops::AddAssign<U256> for U256 {
            fn add_assign(&mut self, other: U256) {
                let (result, overflow) = self.overflowing_add(other);
                if overflow {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!("arithmetic operation overflow"),
                        );
                    }
                }
                *self = result;
            }
        }
        impl<T> ::uint::core_::ops::Sub<T> for U256
        where
            T: Into<U256>,
        {
            type Output = U256;
            #[inline]
            fn sub(self, other: T) -> U256 {
                let (result, overflow) = self.overflowing_sub(other.into());
                if overflow {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!("arithmetic operation overflow"),
                        );
                    }
                }
                result
            }
        }
        impl<'a, T> ::uint::core_::ops::Sub<T> for &'a U256
        where
            T: Into<U256>,
        {
            type Output = U256;
            fn sub(self, other: T) -> U256 {
                *self - other
            }
        }
        impl ::uint::core_::ops::SubAssign<U256> for U256 {
            fn sub_assign(&mut self, other: U256) {
                let (result, overflow) = self.overflowing_sub(other);
                if overflow {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!("arithmetic operation overflow"),
                        );
                    }
                }
                *self = result;
            }
        }
        impl ::uint::core_::ops::Mul<U256> for U256 {
            type Output = U256;
            fn mul(self, other: U256) -> U256 {
                let bignum: U256 = other.into();
                let (result, overflow) = self.overflowing_mul(bignum);
                if overflow {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!("arithmetic operation overflow"),
                        );
                    }
                }
                result
            }
        }
        impl<'a> ::uint::core_::ops::Mul<&'a U256> for U256 {
            type Output = U256;
            fn mul(self, other: &'a U256) -> U256 {
                let bignum: U256 = (*other).into();
                let (result, overflow) = self.overflowing_mul(bignum);
                if overflow {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!("arithmetic operation overflow"),
                        );
                    }
                }
                result
            }
        }
        impl<'a> ::uint::core_::ops::Mul<&'a U256> for &'a U256 {
            type Output = U256;
            fn mul(self, other: &'a U256) -> U256 {
                let bignum: U256 = (*other).into();
                let (result, overflow) = self.overflowing_mul(bignum);
                if overflow {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!("arithmetic operation overflow"),
                        );
                    }
                }
                result
            }
        }
        impl<'a> ::uint::core_::ops::Mul<U256> for &'a U256 {
            type Output = U256;
            fn mul(self, other: U256) -> U256 {
                let bignum: U256 = other.into();
                let (result, overflow) = self.overflowing_mul(bignum);
                if overflow {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!("arithmetic operation overflow"),
                        );
                    }
                }
                result
            }
        }
        impl ::uint::core_::ops::MulAssign<U256> for U256 {
            fn mul_assign(&mut self, other: U256) {
                let result = *self * other;
                *self = result;
            }
        }
        impl ::uint::core_::ops::Mul<u8> for U256 {
            type Output = U256;
            fn mul(self, other: u8) -> U256 {
                let (result, carry) = self.overflowing_mul_u64(other as u64);
                if carry > 0 {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!("arithmetic operation overflow"),
                        );
                    }
                }
                result
            }
        }
        impl<'a> ::uint::core_::ops::Mul<&'a u8> for U256 {
            type Output = U256;
            fn mul(self, other: &'a u8) -> U256 {
                let (result, carry) = self.overflowing_mul_u64(*other as u64);
                if carry > 0 {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!("arithmetic operation overflow"),
                        );
                    }
                }
                result
            }
        }
        impl<'a> ::uint::core_::ops::Mul<&'a u8> for &'a U256 {
            type Output = U256;
            fn mul(self, other: &'a u8) -> U256 {
                let (result, carry) = self.overflowing_mul_u64(*other as u64);
                if carry > 0 {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!("arithmetic operation overflow"),
                        );
                    }
                }
                result
            }
        }
        impl<'a> ::uint::core_::ops::Mul<u8> for &'a U256 {
            type Output = U256;
            fn mul(self, other: u8) -> U256 {
                let (result, carry) = self.overflowing_mul_u64(other as u64);
                if carry > 0 {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!("arithmetic operation overflow"),
                        );
                    }
                }
                result
            }
        }
        impl ::uint::core_::ops::MulAssign<u8> for U256 {
            fn mul_assign(&mut self, other: u8) {
                let result = *self * (other as u64);
                *self = result;
            }
        }
        impl ::uint::core_::ops::Mul<u16> for U256 {
            type Output = U256;
            fn mul(self, other: u16) -> U256 {
                let (result, carry) = self.overflowing_mul_u64(other as u64);
                if carry > 0 {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!("arithmetic operation overflow"),
                        );
                    }
                }
                result
            }
        }
        impl<'a> ::uint::core_::ops::Mul<&'a u16> for U256 {
            type Output = U256;
            fn mul(self, other: &'a u16) -> U256 {
                let (result, carry) = self.overflowing_mul_u64(*other as u64);
                if carry > 0 {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!("arithmetic operation overflow"),
                        );
                    }
                }
                result
            }
        }
        impl<'a> ::uint::core_::ops::Mul<&'a u16> for &'a U256 {
            type Output = U256;
            fn mul(self, other: &'a u16) -> U256 {
                let (result, carry) = self.overflowing_mul_u64(*other as u64);
                if carry > 0 {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!("arithmetic operation overflow"),
                        );
                    }
                }
                result
            }
        }
        impl<'a> ::uint::core_::ops::Mul<u16> for &'a U256 {
            type Output = U256;
            fn mul(self, other: u16) -> U256 {
                let (result, carry) = self.overflowing_mul_u64(other as u64);
                if carry > 0 {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!("arithmetic operation overflow"),
                        );
                    }
                }
                result
            }
        }
        impl ::uint::core_::ops::MulAssign<u16> for U256 {
            fn mul_assign(&mut self, other: u16) {
                let result = *self * (other as u64);
                *self = result;
            }
        }
        impl ::uint::core_::ops::Mul<u32> for U256 {
            type Output = U256;
            fn mul(self, other: u32) -> U256 {
                let (result, carry) = self.overflowing_mul_u64(other as u64);
                if carry > 0 {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!("arithmetic operation overflow"),
                        );
                    }
                }
                result
            }
        }
        impl<'a> ::uint::core_::ops::Mul<&'a u32> for U256 {
            type Output = U256;
            fn mul(self, other: &'a u32) -> U256 {
                let (result, carry) = self.overflowing_mul_u64(*other as u64);
                if carry > 0 {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!("arithmetic operation overflow"),
                        );
                    }
                }
                result
            }
        }
        impl<'a> ::uint::core_::ops::Mul<&'a u32> for &'a U256 {
            type Output = U256;
            fn mul(self, other: &'a u32) -> U256 {
                let (result, carry) = self.overflowing_mul_u64(*other as u64);
                if carry > 0 {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!("arithmetic operation overflow"),
                        );
                    }
                }
                result
            }
        }
        impl<'a> ::uint::core_::ops::Mul<u32> for &'a U256 {
            type Output = U256;
            fn mul(self, other: u32) -> U256 {
                let (result, carry) = self.overflowing_mul_u64(other as u64);
                if carry > 0 {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!("arithmetic operation overflow"),
                        );
                    }
                }
                result
            }
        }
        impl ::uint::core_::ops::MulAssign<u32> for U256 {
            fn mul_assign(&mut self, other: u32) {
                let result = *self * (other as u64);
                *self = result;
            }
        }
        impl ::uint::core_::ops::Mul<u64> for U256 {
            type Output = U256;
            fn mul(self, other: u64) -> U256 {
                let (result, carry) = self.overflowing_mul_u64(other as u64);
                if carry > 0 {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!("arithmetic operation overflow"),
                        );
                    }
                }
                result
            }
        }
        impl<'a> ::uint::core_::ops::Mul<&'a u64> for U256 {
            type Output = U256;
            fn mul(self, other: &'a u64) -> U256 {
                let (result, carry) = self.overflowing_mul_u64(*other as u64);
                if carry > 0 {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!("arithmetic operation overflow"),
                        );
                    }
                }
                result
            }
        }
        impl<'a> ::uint::core_::ops::Mul<&'a u64> for &'a U256 {
            type Output = U256;
            fn mul(self, other: &'a u64) -> U256 {
                let (result, carry) = self.overflowing_mul_u64(*other as u64);
                if carry > 0 {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!("arithmetic operation overflow"),
                        );
                    }
                }
                result
            }
        }
        impl<'a> ::uint::core_::ops::Mul<u64> for &'a U256 {
            type Output = U256;
            fn mul(self, other: u64) -> U256 {
                let (result, carry) = self.overflowing_mul_u64(other as u64);
                if carry > 0 {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!("arithmetic operation overflow"),
                        );
                    }
                }
                result
            }
        }
        impl ::uint::core_::ops::MulAssign<u64> for U256 {
            fn mul_assign(&mut self, other: u64) {
                let result = *self * (other as u64);
                *self = result;
            }
        }
        impl ::uint::core_::ops::Mul<usize> for U256 {
            type Output = U256;
            fn mul(self, other: usize) -> U256 {
                let (result, carry) = self.overflowing_mul_u64(other as u64);
                if carry > 0 {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!("arithmetic operation overflow"),
                        );
                    }
                }
                result
            }
        }
        impl<'a> ::uint::core_::ops::Mul<&'a usize> for U256 {
            type Output = U256;
            fn mul(self, other: &'a usize) -> U256 {
                let (result, carry) = self.overflowing_mul_u64(*other as u64);
                if carry > 0 {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!("arithmetic operation overflow"),
                        );
                    }
                }
                result
            }
        }
        impl<'a> ::uint::core_::ops::Mul<&'a usize> for &'a U256 {
            type Output = U256;
            fn mul(self, other: &'a usize) -> U256 {
                let (result, carry) = self.overflowing_mul_u64(*other as u64);
                if carry > 0 {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!("arithmetic operation overflow"),
                        );
                    }
                }
                result
            }
        }
        impl<'a> ::uint::core_::ops::Mul<usize> for &'a U256 {
            type Output = U256;
            fn mul(self, other: usize) -> U256 {
                let (result, carry) = self.overflowing_mul_u64(other as u64);
                if carry > 0 {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!("arithmetic operation overflow"),
                        );
                    }
                }
                result
            }
        }
        impl ::uint::core_::ops::MulAssign<usize> for U256 {
            fn mul_assign(&mut self, other: usize) {
                let result = *self * (other as u64);
                *self = result;
            }
        }
        impl ::uint::core_::ops::Mul<i8> for U256 {
            type Output = U256;
            fn mul(self, other: i8) -> U256 {
                let (result, carry) = self.overflowing_mul_u64(other as u64);
                if carry > 0 {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!("arithmetic operation overflow"),
                        );
                    }
                }
                result
            }
        }
        impl<'a> ::uint::core_::ops::Mul<&'a i8> for U256 {
            type Output = U256;
            fn mul(self, other: &'a i8) -> U256 {
                let (result, carry) = self.overflowing_mul_u64(*other as u64);
                if carry > 0 {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!("arithmetic operation overflow"),
                        );
                    }
                }
                result
            }
        }
        impl<'a> ::uint::core_::ops::Mul<&'a i8> for &'a U256 {
            type Output = U256;
            fn mul(self, other: &'a i8) -> U256 {
                let (result, carry) = self.overflowing_mul_u64(*other as u64);
                if carry > 0 {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!("arithmetic operation overflow"),
                        );
                    }
                }
                result
            }
        }
        impl<'a> ::uint::core_::ops::Mul<i8> for &'a U256 {
            type Output = U256;
            fn mul(self, other: i8) -> U256 {
                let (result, carry) = self.overflowing_mul_u64(other as u64);
                if carry > 0 {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!("arithmetic operation overflow"),
                        );
                    }
                }
                result
            }
        }
        impl ::uint::core_::ops::MulAssign<i8> for U256 {
            fn mul_assign(&mut self, other: i8) {
                let result = *self * (other as u64);
                *self = result;
            }
        }
        impl ::uint::core_::ops::Mul<i16> for U256 {
            type Output = U256;
            fn mul(self, other: i16) -> U256 {
                let (result, carry) = self.overflowing_mul_u64(other as u64);
                if carry > 0 {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!("arithmetic operation overflow"),
                        );
                    }
                }
                result
            }
        }
        impl<'a> ::uint::core_::ops::Mul<&'a i16> for U256 {
            type Output = U256;
            fn mul(self, other: &'a i16) -> U256 {
                let (result, carry) = self.overflowing_mul_u64(*other as u64);
                if carry > 0 {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!("arithmetic operation overflow"),
                        );
                    }
                }
                result
            }
        }
        impl<'a> ::uint::core_::ops::Mul<&'a i16> for &'a U256 {
            type Output = U256;
            fn mul(self, other: &'a i16) -> U256 {
                let (result, carry) = self.overflowing_mul_u64(*other as u64);
                if carry > 0 {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!("arithmetic operation overflow"),
                        );
                    }
                }
                result
            }
        }
        impl<'a> ::uint::core_::ops::Mul<i16> for &'a U256 {
            type Output = U256;
            fn mul(self, other: i16) -> U256 {
                let (result, carry) = self.overflowing_mul_u64(other as u64);
                if carry > 0 {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!("arithmetic operation overflow"),
                        );
                    }
                }
                result
            }
        }
        impl ::uint::core_::ops::MulAssign<i16> for U256 {
            fn mul_assign(&mut self, other: i16) {
                let result = *self * (other as u64);
                *self = result;
            }
        }
        impl ::uint::core_::ops::Mul<i32> for U256 {
            type Output = U256;
            fn mul(self, other: i32) -> U256 {
                let (result, carry) = self.overflowing_mul_u64(other as u64);
                if carry > 0 {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!("arithmetic operation overflow"),
                        );
                    }
                }
                result
            }
        }
        impl<'a> ::uint::core_::ops::Mul<&'a i32> for U256 {
            type Output = U256;
            fn mul(self, other: &'a i32) -> U256 {
                let (result, carry) = self.overflowing_mul_u64(*other as u64);
                if carry > 0 {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!("arithmetic operation overflow"),
                        );
                    }
                }
                result
            }
        }
        impl<'a> ::uint::core_::ops::Mul<&'a i32> for &'a U256 {
            type Output = U256;
            fn mul(self, other: &'a i32) -> U256 {
                let (result, carry) = self.overflowing_mul_u64(*other as u64);
                if carry > 0 {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!("arithmetic operation overflow"),
                        );
                    }
                }
                result
            }
        }
        impl<'a> ::uint::core_::ops::Mul<i32> for &'a U256 {
            type Output = U256;
            fn mul(self, other: i32) -> U256 {
                let (result, carry) = self.overflowing_mul_u64(other as u64);
                if carry > 0 {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!("arithmetic operation overflow"),
                        );
                    }
                }
                result
            }
        }
        impl ::uint::core_::ops::MulAssign<i32> for U256 {
            fn mul_assign(&mut self, other: i32) {
                let result = *self * (other as u64);
                *self = result;
            }
        }
        impl ::uint::core_::ops::Mul<i64> for U256 {
            type Output = U256;
            fn mul(self, other: i64) -> U256 {
                let (result, carry) = self.overflowing_mul_u64(other as u64);
                if carry > 0 {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!("arithmetic operation overflow"),
                        );
                    }
                }
                result
            }
        }
        impl<'a> ::uint::core_::ops::Mul<&'a i64> for U256 {
            type Output = U256;
            fn mul(self, other: &'a i64) -> U256 {
                let (result, carry) = self.overflowing_mul_u64(*other as u64);
                if carry > 0 {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!("arithmetic operation overflow"),
                        );
                    }
                }
                result
            }
        }
        impl<'a> ::uint::core_::ops::Mul<&'a i64> for &'a U256 {
            type Output = U256;
            fn mul(self, other: &'a i64) -> U256 {
                let (result, carry) = self.overflowing_mul_u64(*other as u64);
                if carry > 0 {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!("arithmetic operation overflow"),
                        );
                    }
                }
                result
            }
        }
        impl<'a> ::uint::core_::ops::Mul<i64> for &'a U256 {
            type Output = U256;
            fn mul(self, other: i64) -> U256 {
                let (result, carry) = self.overflowing_mul_u64(other as u64);
                if carry > 0 {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!("arithmetic operation overflow"),
                        );
                    }
                }
                result
            }
        }
        impl ::uint::core_::ops::MulAssign<i64> for U256 {
            fn mul_assign(&mut self, other: i64) {
                let result = *self * (other as u64);
                *self = result;
            }
        }
        impl ::uint::core_::ops::Mul<isize> for U256 {
            type Output = U256;
            fn mul(self, other: isize) -> U256 {
                let (result, carry) = self.overflowing_mul_u64(other as u64);
                if carry > 0 {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!("arithmetic operation overflow"),
                        );
                    }
                }
                result
            }
        }
        impl<'a> ::uint::core_::ops::Mul<&'a isize> for U256 {
            type Output = U256;
            fn mul(self, other: &'a isize) -> U256 {
                let (result, carry) = self.overflowing_mul_u64(*other as u64);
                if carry > 0 {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!("arithmetic operation overflow"),
                        );
                    }
                }
                result
            }
        }
        impl<'a> ::uint::core_::ops::Mul<&'a isize> for &'a U256 {
            type Output = U256;
            fn mul(self, other: &'a isize) -> U256 {
                let (result, carry) = self.overflowing_mul_u64(*other as u64);
                if carry > 0 {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!("arithmetic operation overflow"),
                        );
                    }
                }
                result
            }
        }
        impl<'a> ::uint::core_::ops::Mul<isize> for &'a U256 {
            type Output = U256;
            fn mul(self, other: isize) -> U256 {
                let (result, carry) = self.overflowing_mul_u64(other as u64);
                if carry > 0 {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!("arithmetic operation overflow"),
                        );
                    }
                }
                result
            }
        }
        impl ::uint::core_::ops::MulAssign<isize> for U256 {
            fn mul_assign(&mut self, other: isize) {
                let result = *self * (other as u64);
                *self = result;
            }
        }
        impl<T> ::uint::core_::ops::Div<T> for U256
        where
            T: Into<U256>,
        {
            type Output = U256;
            fn div(self, other: T) -> U256 {
                let other: Self = other.into();
                self.div_mod(other).0
            }
        }
        impl<'a, T> ::uint::core_::ops::Div<T> for &'a U256
        where
            T: Into<U256>,
        {
            type Output = U256;
            fn div(self, other: T) -> U256 {
                *self / other
            }
        }
        impl<T> ::uint::core_::ops::DivAssign<T> for U256
        where
            T: Into<U256>,
        {
            fn div_assign(&mut self, other: T) {
                *self = *self / other.into();
            }
        }
        impl<T> ::uint::core_::ops::Rem<T> for U256
        where
            T: Into<U256> + Copy,
        {
            type Output = U256;
            fn rem(self, other: T) -> U256 {
                let mut sub_copy = self;
                sub_copy %= other;
                sub_copy
            }
        }
        impl<'a, T> ::uint::core_::ops::Rem<T> for &'a U256
        where
            T: Into<U256> + Copy,
        {
            type Output = U256;
            fn rem(self, other: T) -> U256 {
                *self % other
            }
        }
        impl<T> ::uint::core_::ops::RemAssign<T> for U256
        where
            T: Into<U256> + Copy,
        {
            fn rem_assign(&mut self, other: T) {
                let other: Self = other.into();
                let rem = self.div_mod(other).1;
                *self = rem;
            }
        }
        impl ::uint::core_::ops::BitAnd<U256> for U256 {
            type Output = U256;
            #[inline]
            fn bitand(self, other: U256) -> U256 {
                let U256(ref arr1) = self;
                let U256(ref arr2) = other;
                let mut ret = [0u64; 4];
                for i in 0..4 {
                    ret[i] = arr1[i] & arr2[i];
                }
                U256(ret)
            }
        }
        impl ::uint::core_::ops::BitAndAssign<U256> for U256 {
            fn bitand_assign(&mut self, rhs: U256) {
                *self = *self & rhs;
            }
        }
        impl ::uint::core_::ops::BitXor<U256> for U256 {
            type Output = U256;
            #[inline]
            fn bitxor(self, other: U256) -> U256 {
                let U256(ref arr1) = self;
                let U256(ref arr2) = other;
                let mut ret = [0u64; 4];
                for i in 0..4 {
                    ret[i] = arr1[i] ^ arr2[i];
                }
                U256(ret)
            }
        }
        impl ::uint::core_::ops::BitXorAssign<U256> for U256 {
            fn bitxor_assign(&mut self, rhs: U256) {
                *self = *self ^ rhs;
            }
        }
        impl ::uint::core_::ops::BitOr<U256> for U256 {
            type Output = U256;
            #[inline]
            fn bitor(self, other: U256) -> U256 {
                let U256(ref arr1) = self;
                let U256(ref arr2) = other;
                let mut ret = [0u64; 4];
                for i in 0..4 {
                    ret[i] = arr1[i] | arr2[i];
                }
                U256(ret)
            }
        }
        impl ::uint::core_::ops::BitOrAssign<U256> for U256 {
            fn bitor_assign(&mut self, rhs: U256) {
                *self = *self | rhs;
            }
        }
        impl ::uint::core_::ops::Not for U256 {
            type Output = U256;
            #[inline]
            fn not(self) -> U256 {
                let U256(ref arr) = self;
                let mut ret = [0u64; 4];
                for i in 0..4 {
                    ret[i] = !arr[i];
                }
                U256(ret)
            }
        }
        impl<T> ::uint::core_::ops::Shl<T> for U256
        where
            T: Into<U256>,
        {
            type Output = U256;
            fn shl(self, shift: T) -> U256 {
                let shift = shift.into().as_usize();
                let U256(ref original) = self;
                let mut ret = [0u64; 4];
                let word_shift = shift / 64;
                let bit_shift = shift % 64;
                for i in word_shift..4 {
                    ret[i] = original[i - word_shift] << bit_shift;
                }
                if bit_shift > 0 {
                    for i in word_shift + 1..4 {
                        ret[i] += original[i - 1 - word_shift] >> (64 - bit_shift);
                    }
                }
                U256(ret)
            }
        }
        impl<'a, T> ::uint::core_::ops::Shl<T> for &'a U256
        where
            T: Into<U256>,
        {
            type Output = U256;
            fn shl(self, shift: T) -> U256 {
                *self << shift
            }
        }
        impl<T> ::uint::core_::ops::ShlAssign<T> for U256
        where
            T: Into<U256>,
        {
            fn shl_assign(&mut self, shift: T) {
                *self = *self << shift;
            }
        }
        impl<T> ::uint::core_::ops::Shr<T> for U256
        where
            T: Into<U256>,
        {
            type Output = U256;
            fn shr(self, shift: T) -> U256 {
                let shift = shift.into().as_usize();
                let U256(ref original) = self;
                let mut ret = [0u64; 4];
                let word_shift = shift / 64;
                let bit_shift = shift % 64;
                for i in word_shift..4 {
                    ret[i - word_shift] = original[i] >> bit_shift;
                }
                if bit_shift > 0 {
                    for i in word_shift + 1..4 {
                        ret[i - word_shift - 1] += original[i] << (64 - bit_shift);
                    }
                }
                U256(ret)
            }
        }
        impl<'a, T> ::uint::core_::ops::Shr<T> for &'a U256
        where
            T: Into<U256>,
        {
            type Output = U256;
            fn shr(self, shift: T) -> U256 {
                *self >> shift
            }
        }
        impl<T> ::uint::core_::ops::ShrAssign<T> for U256
        where
            T: Into<U256>,
        {
            fn shr_assign(&mut self, shift: T) {
                *self = *self >> shift;
            }
        }
        impl ::uint::core_::cmp::Ord for U256 {
            fn cmp(&self, other: &U256) -> ::uint::core_::cmp::Ordering {
                self.as_ref().iter().rev().cmp(other.as_ref().iter().rev())
            }
        }
        impl ::uint::core_::cmp::PartialOrd for U256 {
            fn partial_cmp(&self, other: &U256) -> Option<::uint::core_::cmp::Ordering> {
                Some(self.cmp(other))
            }
        }
        impl ::uint::core_::fmt::Debug for U256 {
            fn fmt(
                &self,
                f: &mut ::uint::core_::fmt::Formatter,
            ) -> ::uint::core_::fmt::Result {
                ::uint::core_::fmt::Display::fmt(self, f)
            }
        }
        impl ::uint::core_::fmt::Display for U256 {
            fn fmt(
                &self,
                f: &mut ::uint::core_::fmt::Formatter,
            ) -> ::uint::core_::fmt::Result {
                if self.is_zero() {
                    return f.write_fmt(format_args!("0"));
                }
                let mut buf = [0_u8; 4 * 20];
                let mut i = buf.len() - 1;
                let mut current = *self;
                let ten = U256::from(10);
                loop {
                    let digit = (current % ten).low_u64() as u8;
                    buf[i] = digit + b'0';
                    current /= ten;
                    if current.is_zero() {
                        break;
                    }
                    i -= 1;
                }
                let s = unsafe { ::uint::core_::str::from_utf8_unchecked(&buf[i..]) };
                f.pad_integral(true, "", s)
            }
        }
        impl ::uint::core_::fmt::LowerHex for U256 {
            fn fmt(
                &self,
                f: &mut ::uint::core_::fmt::Formatter,
            ) -> ::uint::core_::fmt::Result {
                self.fmt_hex(f, true)
            }
        }
        impl ::uint::core_::fmt::UpperHex for U256 {
            fn fmt(
                &self,
                f: &mut ::uint::core_::fmt::Formatter,
            ) -> ::uint::core_::fmt::Result {
                self.fmt_hex(f, false)
            }
        }
        impl ::uint::core_::str::FromStr for U256 {
            type Err = ::uint::FromHexError;
            fn from_str(value: &str) -> ::uint::core_::result::Result<U256, Self::Err> {
                let value = value.strip_prefix("0x").unwrap_or(value);
                const BYTES_LEN: usize = 4 * 8;
                const MAX_ENCODED_LEN: usize = BYTES_LEN * 2;
                let mut bytes = [0_u8; BYTES_LEN];
                let encoded = value.as_bytes();
                if encoded.len() > MAX_ENCODED_LEN {
                    return Err(::uint::hex::FromHexError::InvalidStringLength.into());
                }
                if encoded.len() % 2 == 0 {
                    let out = &mut bytes[BYTES_LEN - encoded.len() / 2..];
                    ::uint::hex::decode_to_slice(encoded, out).map_err(Self::Err::from)?;
                } else {
                    let mut s = [b'0'; MAX_ENCODED_LEN];
                    s[MAX_ENCODED_LEN - encoded.len()..].copy_from_slice(encoded);
                    let encoded = &s[MAX_ENCODED_LEN - encoded.len() - 1..];
                    let out = &mut bytes[BYTES_LEN - encoded.len() / 2..];
                    ::uint::hex::decode_to_slice(encoded, out).map_err(Self::Err::from)?;
                }
                Ok(Self::from_big_endian(&bytes))
            }
        }
        impl ::uint::core_::convert::From<&'static str> for U256 {
            fn from(s: &'static str) -> Self {
                s.parse().unwrap()
            }
        }
        impl ::uint::core_::convert::From<u128> for U256 {
            fn from(value: u128) -> U256 {
                let mut ret = [0; 4];
                ret[0] = value as u64;
                ret[1] = (value >> 64) as u64;
                U256(ret)
            }
        }
        impl ::uint::core_::convert::From<i128> for U256 {
            fn from(value: i128) -> U256 {
                match value >= 0 {
                    true => From::from(value as u128),
                    false => {
                        {
                            ::core::panicking::panic_fmt(
                                format_args!(
                                    "Unsigned integer can\'t be created from negative value",
                                ),
                            );
                        };
                    }
                }
            }
        }
        impl U256 {
            /// Low 2 words (u128)
            #[inline]
            pub const fn low_u128(&self) -> u128 {
                let &U256(ref arr) = self;
                ((arr[1] as u128) << 64) + arr[0] as u128
            }
            /// Conversion to u128 with overflow checking
            ///
            /// # Panics
            ///
            /// Panics if the number is larger than 2^128.
            #[inline]
            pub fn as_u128(&self) -> u128 {
                let &U256(ref arr) = self;
                for i in 2..4 {
                    if arr[i] != 0 {
                        {
                            ::core::panicking::panic_fmt(
                                format_args!("Integer overflow when casting to u128"),
                            );
                        }
                    }
                }
                self.low_u128()
            }
        }
        impl ::uint::core_::convert::TryFrom<U256> for u128 {
            type Error = &'static str;
            #[inline]
            fn try_from(u: U256) -> ::uint::core_::result::Result<u128, &'static str> {
                let U256(arr) = u;
                for i in 2..4 {
                    if arr[i] != 0 {
                        return Err("integer overflow when casting to u128");
                    }
                }
                Ok(((arr[1] as u128) << 64) + arr[0] as u128)
            }
        }
        impl ::uint::core_::convert::TryFrom<U256> for i128 {
            type Error = &'static str;
            #[inline]
            fn try_from(u: U256) -> ::uint::core_::result::Result<i128, &'static str> {
                let err_str = "integer overflow when casting to i128";
                let i = u128::try_from(u).map_err(|_| err_str)?;
                if i > i128::max_value() as u128 { Err(err_str) } else { Ok(i as i128) }
            }
        }
        pub trait CheckedCeilDiv: Sized {
            /// Perform ceiling division
            fn checked_ceil_div(&self, rhs: Self) -> Option<(Self, Self)>;
        }
        impl CheckedCeilDiv for u128 {
            fn checked_ceil_div(&self, mut rhs: Self) -> Option<(Self, Self)> {
                let mut quotient = self.checked_div(rhs)?;
                if quotient == 0 {
                    if self.checked_mul(2 as u128)? >= rhs {
                        return Some((1, 0));
                    } else {
                        return Some((0, 0));
                    }
                }
                let remainder = self.checked_rem(rhs)?;
                if remainder > 0 {
                    quotient = quotient.checked_add(1)?;
                    rhs = self.checked_div(quotient)?;
                    let remainder = self.checked_rem(quotient)?;
                    if remainder > 0 {
                        rhs = rhs.checked_add(1)?;
                    }
                }
                Some((quotient, rhs))
            }
        }
    }
    pub mod token {
        use crate::error::ErrorCode;
        use anchor_lang::prelude::*;
        use anchor_spl::{token::Token, token_interface::Mint};
        use light_compressed_token_sdk::instructions::transfer2::{
            transfer_interface, transfer_interface_signed,
        };
        use spl_token_2022::{
            self,
            extension::{
                transfer_fee::{TransferFeeConfig, MAX_FEE_BASIS_POINTS},
                BaseStateWithExtensions, ExtensionType, StateWithExtensions,
            },
        };
        use std::collections::HashSet;
        const MINT_WHITELIST: [&'static str; 4] = [
            "HVbpJAQGNpkgBaYBZQBR1t7yFdvaYVp2vCQQfKKEN4tM",
            "Crn4x1Y2HUKko7ox2EZMT6N2t2ZyH7eKtwkBGVnhEq1g",
            "FrBfWJ4qE5sCzKm3k3JaAtqZcXUh4LvJygDeketsrsH4",
            "2b1kV6DkPAnxd5ixfnxCpjxmKwqjjaYmCZfHsFu24GXo",
        ];
        pub fn transfer_from_user_to_pool_vault<'a, 'b>(
            authority: AccountInfo<'a>,
            from: AccountInfo<'a>,
            to_vault: AccountInfo<'a>,
            mint: Option<AccountInfo<'a>>,
            spl_token_program: Option<AccountInfo<'a>>,
            compressed_token_pool_pda: Option<AccountInfo<'a>>,
            compressed_token_pool_pda_bump: Option<u8>,
            compressed_token_program_authority: AccountInfo<'a>,
            amount: u64,
        ) -> Result<()> {
            if amount == 0 {
                return Ok(());
            }
            transfer_interface(
                &from,
                &to_vault,
                &authority,
                amount,
                &authority,
                &compressed_token_program_authority,
                mint.as_ref(),
                spl_token_program.as_ref(),
                compressed_token_pool_pda.as_ref(),
                compressed_token_pool_pda_bump,
            )?;
            Ok(())
        }
        pub fn transfer_from_pool_vault_to_user<'a>(
            payer: AccountInfo<'a>,
            authority: AccountInfo<'a>,
            from_vault: AccountInfo<'a>,
            to: AccountInfo<'a>,
            mint: Option<AccountInfo<'a>>,
            spl_token_program: Option<AccountInfo<'a>>,
            compressed_token_pool_pda: Option<AccountInfo<'a>>,
            compressed_token_pool_pda_bump: Option<u8>,
            compressed_token_program_authority: AccountInfo<'a>,
            amount: u64,
            signer_seeds: &[&[&[u8]]],
        ) -> Result<()> {
            if amount == 0 {
                return Ok(());
            }
            transfer_interface_signed(
                &from_vault,
                &to,
                &authority,
                amount,
                &payer,
                &compressed_token_program_authority,
                mint.as_ref(),
                spl_token_program.as_ref(),
                compressed_token_pool_pda.as_ref(),
                compressed_token_pool_pda_bump,
                signer_seeds,
            )?;
            Ok(())
        }
        /// Calculate the fee for output amount
        pub fn get_transfer_inverse_fee(
            mint_info: &AccountInfo,
            post_fee_amount: u64,
        ) -> Result<u64> {
            if *mint_info.owner == anchor_lang::solana_program::system_program::ID {
                return Ok(0);
            }
            if *mint_info.owner == Token::id() {
                return Ok(0);
            }
            if post_fee_amount == 0 {
                return Err(
                    anchor_lang::error::Error::from(anchor_lang::error::AnchorError {
                        error_name: ErrorCode::InvalidInput.name(),
                        error_code_number: ErrorCode::InvalidInput.into(),
                        error_msg: ErrorCode::InvalidInput.to_string(),
                        error_origin: Some(
                            anchor_lang::error::ErrorOrigin::Source(anchor_lang::error::Source {
                                filename: "programs/cp-swap/src/utils/token.rs",
                                line: 93u32,
                            }),
                        ),
                        compared_values: None,
                    }),
                );
            }
            let mint_data = mint_info.try_borrow_data()?;
            let mint = StateWithExtensions::<
                spl_token_2022::state::Mint,
            >::unpack(&mint_data)?;
            let fee = if let Ok(transfer_fee_config) = mint
                .get_extension::<TransferFeeConfig>()
            {
                let epoch = Clock::get()?.epoch;
                let transfer_fee = transfer_fee_config.get_epoch_fee(epoch);
                if u16::from(transfer_fee.transfer_fee_basis_points)
                    == MAX_FEE_BASIS_POINTS
                {
                    u64::from(transfer_fee.maximum_fee)
                } else {
                    let transfer_fee = transfer_fee_config
                        .calculate_inverse_epoch_fee(epoch, post_fee_amount)
                        .unwrap();
                    let transfer_fee_for_check = transfer_fee_config
                        .calculate_epoch_fee(
                            epoch,
                            post_fee_amount.checked_add(transfer_fee).unwrap(),
                        )
                        .unwrap();
                    if transfer_fee != transfer_fee_for_check {
                        return Err(
                            anchor_lang::error::Error::from(anchor_lang::error::AnchorError {
                                error_name: ErrorCode::TransferFeeCalculateNotMatch.name(),
                                error_code_number: ErrorCode::TransferFeeCalculateNotMatch
                                    .into(),
                                error_msg: ErrorCode::TransferFeeCalculateNotMatch
                                    .to_string(),
                                error_origin: Some(
                                    anchor_lang::error::ErrorOrigin::Source(anchor_lang::error::Source {
                                        filename: "programs/cp-swap/src/utils/token.rs",
                                        line: 112u32,
                                    }),
                                ),
                                compared_values: None,
                            }),
                        );
                    }
                    transfer_fee
                }
            } else {
                0
            };
            Ok(fee)
        }
        /// Calculate the fee for input amount
        pub fn get_transfer_fee(
            mint_info: &AccountInfo,
            pre_fee_amount: u64,
        ) -> Result<u64> {
            if *mint_info.owner == anchor_lang::solana_program::system_program::ID {
                return Ok(0);
            }
            if *mint_info.owner == Token::id() {
                return Ok(0);
            }
            let mint_data = mint_info.try_borrow_data()?;
            let mint = StateWithExtensions::<
                spl_token_2022::state::Mint,
            >::unpack(&mint_data)?;
            let fee = if let Ok(transfer_fee_config) = mint
                .get_extension::<TransferFeeConfig>()
            {
                transfer_fee_config
                    .calculate_epoch_fee(Clock::get()?.epoch, pre_fee_amount)
                    .unwrap()
            } else {
                0
            };
            Ok(fee)
        }
        pub fn is_supported_mint(mint_account: &InterfaceAccount<Mint>) -> Result<bool> {
            let mint_info = mint_account.to_account_info();
            if *mint_info.owner == anchor_lang::solana_program::system_program::ID {
                return Ok(true);
            }
            if *mint_info.owner == Token::id() {
                return Ok(true);
            }
            let mint_whitelist: HashSet<&str> = MINT_WHITELIST.into_iter().collect();
            if mint_whitelist.contains(mint_account.key().to_string().as_str()) {
                return Ok(true);
            }
            let mint_data = mint_info.try_borrow_data()?;
            let mint = StateWithExtensions::<
                spl_token_2022::state::Mint,
            >::unpack(&mint_data)?;
            let extensions = mint.get_extension_types()?;
            for e in extensions {
                if e != ExtensionType::TokenMetadata {
                    return Ok(false);
                }
            }
            Ok(true)
        }
    }
    pub use compression::*;
    pub use ctoken::*;
    pub use math::*;
    pub use token::*;
}
use crate::curve::fees::FEE_RATE_DENOMINATOR_VALUE;
pub use crate::error::ErrorCode;
pub use crate::instructions::initialize::Initialize;
pub use crate::states::*;
use anchor_lang::prelude::*;
use instructions::*;
use light_sdk::derive_light_cpi_signer;
use light_sdk_macros::add_compressible_instructions;
use light_sdk_types::CpiSigner;
#[allow(dead_code)]
#[no_mangle]
/// Static string containing the security.txt file.
pub static security_txt: &str = "=======BEGIN SECURITY.TXT V1=======\u{0}name\u{0}raydium-cp-swap\u{0}project_url\u{0}https://raydium.io\u{0}contacts\u{0}link:https://immunefi.com/bounty/raydium\u{0}policy\u{0}https://immunefi.com/bounty/raydium\u{0}source_code\u{0}https://github.com/raydium-io/raydium-cp-swap\u{0}preferred_languages\u{0}en\u{0}auditors\u{0}https://github.com/raydium-io/raydium-docs/blob/master/audit/MadShield%20Q1%202024/raydium-cp-swap-v-1.0.0.pdf\u{0}=======END SECURITY.TXT V1=======\u{0}";
/// The static program ID
pub static ID: anchor_lang::solana_program::pubkey::Pubkey = anchor_lang::solana_program::pubkey::Pubkey::new_from_array([
    169u8,
    42u8,
    90u8,
    139u8,
    79u8,
    41u8,
    89u8,
    82u8,
    132u8,
    37u8,
    80u8,
    170u8,
    147u8,
    253u8,
    91u8,
    149u8,
    181u8,
    172u8,
    230u8,
    168u8,
    235u8,
    146u8,
    12u8,
    147u8,
    148u8,
    46u8,
    67u8,
    105u8,
    12u8,
    32u8,
    236u8,
    115u8,
]);
/// Const version of `ID`
pub const ID_CONST: anchor_lang::solana_program::pubkey::Pubkey = anchor_lang::solana_program::pubkey::Pubkey::new_from_array([
    169u8,
    42u8,
    90u8,
    139u8,
    79u8,
    41u8,
    89u8,
    82u8,
    132u8,
    37u8,
    80u8,
    170u8,
    147u8,
    253u8,
    91u8,
    149u8,
    181u8,
    172u8,
    230u8,
    168u8,
    235u8,
    146u8,
    12u8,
    147u8,
    148u8,
    46u8,
    67u8,
    105u8,
    12u8,
    32u8,
    236u8,
    115u8,
]);
/// Confirms that a given pubkey is equivalent to the program ID
pub fn check_id(id: &anchor_lang::solana_program::pubkey::Pubkey) -> bool {
    id == &ID
}
/// Returns the program ID
pub fn id() -> anchor_lang::solana_program::pubkey::Pubkey {
    ID
}
/// Const version of `ID`
pub const fn id_const() -> anchor_lang::solana_program::pubkey::Pubkey {
    ID_CONST
}
pub const LIGHT_CPI_SIGNER: CpiSigner = {
    ::light_sdk_types::CpiSigner {
        program_id: [
            169,
            42,
            90,
            139,
            79,
            41,
            89,
            82,
            132,
            37,
            80,
            170,
            147,
            253,
            91,
            149,
            181,
            172,
            230,
            168,
            235,
            146,
            12,
            147,
            148,
            46,
            67,
            105,
            12,
            32,
            236,
            115,
        ],
        cpi_signer: [
            80,
            146,
            39,
            213,
            229,
            18,
            197,
            250,
            215,
            140,
            229,
            99,
            221,
            150,
            76,
            98,
            85,
            201,
            185,
            84,
            101,
            127,
            107,
            18,
            212,
            247,
            230,
            78,
            6,
            83,
            128,
            121,
        ],
        bump: 255u8,
    }
};
pub mod admin {
    use super::{pubkey, Pubkey};
    pub const ID: Pubkey = anchor_lang::solana_program::pubkey::Pubkey::new_from_array([
        229u8,
        182u8,
        43u8,
        101u8,
        203u8,
        59u8,
        189u8,
        166u8,
        245u8,
        104u8,
        136u8,
        230u8,
        111u8,
        238u8,
        142u8,
        100u8,
        220u8,
        85u8,
        96u8,
        25u8,
        156u8,
        15u8,
        136u8,
        177u8,
        31u8,
        226u8,
        115u8,
        189u8,
        5u8,
        158u8,
        138u8,
        161u8,
    ]);
}
pub mod create_pool_fee_receiver {
    use super::{pubkey, Pubkey};
    pub const ID: Pubkey = anchor_lang::solana_program::pubkey::Pubkey::new_from_array([
        183u8,
        208u8,
        34u8,
        82u8,
        84u8,
        172u8,
        7u8,
        227u8,
        178u8,
        189u8,
        63u8,
        134u8,
        193u8,
        240u8,
        241u8,
        16u8,
        63u8,
        192u8,
        112u8,
        140u8,
        193u8,
        90u8,
        239u8,
        20u8,
        7u8,
        58u8,
        166u8,
        69u8,
        63u8,
        85u8,
        234u8,
        105u8,
    ]);
}
use light_sdk::LightDiscriminator;
pub const AUTH_SEED: &str = "vault_and_lp_mint_auth_seed";
const _: () = {
    const COMPRESSED_SIZE: usize = 8
        + <PoolState as light_sdk::compressible::compression_info::CompressedInitSpace>::COMPRESSED_INIT_SPACE;
    if COMPRESSED_SIZE > 800 {
        {
            ::core::panicking::panic_fmt(
                format_args!(
                    "Compressed account \'PoolState\' exceeds 800-byte compressible account size limit. If you need support for larger accounts, send a message to team@lightprotocol.com",
                ),
            );
        };
    }
};
const _: () = {
    const COMPRESSED_SIZE: usize = 8
        + <ObservationState as light_sdk::compressible::compression_info::CompressedInitSpace>::COMPRESSED_INIT_SPACE;
    if COMPRESSED_SIZE > 800 {
        {
            ::core::panicking::panic_fmt(
                format_args!(
                    "Compressed account \'ObservationState\' exceeds 800-byte compressible account size limit. If you need support for larger accounts, send a message to team@lightprotocol.com",
                ),
            );
        };
    }
};
#[repr(u32)]
/// Auto-generated error codes for compressible instructions
/// These are separate from the user's ErrorCode enum to avoid conflicts
pub enum CompressibleInstructionError {
    InvalidRentRecipient,
    CTokenDecompressionNotImplemented,
    PdaDecompressionNotImplemented,
    TokenCompressionNotImplemented,
    PdaCompressionNotImplemented,
}
#[automatically_derived]
impl ::core::fmt::Debug for CompressibleInstructionError {
    #[inline]
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        ::core::fmt::Formatter::write_str(
            f,
            match self {
                CompressibleInstructionError::InvalidRentRecipient => {
                    "InvalidRentRecipient"
                }
                CompressibleInstructionError::CTokenDecompressionNotImplemented => {
                    "CTokenDecompressionNotImplemented"
                }
                CompressibleInstructionError::PdaDecompressionNotImplemented => {
                    "PdaDecompressionNotImplemented"
                }
                CompressibleInstructionError::TokenCompressionNotImplemented => {
                    "TokenCompressionNotImplemented"
                }
                CompressibleInstructionError::PdaCompressionNotImplemented => {
                    "PdaCompressionNotImplemented"
                }
            },
        )
    }
}
#[automatically_derived]
impl ::core::clone::Clone for CompressibleInstructionError {
    #[inline]
    fn clone(&self) -> CompressibleInstructionError {
        *self
    }
}
#[automatically_derived]
impl ::core::marker::Copy for CompressibleInstructionError {}
impl CompressibleInstructionError {
    /// Gets the name of this [#enum_name].
    pub fn name(&self) -> String {
        match self {
            CompressibleInstructionError::InvalidRentRecipient => {
                "InvalidRentRecipient".to_string()
            }
            CompressibleInstructionError::CTokenDecompressionNotImplemented => {
                "CTokenDecompressionNotImplemented".to_string()
            }
            CompressibleInstructionError::PdaDecompressionNotImplemented => {
                "PdaDecompressionNotImplemented".to_string()
            }
            CompressibleInstructionError::TokenCompressionNotImplemented => {
                "TokenCompressionNotImplemented".to_string()
            }
            CompressibleInstructionError::PdaCompressionNotImplemented => {
                "PdaCompressionNotImplemented".to_string()
            }
        }
    }
}
impl From<CompressibleInstructionError> for u32 {
    fn from(e: CompressibleInstructionError) -> u32 {
        e as u32 + anchor_lang::error::ERROR_CODE_OFFSET
    }
}
impl From<CompressibleInstructionError> for anchor_lang::error::Error {
    fn from(error_code: CompressibleInstructionError) -> anchor_lang::error::Error {
        anchor_lang::error::Error::from(anchor_lang::error::AnchorError {
            error_name: error_code.name(),
            error_code_number: error_code.into(),
            error_msg: error_code.to_string(),
            error_origin: None,
            compared_values: None,
        })
    }
}
impl std::fmt::Display for CompressibleInstructionError {
    fn fmt(
        &self,
        fmt: &mut std::fmt::Formatter<'_>,
    ) -> std::result::Result<(), std::fmt::Error> {
        match self {
            CompressibleInstructionError::InvalidRentRecipient => {
                fmt.write_fmt(format_args!("Rent recipient does not match config"))
            }
            CompressibleInstructionError::CTokenDecompressionNotImplemented => {
                fmt.write_fmt(format_args!("CToken decompression not yet implemented"))
            }
            CompressibleInstructionError::PdaDecompressionNotImplemented => {
                fmt.write_fmt(
                    format_args!(
                        "PDA decompression not implemented in token-only variant",
                    ),
                )
            }
            CompressibleInstructionError::TokenCompressionNotImplemented => {
                fmt.write_fmt(
                    format_args!("Token compression not implemented in PDA-only variant"),
                )
            }
            CompressibleInstructionError::PdaCompressionNotImplemented => {
                fmt.write_fmt(
                    format_args!("PDA compression not implemented in token-only variant"),
                )
            }
        }
    }
}
/// Auto-generated CTokenAccountVariant enum from token seed specifications
#[repr(u8)]
pub enum CTokenAccountVariant {
    LpVault = 0u8,
    Token0Vault = 1u8,
    Token1Vault = 2u8,
}
impl borsh::ser::BorshSerialize for CTokenAccountVariant {
    fn serialize<W: borsh::maybestd::io::Write>(
        &self,
        writer: &mut W,
    ) -> ::core::result::Result<(), borsh::maybestd::io::Error> {
        let variant_idx: u8 = match self {
            CTokenAccountVariant::LpVault => 0u8,
            CTokenAccountVariant::Token0Vault => 1u8,
            CTokenAccountVariant::Token1Vault => 2u8,
        };
        writer.write_all(&variant_idx.to_le_bytes())?;
        match self {
            CTokenAccountVariant::LpVault => {}
            CTokenAccountVariant::Token0Vault => {}
            CTokenAccountVariant::Token1Vault => {}
        }
        Ok(())
    }
}
impl anchor_lang::idl::build::IdlBuild for CTokenAccountVariant {
    fn create_type() -> Option<anchor_lang::idl::types::IdlTypeDef> {
        Some(anchor_lang::idl::types::IdlTypeDef {
            name: Self::get_full_path(),
            docs: <[_]>::into_vec(
                ::alloc::boxed::box_new([
                    "Auto-generated CTokenAccountVariant enum from token seed specifications"
                        .into(),
                ]),
            ),
            serialization: anchor_lang::idl::types::IdlSerialization::default(),
            repr: Some(
                anchor_lang::idl::types::IdlRepr::Rust(anchor_lang::idl::types::IdlReprModifier {
                    packed: false,
                    align: None,
                }),
            ),
            generics: ::alloc::vec::Vec::new(),
            ty: anchor_lang::idl::types::IdlTypeDefTy::Enum {
                variants: <[_]>::into_vec(
                    ::alloc::boxed::box_new([
                        anchor_lang::idl::types::IdlEnumVariant {
                            name: "LpVault".into(),
                            fields: None,
                        },
                        anchor_lang::idl::types::IdlEnumVariant {
                            name: "Token0Vault".into(),
                            fields: None,
                        },
                        anchor_lang::idl::types::IdlEnumVariant {
                            name: "Token1Vault".into(),
                            fields: None,
                        },
                    ]),
                ),
            },
        })
    }
    fn insert_types(
        types: &mut std::collections::BTreeMap<
            String,
            anchor_lang::idl::types::IdlTypeDef,
        >,
    ) {}
    fn get_full_path() -> String {
        ::alloc::__export::must_use({
            ::alloc::fmt::format(
                format_args!("{0}::{1}", "raydium_cp_swap", "CTokenAccountVariant"),
            )
        })
    }
}
impl borsh::de::BorshDeserialize for CTokenAccountVariant {
    fn deserialize_reader<R: borsh::maybestd::io::Read>(
        reader: &mut R,
    ) -> ::core::result::Result<Self, borsh::maybestd::io::Error> {
        let tag = <u8 as borsh::de::BorshDeserialize>::deserialize_reader(reader)?;
        <Self as borsh::de::EnumExt>::deserialize_variant(reader, tag)
    }
}
impl borsh::de::EnumExt for CTokenAccountVariant {
    fn deserialize_variant<R: borsh::maybestd::io::Read>(
        reader: &mut R,
        variant_idx: u8,
    ) -> ::core::result::Result<Self, borsh::maybestd::io::Error> {
        let mut return_value = match variant_idx {
            0u8 => CTokenAccountVariant::LpVault,
            1u8 => CTokenAccountVariant::Token0Vault,
            2u8 => CTokenAccountVariant::Token1Vault,
            _ => {
                return Err(
                    borsh::maybestd::io::Error::new(
                        borsh::maybestd::io::ErrorKind::InvalidInput,
                        ::alloc::__export::must_use({
                            ::alloc::fmt::format(
                                format_args!("Unexpected variant index: {0:?}", variant_idx),
                            )
                        }),
                    ),
                );
            }
        };
        Ok(return_value)
    }
}
#[automatically_derived]
impl ::core::fmt::Debug for CTokenAccountVariant {
    #[inline]
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        ::core::fmt::Formatter::write_str(
            f,
            match self {
                CTokenAccountVariant::LpVault => "LpVault",
                CTokenAccountVariant::Token0Vault => "Token0Vault",
                CTokenAccountVariant::Token1Vault => "Token1Vault",
            },
        )
    }
}
#[automatically_derived]
impl ::core::clone::Clone for CTokenAccountVariant {
    #[inline]
    fn clone(&self) -> CTokenAccountVariant {
        *self
    }
}
#[automatically_derived]
impl ::core::marker::Copy for CTokenAccountVariant {}
pub enum CompressedAccountVariant {
    PoolState(PoolState),
    PackedPoolState(PackedPoolState),
    ObservationState(ObservationState),
    PackedObservationState(PackedObservationState),
    PackedCTokenData(light_sdk::token::PackedCTokenData<CTokenAccountVariant>),
    CTokenData(light_sdk::token::CTokenData<CTokenAccountVariant>),
}
#[automatically_derived]
impl ::core::clone::Clone for CompressedAccountVariant {
    #[inline]
    fn clone(&self) -> CompressedAccountVariant {
        match self {
            CompressedAccountVariant::PoolState(__self_0) => {
                CompressedAccountVariant::PoolState(
                    ::core::clone::Clone::clone(__self_0),
                )
            }
            CompressedAccountVariant::PackedPoolState(__self_0) => {
                CompressedAccountVariant::PackedPoolState(
                    ::core::clone::Clone::clone(__self_0),
                )
            }
            CompressedAccountVariant::ObservationState(__self_0) => {
                CompressedAccountVariant::ObservationState(
                    ::core::clone::Clone::clone(__self_0),
                )
            }
            CompressedAccountVariant::PackedObservationState(__self_0) => {
                CompressedAccountVariant::PackedObservationState(
                    ::core::clone::Clone::clone(__self_0),
                )
            }
            CompressedAccountVariant::PackedCTokenData(__self_0) => {
                CompressedAccountVariant::PackedCTokenData(
                    ::core::clone::Clone::clone(__self_0),
                )
            }
            CompressedAccountVariant::CTokenData(__self_0) => {
                CompressedAccountVariant::CTokenData(
                    ::core::clone::Clone::clone(__self_0),
                )
            }
        }
    }
}
#[automatically_derived]
impl ::core::fmt::Debug for CompressedAccountVariant {
    #[inline]
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        match self {
            CompressedAccountVariant::PoolState(__self_0) => {
                ::core::fmt::Formatter::debug_tuple_field1_finish(
                    f,
                    "PoolState",
                    &__self_0,
                )
            }
            CompressedAccountVariant::PackedPoolState(__self_0) => {
                ::core::fmt::Formatter::debug_tuple_field1_finish(
                    f,
                    "PackedPoolState",
                    &__self_0,
                )
            }
            CompressedAccountVariant::ObservationState(__self_0) => {
                ::core::fmt::Formatter::debug_tuple_field1_finish(
                    f,
                    "ObservationState",
                    &__self_0,
                )
            }
            CompressedAccountVariant::PackedObservationState(__self_0) => {
                ::core::fmt::Formatter::debug_tuple_field1_finish(
                    f,
                    "PackedObservationState",
                    &__self_0,
                )
            }
            CompressedAccountVariant::PackedCTokenData(__self_0) => {
                ::core::fmt::Formatter::debug_tuple_field1_finish(
                    f,
                    "PackedCTokenData",
                    &__self_0,
                )
            }
            CompressedAccountVariant::CTokenData(__self_0) => {
                ::core::fmt::Formatter::debug_tuple_field1_finish(
                    f,
                    "CTokenData",
                    &__self_0,
                )
            }
        }
    }
}
impl borsh::ser::BorshSerialize for CompressedAccountVariant
where
    PoolState: borsh::ser::BorshSerialize,
    PackedPoolState: borsh::ser::BorshSerialize,
    ObservationState: borsh::ser::BorshSerialize,
    PackedObservationState: borsh::ser::BorshSerialize,
    light_sdk::token::PackedCTokenData<CTokenAccountVariant>: borsh::ser::BorshSerialize,
    light_sdk::token::CTokenData<CTokenAccountVariant>: borsh::ser::BorshSerialize,
{
    fn serialize<W: borsh::maybestd::io::Write>(
        &self,
        writer: &mut W,
    ) -> ::core::result::Result<(), borsh::maybestd::io::Error> {
        let variant_idx: u8 = match self {
            CompressedAccountVariant::PoolState(..) => 0u8,
            CompressedAccountVariant::PackedPoolState(..) => 1u8,
            CompressedAccountVariant::ObservationState(..) => 2u8,
            CompressedAccountVariant::PackedObservationState(..) => 3u8,
            CompressedAccountVariant::PackedCTokenData(..) => 4u8,
            CompressedAccountVariant::CTokenData(..) => 5u8,
        };
        writer.write_all(&variant_idx.to_le_bytes())?;
        match self {
            CompressedAccountVariant::PoolState(id0) => {
                borsh::BorshSerialize::serialize(id0, writer)?;
            }
            CompressedAccountVariant::PackedPoolState(id0) => {
                borsh::BorshSerialize::serialize(id0, writer)?;
            }
            CompressedAccountVariant::ObservationState(id0) => {
                borsh::BorshSerialize::serialize(id0, writer)?;
            }
            CompressedAccountVariant::PackedObservationState(id0) => {
                borsh::BorshSerialize::serialize(id0, writer)?;
            }
            CompressedAccountVariant::PackedCTokenData(id0) => {
                borsh::BorshSerialize::serialize(id0, writer)?;
            }
            CompressedAccountVariant::CTokenData(id0) => {
                borsh::BorshSerialize::serialize(id0, writer)?;
            }
        }
        Ok(())
    }
}
impl anchor_lang::idl::build::IdlBuild for CompressedAccountVariant {
    fn create_type() -> Option<anchor_lang::idl::types::IdlTypeDef> {
        Some(anchor_lang::idl::types::IdlTypeDef {
            name: Self::get_full_path(),
            docs: ::alloc::vec::Vec::new(),
            serialization: anchor_lang::idl::types::IdlSerialization::default(),
            repr: None,
            generics: ::alloc::vec::Vec::new(),
            ty: anchor_lang::idl::types::IdlTypeDefTy::Enum {
                variants: <[_]>::into_vec(
                    ::alloc::boxed::box_new([
                        anchor_lang::idl::types::IdlEnumVariant {
                            name: "PoolState".into(),
                            fields: Some(
                                anchor_lang::idl::types::IdlDefinedFields::Tuple(
                                    <[_]>::into_vec(
                                        ::alloc::boxed::box_new([
                                            anchor_lang::idl::types::IdlType::Defined {
                                                name: <PoolState>::get_full_path(),
                                                generics: ::alloc::vec::Vec::new(),
                                            },
                                        ]),
                                    ),
                                ),
                            ),
                        },
                        anchor_lang::idl::types::IdlEnumVariant {
                            name: "PackedPoolState".into(),
                            fields: Some(
                                anchor_lang::idl::types::IdlDefinedFields::Tuple(
                                    <[_]>::into_vec(
                                        ::alloc::boxed::box_new([
                                            anchor_lang::idl::types::IdlType::Defined {
                                                name: <PackedPoolState>::get_full_path(),
                                                generics: ::alloc::vec::Vec::new(),
                                            },
                                        ]),
                                    ),
                                ),
                            ),
                        },
                        anchor_lang::idl::types::IdlEnumVariant {
                            name: "ObservationState".into(),
                            fields: Some(
                                anchor_lang::idl::types::IdlDefinedFields::Tuple(
                                    <[_]>::into_vec(
                                        ::alloc::boxed::box_new([
                                            anchor_lang::idl::types::IdlType::Defined {
                                                name: <ObservationState>::get_full_path(),
                                                generics: ::alloc::vec::Vec::new(),
                                            },
                                        ]),
                                    ),
                                ),
                            ),
                        },
                        anchor_lang::idl::types::IdlEnumVariant {
                            name: "PackedObservationState".into(),
                            fields: Some(
                                anchor_lang::idl::types::IdlDefinedFields::Tuple(
                                    <[_]>::into_vec(
                                        ::alloc::boxed::box_new([
                                            anchor_lang::idl::types::IdlType::Defined {
                                                name: <PackedObservationState>::get_full_path(),
                                                generics: ::alloc::vec::Vec::new(),
                                            },
                                        ]),
                                    ),
                                ),
                            ),
                        },
                        anchor_lang::idl::types::IdlEnumVariant {
                            name: "PackedCTokenData".into(),
                            fields: Some(
                                anchor_lang::idl::types::IdlDefinedFields::Tuple(
                                    <[_]>::into_vec(
                                        ::alloc::boxed::box_new([
                                            anchor_lang::idl::types::IdlType::Defined {
                                                name: <light_sdk::token::PackedCTokenData<
                                                    CTokenAccountVariant,
                                                >>::get_full_path(),
                                                generics: <[_]>::into_vec(
                                                    ::alloc::boxed::box_new([
                                                        anchor_lang::idl::types::IdlGenericArg::Type {
                                                            ty: anchor_lang::idl::types::IdlType::Defined {
                                                                name: <CTokenAccountVariant>::get_full_path(),
                                                                generics: ::alloc::vec::Vec::new(),
                                                            },
                                                        },
                                                    ]),
                                                ),
                                            },
                                        ]),
                                    ),
                                ),
                            ),
                        },
                        anchor_lang::idl::types::IdlEnumVariant {
                            name: "CTokenData".into(),
                            fields: Some(
                                anchor_lang::idl::types::IdlDefinedFields::Tuple(
                                    <[_]>::into_vec(
                                        ::alloc::boxed::box_new([
                                            anchor_lang::idl::types::IdlType::Defined {
                                                name: <light_sdk::token::CTokenData<
                                                    CTokenAccountVariant,
                                                >>::get_full_path(),
                                                generics: <[_]>::into_vec(
                                                    ::alloc::boxed::box_new([
                                                        anchor_lang::idl::types::IdlGenericArg::Type {
                                                            ty: anchor_lang::idl::types::IdlType::Defined {
                                                                name: <CTokenAccountVariant>::get_full_path(),
                                                                generics: ::alloc::vec::Vec::new(),
                                                            },
                                                        },
                                                    ]),
                                                ),
                                            },
                                        ]),
                                    ),
                                ),
                            ),
                        },
                    ]),
                ),
            },
        })
    }
    fn insert_types(
        types: &mut std::collections::BTreeMap<
            String,
            anchor_lang::idl::types::IdlTypeDef,
        >,
    ) {
        if let Some(ty) = <PoolState>::create_type() {
            types.insert(<PoolState>::get_full_path(), ty);
            <PoolState>::insert_types(types);
        }
        if let Some(ty) = <PackedPoolState>::create_type() {
            types.insert(<PackedPoolState>::get_full_path(), ty);
            <PackedPoolState>::insert_types(types);
        }
        if let Some(ty) = <ObservationState>::create_type() {
            types.insert(<ObservationState>::get_full_path(), ty);
            <ObservationState>::insert_types(types);
        }
        if let Some(ty) = <PackedObservationState>::create_type() {
            types.insert(<PackedObservationState>::get_full_path(), ty);
            <PackedObservationState>::insert_types(types);
        }
        if let Some(ty) = <light_sdk::token::PackedCTokenData<
            CTokenAccountVariant,
        >>::create_type() {
            types
                .insert(
                    <light_sdk::token::PackedCTokenData<
                        CTokenAccountVariant,
                    >>::get_full_path(),
                    ty,
                );
            <light_sdk::token::PackedCTokenData<
                CTokenAccountVariant,
            >>::insert_types(types);
        }
        if let Some(ty) = <CTokenAccountVariant>::create_type() {
            types.insert(<CTokenAccountVariant>::get_full_path(), ty);
            <CTokenAccountVariant>::insert_types(types);
        }
        if let Some(ty) = <light_sdk::token::CTokenData<
            CTokenAccountVariant,
        >>::create_type() {
            types
                .insert(
                    <light_sdk::token::CTokenData<
                        CTokenAccountVariant,
                    >>::get_full_path(),
                    ty,
                );
            <light_sdk::token::CTokenData<CTokenAccountVariant>>::insert_types(types);
        }
        if let Some(ty) = <CTokenAccountVariant>::create_type() {
            types.insert(<CTokenAccountVariant>::get_full_path(), ty);
            <CTokenAccountVariant>::insert_types(types);
        }
    }
    fn get_full_path() -> String {
        ::alloc::__export::must_use({
            ::alloc::fmt::format(
                format_args!("{0}::{1}", "raydium_cp_swap", "CompressedAccountVariant"),
            )
        })
    }
}
impl borsh::de::BorshDeserialize for CompressedAccountVariant
where
    PoolState: borsh::BorshDeserialize,
    PackedPoolState: borsh::BorshDeserialize,
    ObservationState: borsh::BorshDeserialize,
    PackedObservationState: borsh::BorshDeserialize,
    light_sdk::token::PackedCTokenData<CTokenAccountVariant>: borsh::BorshDeserialize,
    light_sdk::token::CTokenData<CTokenAccountVariant>: borsh::BorshDeserialize,
{
    fn deserialize_reader<R: borsh::maybestd::io::Read>(
        reader: &mut R,
    ) -> ::core::result::Result<Self, borsh::maybestd::io::Error> {
        let tag = <u8 as borsh::de::BorshDeserialize>::deserialize_reader(reader)?;
        <Self as borsh::de::EnumExt>::deserialize_variant(reader, tag)
    }
}
impl borsh::de::EnumExt for CompressedAccountVariant
where
    PoolState: borsh::BorshDeserialize,
    PackedPoolState: borsh::BorshDeserialize,
    ObservationState: borsh::BorshDeserialize,
    PackedObservationState: borsh::BorshDeserialize,
    light_sdk::token::PackedCTokenData<CTokenAccountVariant>: borsh::BorshDeserialize,
    light_sdk::token::CTokenData<CTokenAccountVariant>: borsh::BorshDeserialize,
{
    fn deserialize_variant<R: borsh::maybestd::io::Read>(
        reader: &mut R,
        variant_idx: u8,
    ) -> ::core::result::Result<Self, borsh::maybestd::io::Error> {
        let mut return_value = match variant_idx {
            0u8 => {
                CompressedAccountVariant::PoolState(
                    borsh::BorshDeserialize::deserialize_reader(reader)?,
                )
            }
            1u8 => {
                CompressedAccountVariant::PackedPoolState(
                    borsh::BorshDeserialize::deserialize_reader(reader)?,
                )
            }
            2u8 => {
                CompressedAccountVariant::ObservationState(
                    borsh::BorshDeserialize::deserialize_reader(reader)?,
                )
            }
            3u8 => {
                CompressedAccountVariant::PackedObservationState(
                    borsh::BorshDeserialize::deserialize_reader(reader)?,
                )
            }
            4u8 => {
                CompressedAccountVariant::PackedCTokenData(
                    borsh::BorshDeserialize::deserialize_reader(reader)?,
                )
            }
            5u8 => {
                CompressedAccountVariant::CTokenData(
                    borsh::BorshDeserialize::deserialize_reader(reader)?,
                )
            }
            _ => {
                return Err(
                    borsh::maybestd::io::Error::new(
                        borsh::maybestd::io::ErrorKind::InvalidInput,
                        ::alloc::__export::must_use({
                            ::alloc::fmt::format(
                                format_args!("Unexpected variant index: {0:?}", variant_idx),
                            )
                        }),
                    ),
                );
            }
        };
        Ok(return_value)
    }
}
impl Default for CompressedAccountVariant {
    fn default() -> Self {
        Self::PoolState(PoolState::default())
    }
}
impl light_hasher::DataHasher for CompressedAccountVariant {
    fn hash<H: light_hasher::Hasher>(
        &self,
    ) -> std::result::Result<[u8; 32], light_hasher::HasherError> {
        match self {
            CompressedAccountVariant::PoolState(data) => {
                <PoolState as light_hasher::DataHasher>::hash::<H>(data)
            }
            CompressedAccountVariant::PackedPoolState(_) => {
                ::core::panicking::panic("internal error: entered unreachable code")
            }
            CompressedAccountVariant::ObservationState(data) => {
                <ObservationState as light_hasher::DataHasher>::hash::<H>(data)
            }
            CompressedAccountVariant::PackedObservationState(_) => {
                ::core::panicking::panic("internal error: entered unreachable code")
            }
            Self::PackedCTokenData(_) => {
                ::core::panicking::panic("internal error: entered unreachable code")
            }
            Self::CTokenData(_) => {
                ::core::panicking::panic("internal error: entered unreachable code")
            }
        }
    }
}
impl light_sdk::LightDiscriminator for CompressedAccountVariant {
    const LIGHT_DISCRIMINATOR: [u8; 8] = [0; 8];
    const LIGHT_DISCRIMINATOR_SLICE: &'static [u8] = &Self::LIGHT_DISCRIMINATOR;
}
impl light_sdk::compressible::HasCompressionInfo for CompressedAccountVariant {
    fn compression_info(&self) -> &light_sdk::compressible::CompressionInfo {
        match self {
            CompressedAccountVariant::PoolState(data) => {
                <PoolState as light_sdk::compressible::HasCompressionInfo>::compression_info(
                    data,
                )
            }
            CompressedAccountVariant::PackedPoolState(_) => {
                ::core::panicking::panic("internal error: entered unreachable code")
            }
            CompressedAccountVariant::ObservationState(data) => {
                <ObservationState as light_sdk::compressible::HasCompressionInfo>::compression_info(
                    data,
                )
            }
            CompressedAccountVariant::PackedObservationState(_) => {
                ::core::panicking::panic("internal error: entered unreachable code")
            }
            Self::PackedCTokenData(_) => {
                ::core::panicking::panic("internal error: entered unreachable code")
            }
            Self::CTokenData(_) => {
                ::core::panicking::panic("internal error: entered unreachable code")
            }
        }
    }
    fn compression_info_mut(&mut self) -> &mut light_sdk::compressible::CompressionInfo {
        match self {
            CompressedAccountVariant::PoolState(data) => {
                <PoolState as light_sdk::compressible::HasCompressionInfo>::compression_info_mut(
                    data,
                )
            }
            CompressedAccountVariant::PackedPoolState(_) => {
                ::core::panicking::panic("internal error: entered unreachable code")
            }
            CompressedAccountVariant::ObservationState(data) => {
                <ObservationState as light_sdk::compressible::HasCompressionInfo>::compression_info_mut(
                    data,
                )
            }
            CompressedAccountVariant::PackedObservationState(_) => {
                ::core::panicking::panic("internal error: entered unreachable code")
            }
            Self::PackedCTokenData(_) => {
                ::core::panicking::panic("internal error: entered unreachable code")
            }
            Self::CTokenData(_) => {
                ::core::panicking::panic("internal error: entered unreachable code")
            }
        }
    }
    fn compression_info_mut_opt(
        &mut self,
    ) -> &mut Option<light_sdk::compressible::CompressionInfo> {
        match self {
            CompressedAccountVariant::PoolState(data) => {
                <PoolState as light_sdk::compressible::HasCompressionInfo>::compression_info_mut_opt(
                    data,
                )
            }
            CompressedAccountVariant::PackedPoolState(_) => {
                ::core::panicking::panic("internal error: entered unreachable code")
            }
            CompressedAccountVariant::ObservationState(data) => {
                <ObservationState as light_sdk::compressible::HasCompressionInfo>::compression_info_mut_opt(
                    data,
                )
            }
            CompressedAccountVariant::PackedObservationState(_) => {
                ::core::panicking::panic("internal error: entered unreachable code")
            }
            Self::PackedCTokenData(_) => {
                ::core::panicking::panic("internal error: entered unreachable code")
            }
            Self::CTokenData(_) => {
                ::core::panicking::panic("internal error: entered unreachable code")
            }
        }
    }
    fn set_compression_info_none(&mut self) {
        match self {
            CompressedAccountVariant::PoolState(data) => {
                <PoolState as light_sdk::compressible::HasCompressionInfo>::set_compression_info_none(
                    data,
                )
            }
            CompressedAccountVariant::PackedPoolState(_) => {
                ::core::panicking::panic("internal error: entered unreachable code")
            }
            CompressedAccountVariant::ObservationState(data) => {
                <ObservationState as light_sdk::compressible::HasCompressionInfo>::set_compression_info_none(
                    data,
                )
            }
            CompressedAccountVariant::PackedObservationState(_) => {
                ::core::panicking::panic("internal error: entered unreachable code")
            }
            Self::PackedCTokenData(_) => {
                ::core::panicking::panic("internal error: entered unreachable code")
            }
            Self::CTokenData(_) => {
                ::core::panicking::panic("internal error: entered unreachable code")
            }
        }
    }
}
impl light_sdk::account::Size for CompressedAccountVariant {
    fn size(&self) -> usize {
        match self {
            CompressedAccountVariant::PoolState(data) => {
                <PoolState as light_sdk::account::Size>::size(data)
            }
            CompressedAccountVariant::PackedPoolState(_) => {
                ::core::panicking::panic("internal error: entered unreachable code")
            }
            CompressedAccountVariant::ObservationState(data) => {
                <ObservationState as light_sdk::account::Size>::size(data)
            }
            CompressedAccountVariant::PackedObservationState(_) => {
                ::core::panicking::panic("internal error: entered unreachable code")
            }
            Self::PackedCTokenData(_) => {
                ::core::panicking::panic("internal error: entered unreachable code")
            }
            Self::CTokenData(_) => {
                ::core::panicking::panic("internal error: entered unreachable code")
            }
        }
    }
}
impl light_sdk::compressible::Pack for CompressedAccountVariant {
    type Packed = Self;
    fn pack(
        &self,
        remaining_accounts: &mut light_sdk::instruction::PackedAccounts,
    ) -> Self::Packed {
        match self {
            CompressedAccountVariant::PackedPoolState(_) => {
                ::core::panicking::panic("internal error: entered unreachable code")
            }
            CompressedAccountVariant::PoolState(data) => {
                CompressedAccountVariant::PackedPoolState(
                    <PoolState as light_sdk::compressible::Pack>::pack(
                        data,
                        remaining_accounts,
                    ),
                )
            }
            CompressedAccountVariant::PackedObservationState(_) => {
                ::core::panicking::panic("internal error: entered unreachable code")
            }
            CompressedAccountVariant::ObservationState(data) => {
                CompressedAccountVariant::PackedObservationState(
                    <ObservationState as light_sdk::compressible::Pack>::pack(
                        data,
                        remaining_accounts,
                    ),
                )
            }
            Self::PackedCTokenData(_) => {
                ::core::panicking::panic("internal error: entered unreachable code")
            }
            Self::CTokenData(data) => {
                Self::PackedCTokenData(data.pack(remaining_accounts))
            }
        }
    }
}
impl light_sdk::compressible::Unpack for CompressedAccountVariant {
    type Unpacked = Self;
    fn unpack(
        &self,
        remaining_accounts: &[anchor_lang::prelude::AccountInfo],
    ) -> std::result::Result<Self::Unpacked, anchor_lang::prelude::ProgramError> {
        match self {
            CompressedAccountVariant::PackedPoolState(data) => {
                Ok(
                    CompressedAccountVariant::PoolState(
                        <PackedPoolState as light_sdk::compressible::Unpack>::unpack(
                            data,
                            remaining_accounts,
                        )?,
                    ),
                )
            }
            CompressedAccountVariant::PoolState(_) => {
                ::core::panicking::panic("internal error: entered unreachable code")
            }
            CompressedAccountVariant::PackedObservationState(data) => {
                Ok(
                    CompressedAccountVariant::ObservationState(
                        <PackedObservationState as light_sdk::compressible::Unpack>::unpack(
                            data,
                            remaining_accounts,
                        )?,
                    ),
                )
            }
            CompressedAccountVariant::ObservationState(_) => {
                ::core::panicking::panic("internal error: entered unreachable code")
            }
            Self::PackedCTokenData(_data) => Ok(self.clone()),
            Self::CTokenData(_data) => {
                ::core::panicking::panic("internal error: entered unreachable code")
            }
        }
    }
}
pub struct CompressedAccountData {
    pub meta: light_sdk::instruction::account_meta::CompressedAccountMetaNoLamportsNoAddress,
    pub data: CompressedAccountVariant,
    /// Indices into remaining_accounts for seed account references (starting from seed_accounts_offset)
    pub seed_indices: Vec<u8>,
    /// Indices into remaining_accounts for authority seed references (for CTokens only)
    pub authority_indices: Vec<u8>,
}
#[automatically_derived]
impl ::core::clone::Clone for CompressedAccountData {
    #[inline]
    fn clone(&self) -> CompressedAccountData {
        CompressedAccountData {
            meta: ::core::clone::Clone::clone(&self.meta),
            data: ::core::clone::Clone::clone(&self.data),
            seed_indices: ::core::clone::Clone::clone(&self.seed_indices),
            authority_indices: ::core::clone::Clone::clone(&self.authority_indices),
        }
    }
}
#[automatically_derived]
impl ::core::fmt::Debug for CompressedAccountData {
    #[inline]
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        ::core::fmt::Formatter::debug_struct_field4_finish(
            f,
            "CompressedAccountData",
            "meta",
            &self.meta,
            "data",
            &self.data,
            "seed_indices",
            &self.seed_indices,
            "authority_indices",
            &&self.authority_indices,
        )
    }
}
impl borsh::de::BorshDeserialize for CompressedAccountData
where
    light_sdk::instruction::account_meta::CompressedAccountMetaNoLamportsNoAddress: borsh::BorshDeserialize,
    CompressedAccountVariant: borsh::BorshDeserialize,
    Vec<u8>: borsh::BorshDeserialize,
    Vec<u8>: borsh::BorshDeserialize,
{
    fn deserialize_reader<R: borsh::maybestd::io::Read>(
        reader: &mut R,
    ) -> ::core::result::Result<Self, borsh::maybestd::io::Error> {
        Ok(Self {
            meta: borsh::BorshDeserialize::deserialize_reader(reader)?,
            data: borsh::BorshDeserialize::deserialize_reader(reader)?,
            seed_indices: borsh::BorshDeserialize::deserialize_reader(reader)?,
            authority_indices: borsh::BorshDeserialize::deserialize_reader(reader)?,
        })
    }
}
impl borsh::ser::BorshSerialize for CompressedAccountData
where
    light_sdk::instruction::account_meta::CompressedAccountMetaNoLamportsNoAddress: borsh::ser::BorshSerialize,
    CompressedAccountVariant: borsh::ser::BorshSerialize,
    Vec<u8>: borsh::ser::BorshSerialize,
    Vec<u8>: borsh::ser::BorshSerialize,
{
    fn serialize<W: borsh::maybestd::io::Write>(
        &self,
        writer: &mut W,
    ) -> ::core::result::Result<(), borsh::maybestd::io::Error> {
        borsh::BorshSerialize::serialize(&self.meta, writer)?;
        borsh::BorshSerialize::serialize(&self.data, writer)?;
        borsh::BorshSerialize::serialize(&self.seed_indices, writer)?;
        borsh::BorshSerialize::serialize(&self.authority_indices, writer)?;
        Ok(())
    }
}
impl anchor_lang::idl::build::IdlBuild for CompressedAccountData {
    fn create_type() -> Option<anchor_lang::idl::types::IdlTypeDef> {
        Some(anchor_lang::idl::types::IdlTypeDef {
            name: Self::get_full_path(),
            docs: ::alloc::vec::Vec::new(),
            serialization: anchor_lang::idl::types::IdlSerialization::default(),
            repr: None,
            generics: ::alloc::vec::Vec::new(),
            ty: anchor_lang::idl::types::IdlTypeDefTy::Struct {
                fields: Some(
                    anchor_lang::idl::types::IdlDefinedFields::Named(
                        <[_]>::into_vec(
                            ::alloc::boxed::box_new([
                                anchor_lang::idl::types::IdlField {
                                    name: "meta".into(),
                                    docs: ::alloc::vec::Vec::new(),
                                    ty: anchor_lang::idl::types::IdlType::Defined {
                                        name: <light_sdk::instruction::account_meta::CompressedAccountMetaNoLamportsNoAddress>::get_full_path(),
                                        generics: ::alloc::vec::Vec::new(),
                                    },
                                },
                                anchor_lang::idl::types::IdlField {
                                    name: "data".into(),
                                    docs: ::alloc::vec::Vec::new(),
                                    ty: anchor_lang::idl::types::IdlType::Defined {
                                        name: <CompressedAccountVariant>::get_full_path(),
                                        generics: ::alloc::vec::Vec::new(),
                                    },
                                },
                                anchor_lang::idl::types::IdlField {
                                    name: "seed_indices".into(),
                                    docs: <[_]>::into_vec(
                                        ::alloc::boxed::box_new([
                                            "Indices into remaining_accounts for seed account references (starting from seed_accounts_offset)"
                                                .into(),
                                        ]),
                                    ),
                                    ty: anchor_lang::idl::types::IdlType::Bytes,
                                },
                                anchor_lang::idl::types::IdlField {
                                    name: "authority_indices".into(),
                                    docs: <[_]>::into_vec(
                                        ::alloc::boxed::box_new([
                                            "Indices into remaining_accounts for authority seed references (for CTokens only)"
                                                .into(),
                                        ]),
                                    ),
                                    ty: anchor_lang::idl::types::IdlType::Bytes,
                                },
                            ]),
                        ),
                    ),
                ),
            },
        })
    }
    fn insert_types(
        types: &mut std::collections::BTreeMap<
            String,
            anchor_lang::idl::types::IdlTypeDef,
        >,
    ) {
        if let Some(ty) = <light_sdk::instruction::account_meta::CompressedAccountMetaNoLamportsNoAddress>::create_type() {
            types
                .insert(
                    <light_sdk::instruction::account_meta::CompressedAccountMetaNoLamportsNoAddress>::get_full_path(),
                    ty,
                );
            <light_sdk::instruction::account_meta::CompressedAccountMetaNoLamportsNoAddress>::insert_types(
                types,
            );
        }
        if let Some(ty) = <CompressedAccountVariant>::create_type() {
            types.insert(<CompressedAccountVariant>::get_full_path(), ty);
            <CompressedAccountVariant>::insert_types(types);
        }
    }
    fn get_full_path() -> String {
        ::alloc::__export::must_use({
            ::alloc::fmt::format(
                format_args!("{0}::{1}", "raydium_cp_swap", "CompressedAccountData"),
            )
        })
    }
}
/// Auto-generated client-side seed function
pub fn get_poolstate_seeds(
    amm_config: &anchor_lang::prelude::Pubkey,
    token_0_mint: &anchor_lang::prelude::Pubkey,
    token_1_mint: &anchor_lang::prelude::Pubkey,
) -> (Vec<Vec<u8>>, anchor_lang::prelude::Pubkey) {
    let mut seed_values = Vec::with_capacity(4usize + 1);
    seed_values.push((POOL_SEED.as_bytes()).to_vec());
    seed_values.push((amm_config.as_ref()).to_vec());
    seed_values.push((token_0_mint.as_ref()).to_vec());
    seed_values.push((token_1_mint.as_ref()).to_vec());
    let seed_slices: Vec<&[u8]> = seed_values.iter().map(|v| v.as_slice()).collect();
    let (pda, bump) = anchor_lang::prelude::Pubkey::find_program_address(
        &seed_slices,
        &crate::ID,
    );
    seed_values.push(<[_]>::into_vec(::alloc::boxed::box_new([bump])));
    (seed_values, pda)
}
/// Auto-generated client-side seed function
pub fn get_observationstate_seeds(
    pool_state: &anchor_lang::prelude::Pubkey,
) -> (Vec<Vec<u8>>, anchor_lang::prelude::Pubkey) {
    let mut seed_values = Vec::with_capacity(2usize + 1);
    seed_values.push((OBSERVATION_SEED.as_bytes()).to_vec());
    seed_values.push((pool_state.as_ref()).to_vec());
    let seed_slices: Vec<&[u8]> = seed_values.iter().map(|v| v.as_slice()).collect();
    let (pda, bump) = anchor_lang::prelude::Pubkey::find_program_address(
        &seed_slices,
        &crate::ID,
    );
    seed_values.push(<[_]>::into_vec(::alloc::boxed::box_new([bump])));
    (seed_values, pda)
}
/// Auto-generated client-side CToken seed function (for token account address derivation)
pub fn get_lpvault_seeds(
    lp_mint: &anchor_lang::prelude::Pubkey,
) -> (Vec<Vec<u8>>, anchor_lang::prelude::Pubkey) {
    let mut seed_values = Vec::with_capacity(2usize + 1);
    seed_values.push((POOL_VAULT_SEED.as_bytes()).to_vec());
    seed_values.push((lp_mint.as_ref()).to_vec());
    let seed_slices: Vec<&[u8]> = seed_values.iter().map(|v| v.as_slice()).collect();
    let (pda, bump) = anchor_lang::prelude::Pubkey::find_program_address(
        &seed_slices,
        &crate::ID,
    );
    seed_values.push(<[_]>::into_vec(::alloc::boxed::box_new([bump])));
    (seed_values, pda)
}
/// Auto-generated authority seed function for compression signing
pub fn get_lpvault_authority_seeds() -> (Vec<Vec<u8>>, anchor_lang::prelude::Pubkey) {
    let mut seed_values = Vec::with_capacity(1usize + 1);
    seed_values.push((AUTH_SEED.as_bytes()).to_vec());
    let seed_slices: Vec<&[u8]> = seed_values.iter().map(|v| v.as_slice()).collect();
    let (pda, bump) = anchor_lang::prelude::Pubkey::find_program_address(
        &seed_slices,
        &crate::ID,
    );
    seed_values.push(<[_]>::into_vec(::alloc::boxed::box_new([bump])));
    (seed_values, pda)
}
/// Auto-generated client-side CToken seed function (for token account address derivation)
pub fn get_token0vault_seeds(
    pool_state: &anchor_lang::prelude::Pubkey,
    token_0_mint: &anchor_lang::prelude::Pubkey,
) -> (Vec<Vec<u8>>, anchor_lang::prelude::Pubkey) {
    let mut seed_values = Vec::with_capacity(3usize + 1);
    seed_values.push((POOL_VAULT_SEED.as_bytes()).to_vec());
    seed_values.push((pool_state.as_ref()).to_vec());
    seed_values.push((token_0_mint.as_ref()).to_vec());
    let seed_slices: Vec<&[u8]> = seed_values.iter().map(|v| v.as_slice()).collect();
    let (pda, bump) = anchor_lang::prelude::Pubkey::find_program_address(
        &seed_slices,
        &crate::ID,
    );
    seed_values.push(<[_]>::into_vec(::alloc::boxed::box_new([bump])));
    (seed_values, pda)
}
/// Auto-generated authority seed function for compression signing
pub fn get_token0vault_authority_seeds() -> (
    Vec<Vec<u8>>,
    anchor_lang::prelude::Pubkey,
) {
    let mut seed_values = Vec::with_capacity(1usize + 1);
    seed_values.push((AUTH_SEED.as_bytes()).to_vec());
    let seed_slices: Vec<&[u8]> = seed_values.iter().map(|v| v.as_slice()).collect();
    let (pda, bump) = anchor_lang::prelude::Pubkey::find_program_address(
        &seed_slices,
        &crate::ID,
    );
    seed_values.push(<[_]>::into_vec(::alloc::boxed::box_new([bump])));
    (seed_values, pda)
}
/// Auto-generated client-side CToken seed function (for token account address derivation)
pub fn get_token1vault_seeds(
    pool_state: &anchor_lang::prelude::Pubkey,
    token_1_mint: &anchor_lang::prelude::Pubkey,
) -> (Vec<Vec<u8>>, anchor_lang::prelude::Pubkey) {
    let mut seed_values = Vec::with_capacity(3usize + 1);
    seed_values.push((POOL_VAULT_SEED.as_bytes()).to_vec());
    seed_values.push((pool_state.as_ref()).to_vec());
    seed_values.push((token_1_mint.as_ref()).to_vec());
    let seed_slices: Vec<&[u8]> = seed_values.iter().map(|v| v.as_slice()).collect();
    let (pda, bump) = anchor_lang::prelude::Pubkey::find_program_address(
        &seed_slices,
        &crate::ID,
    );
    seed_values.push(<[_]>::into_vec(::alloc::boxed::box_new([bump])));
    (seed_values, pda)
}
/// Auto-generated authority seed function for compression signing
pub fn get_token1vault_authority_seeds() -> (
    Vec<Vec<u8>>,
    anchor_lang::prelude::Pubkey,
) {
    let mut seed_values = Vec::with_capacity(1usize + 1);
    seed_values.push((AUTH_SEED.as_bytes()).to_vec());
    let seed_slices: Vec<&[u8]> = seed_values.iter().map(|v| v.as_slice()).collect();
    let (pda, bump) = anchor_lang::prelude::Pubkey::find_program_address(
        &seed_slices,
        &crate::ID,
    );
    seed_values.push(<[_]>::into_vec(::alloc::boxed::box_new([bump])));
    (seed_values, pda)
}
/// Auto-generated CTokenSeedProvider implementation using positional indices
impl ctoken_seed_system::CTokenSeedProvider for CTokenAccountVariant {
    fn get_seeds<'info>(
        &self,
        remaining_accounts: &[anchor_lang::prelude::AccountInfo<'info>],
        seed_indices: &[u8],
        seed_accounts_offset: u8,
    ) -> (Vec<Vec<u8>>, anchor_lang::prelude::Pubkey) {
        match self {
            CTokenAccountVariant::LpVault => {
                let seeds: &[&[u8]] = &[
                    POOL_VAULT_SEED.as_bytes(),
                    remaining_accounts[(seed_accounts_offset + seed_indices[0]) as usize]
                        .key
                        .as_ref(),
                ];
                let (token_account_pda, bump) = anchor_lang::prelude::Pubkey::find_program_address(
                    seeds,
                    &crate::ID,
                );
                let mut seeds_vec = Vec::with_capacity(seeds.len() + 1);
                seeds_vec.extend(seeds.iter().map(|s| s.to_vec()));
                seeds_vec.push(<[_]>::into_vec(::alloc::boxed::box_new([bump])));
                (seeds_vec, token_account_pda)
            }
            CTokenAccountVariant::Token0Vault => {
                let seeds: &[&[u8]] = &[
                    POOL_VAULT_SEED.as_bytes(),
                    remaining_accounts[(seed_accounts_offset + seed_indices[0]) as usize]
                        .key
                        .as_ref(),
                    remaining_accounts[(seed_accounts_offset + seed_indices[1]) as usize]
                        .key
                        .as_ref(),
                ];
                let (token_account_pda, bump) = anchor_lang::prelude::Pubkey::find_program_address(
                    seeds,
                    &crate::ID,
                );
                let mut seeds_vec = Vec::with_capacity(seeds.len() + 1);
                seeds_vec.extend(seeds.iter().map(|s| s.to_vec()));
                seeds_vec.push(<[_]>::into_vec(::alloc::boxed::box_new([bump])));
                (seeds_vec, token_account_pda)
            }
            CTokenAccountVariant::Token1Vault => {
                let seeds: &[&[u8]] = &[
                    POOL_VAULT_SEED.as_bytes(),
                    remaining_accounts[(seed_accounts_offset + seed_indices[0]) as usize]
                        .key
                        .as_ref(),
                    remaining_accounts[(seed_accounts_offset + seed_indices[1]) as usize]
                        .key
                        .as_ref(),
                ];
                let (token_account_pda, bump) = anchor_lang::prelude::Pubkey::find_program_address(
                    seeds,
                    &crate::ID,
                );
                let mut seeds_vec = Vec::with_capacity(seeds.len() + 1);
                seeds_vec.extend(seeds.iter().map(|s| s.to_vec()));
                seeds_vec.push(<[_]>::into_vec(::alloc::boxed::box_new([bump])));
                (seeds_vec, token_account_pda)
            }
            _ => {
                ::core::panicking::panic_fmt(
                    format_args!(
                        "internal error: entered unreachable code: {0}",
                        format_args!("CToken variant not configured with seeds"),
                    ),
                );
            }
        }
    }
    fn get_authority_seeds<'info>(
        &self,
        remaining_accounts: &[anchor_lang::prelude::AccountInfo<'info>],
        authority_indices: &[u8],
        seed_accounts_offset: u8,
    ) -> (Vec<Vec<u8>>, anchor_lang::prelude::Pubkey) {
        match self {
            CTokenAccountVariant::LpVault => {
                let seeds: &[&[u8]] = &[AUTH_SEED.as_bytes()];
                let (authority_pda, bump) = anchor_lang::prelude::Pubkey::find_program_address(
                    seeds,
                    &crate::ID,
                );
                let mut seeds_vec = Vec::with_capacity(seeds.len() + 1);
                seeds_vec.extend(seeds.iter().map(|s| s.to_vec()));
                seeds_vec.push(<[_]>::into_vec(::alloc::boxed::box_new([bump])));
                (seeds_vec, authority_pda)
            }
            CTokenAccountVariant::Token0Vault => {
                let seeds: &[&[u8]] = &[AUTH_SEED.as_bytes()];
                let (authority_pda, bump) = anchor_lang::prelude::Pubkey::find_program_address(
                    seeds,
                    &crate::ID,
                );
                let mut seeds_vec = Vec::with_capacity(seeds.len() + 1);
                seeds_vec.extend(seeds.iter().map(|s| s.to_vec()));
                seeds_vec.push(<[_]>::into_vec(::alloc::boxed::box_new([bump])));
                (seeds_vec, authority_pda)
            }
            CTokenAccountVariant::Token1Vault => {
                let seeds: &[&[u8]] = &[AUTH_SEED.as_bytes()];
                let (authority_pda, bump) = anchor_lang::prelude::Pubkey::find_program_address(
                    seeds,
                    &crate::ID,
                );
                let mut seeds_vec = Vec::with_capacity(seeds.len() + 1);
                seeds_vec.extend(seeds.iter().map(|s| s.to_vec()));
                seeds_vec.push(<[_]>::into_vec(::alloc::boxed::box_new([bump])));
                (seeds_vec, authority_pda)
            }
            _ => {
                ::core::panicking::panic_fmt(
                    format_args!(
                        "internal error: entered unreachable code: {0}",
                        format_args!(
                            "CToken variant not configured with authority seeds",
                        ),
                    ),
                );
            }
        }
    }
}
use self::raydium_cp_swap::*;
/// # Safety
#[no_mangle]
pub unsafe extern "C" fn entrypoint(input: *mut u8) -> u64 {
    let (program_id, accounts, instruction_data) = unsafe {
        ::solana_program_entrypoint::deserialize(input)
    };
    match entry(program_id, &accounts, instruction_data) {
        Ok(()) => ::solana_program_entrypoint::SUCCESS,
        Err(error) => error.into(),
    }
}
/// The Anchor codegen exposes a programming model where a user defines
/// a set of methods inside of a `#[program]` module in a way similar
/// to writing RPC request handlers. The macro then generates a bunch of
/// code wrapping these user defined methods into something that can be
/// executed on Solana.
///
/// These methods fall into one category for now.
///
/// Global methods - regular methods inside of the `#[program]`.
///
/// Care must be taken by the codegen to prevent collisions between
/// methods in these different namespaces. For this reason, Anchor uses
/// a variant of sighash to perform method dispatch, rather than
/// something like a simple enum variant discriminator.
///
/// The execution flow of the generated code can be roughly outlined:
///
/// * Start program via the entrypoint.
/// * Check whether the declared program id matches the input program
///   id. If it's not, return an error.
/// * Find and invoke the method based on whether the instruction data
///   starts with the method's discriminator.
/// * Run the method handler wrapper. This wraps the code the user
///   actually wrote, deserializing the accounts, constructing the
///   context, invoking the user's code, and finally running the exit
///   routine, which typically persists account changes.
///
/// The `entry` function here, defines the standard entry to a Solana
/// program, where execution begins.
pub fn entry<'info>(
    program_id: &Pubkey,
    accounts: &'info [AccountInfo<'info>],
    data: &[u8],
) -> anchor_lang::solana_program::entrypoint::ProgramResult {
    try_entry(program_id, accounts, data)
        .map_err(|e| {
            e.log();
            e.into()
        })
}
fn try_entry<'info>(
    program_id: &Pubkey,
    accounts: &'info [AccountInfo<'info>],
    data: &[u8],
) -> anchor_lang::Result<()> {
    if *program_id != ID {
        return Err(anchor_lang::error::ErrorCode::DeclaredProgramIdMismatch.into());
    }
    dispatch(program_id, accounts, data)
}
/// Module representing the program.
pub mod program {
    use super::*;
    /// Type representing the program.
    pub struct RaydiumCpSwap;
    #[automatically_derived]
    impl ::core::clone::Clone for RaydiumCpSwap {
        #[inline]
        fn clone(&self) -> RaydiumCpSwap {
            RaydiumCpSwap
        }
    }
    impl anchor_lang::Id for RaydiumCpSwap {
        fn id() -> Pubkey {
            ID
        }
    }
}
/// Performs method dispatch.
///
/// Each instruction's discriminator is checked until the given instruction data starts with
/// the current discriminator.
///
/// If a match is found, the instruction handler is called using the given instruction data
/// excluding the prepended discriminator bytes.
///
/// If no match is found, the fallback function is executed if it exists, or an error is
/// returned if it doesn't exist.
fn dispatch<'info>(
    program_id: &Pubkey,
    accounts: &'info [AccountInfo<'info>],
    data: &[u8],
) -> anchor_lang::Result<()> {
    if data.starts_with(instruction::CreateAmmConfig::DISCRIMINATOR) {
        return __private::__global::create_amm_config(
            program_id,
            accounts,
            &data[instruction::CreateAmmConfig::DISCRIMINATOR.len()..],
        );
    }
    if data.starts_with(instruction::UpdateAmmConfig::DISCRIMINATOR) {
        return __private::__global::update_amm_config(
            program_id,
            accounts,
            &data[instruction::UpdateAmmConfig::DISCRIMINATOR.len()..],
        );
    }
    if data.starts_with(instruction::UpdatePoolStatus::DISCRIMINATOR) {
        return __private::__global::update_pool_status(
            program_id,
            accounts,
            &data[instruction::UpdatePoolStatus::DISCRIMINATOR.len()..],
        );
    }
    if data.starts_with(instruction::CollectProtocolFee::DISCRIMINATOR) {
        return __private::__global::collect_protocol_fee(
            program_id,
            accounts,
            &data[instruction::CollectProtocolFee::DISCRIMINATOR.len()..],
        );
    }
    if data.starts_with(instruction::CollectFundFee::DISCRIMINATOR) {
        return __private::__global::collect_fund_fee(
            program_id,
            accounts,
            &data[instruction::CollectFundFee::DISCRIMINATOR.len()..],
        );
    }
    if data.starts_with(instruction::Initialize::DISCRIMINATOR) {
        return __private::__global::initialize(
            program_id,
            accounts,
            &data[instruction::Initialize::DISCRIMINATOR.len()..],
        );
    }
    if data.starts_with(instruction::Deposit::DISCRIMINATOR) {
        return __private::__global::deposit(
            program_id,
            accounts,
            &data[instruction::Deposit::DISCRIMINATOR.len()..],
        );
    }
    if data.starts_with(instruction::Withdraw::DISCRIMINATOR) {
        return __private::__global::withdraw(
            program_id,
            accounts,
            &data[instruction::Withdraw::DISCRIMINATOR.len()..],
        );
    }
    if data.starts_with(instruction::SwapBaseInput::DISCRIMINATOR) {
        return __private::__global::swap_base_input(
            program_id,
            accounts,
            &data[instruction::SwapBaseInput::DISCRIMINATOR.len()..],
        );
    }
    if data.starts_with(instruction::SwapBaseOutput::DISCRIMINATOR) {
        return __private::__global::swap_base_output(
            program_id,
            accounts,
            &data[instruction::SwapBaseOutput::DISCRIMINATOR.len()..],
        );
    }
    if data.starts_with(instruction::DecompressAccountsIdempotent::DISCRIMINATOR) {
        return __private::__global::decompress_accounts_idempotent(
            program_id,
            accounts,
            &data[instruction::DecompressAccountsIdempotent::DISCRIMINATOR.len()..],
        );
    }
    if data.starts_with(instruction::CompressAccountsIdempotent::DISCRIMINATOR) {
        return __private::__global::compress_accounts_idempotent(
            program_id,
            accounts,
            &data[instruction::CompressAccountsIdempotent::DISCRIMINATOR.len()..],
        );
    }
    if data.starts_with(instruction::InitializeCompressionConfig::DISCRIMINATOR) {
        return __private::__global::initialize_compression_config(
            program_id,
            accounts,
            &data[instruction::InitializeCompressionConfig::DISCRIMINATOR.len()..],
        );
    }
    if data.starts_with(instruction::UpdateCompressionConfig::DISCRIMINATOR) {
        return __private::__global::update_compression_config(
            program_id,
            accounts,
            &data[instruction::UpdateCompressionConfig::DISCRIMINATOR.len()..],
        );
    }
    if data.starts_with(anchor_lang::idl::IDL_IX_TAG_LE) {
        return __private::__idl::__idl_dispatch(
            program_id,
            accounts,
            &data[anchor_lang::idl::IDL_IX_TAG_LE.len()..],
        );
    }
    if data.starts_with(anchor_lang::event::EVENT_IX_TAG_LE) {
        return Err(anchor_lang::error::ErrorCode::EventInstructionStub.into());
    }
    Err(anchor_lang::error::ErrorCode::InstructionFallbackNotFound.into())
}
/// Create a private module to not clutter the program's namespace.
/// Defines an entrypoint for each individual instruction handler
/// wrapper.
mod __private {
    use super::*;
    /// __idl mod defines handlers for injected Anchor IDL instructions.
    pub mod __idl {
        use super::*;
        #[inline(never)]
        pub fn __idl_dispatch<'info>(
            program_id: &Pubkey,
            accounts: &'info [AccountInfo<'info>],
            idl_ix_data: &[u8],
        ) -> anchor_lang::Result<()> {
            let mut accounts = accounts;
            let mut data: &[u8] = idl_ix_data;
            let ix = anchor_lang::idl::IdlInstruction::deserialize(&mut data)
                .map_err(|_| {
                    anchor_lang::error::ErrorCode::InstructionDidNotDeserialize
                })?;
            match ix {
                anchor_lang::idl::IdlInstruction::Create { data_len } => {
                    let mut bumps = <IdlCreateAccounts as anchor_lang::Bumps>::Bumps::default();
                    let mut reallocs = std::collections::BTreeSet::new();
                    let mut accounts = IdlCreateAccounts::try_accounts(
                        program_id,
                        &mut accounts,
                        &[],
                        &mut bumps,
                        &mut reallocs,
                    )?;
                    __idl_create_account(program_id, &mut accounts, data_len)?;
                    accounts.exit(program_id)?;
                }
                anchor_lang::idl::IdlInstruction::Resize { data_len } => {
                    let mut bumps = <IdlResizeAccount as anchor_lang::Bumps>::Bumps::default();
                    let mut reallocs = std::collections::BTreeSet::new();
                    let mut accounts = IdlResizeAccount::try_accounts(
                        program_id,
                        &mut accounts,
                        &[],
                        &mut bumps,
                        &mut reallocs,
                    )?;
                    __idl_resize_account(program_id, &mut accounts, data_len)?;
                    accounts.exit(program_id)?;
                }
                anchor_lang::idl::IdlInstruction::Close => {
                    let mut bumps = <IdlCloseAccount as anchor_lang::Bumps>::Bumps::default();
                    let mut reallocs = std::collections::BTreeSet::new();
                    let mut accounts = IdlCloseAccount::try_accounts(
                        program_id,
                        &mut accounts,
                        &[],
                        &mut bumps,
                        &mut reallocs,
                    )?;
                    __idl_close_account(program_id, &mut accounts)?;
                    accounts.exit(program_id)?;
                }
                anchor_lang::idl::IdlInstruction::CreateBuffer => {
                    let mut bumps = <IdlCreateBuffer as anchor_lang::Bumps>::Bumps::default();
                    let mut reallocs = std::collections::BTreeSet::new();
                    let mut accounts = IdlCreateBuffer::try_accounts(
                        program_id,
                        &mut accounts,
                        &[],
                        &mut bumps,
                        &mut reallocs,
                    )?;
                    __idl_create_buffer(program_id, &mut accounts)?;
                    accounts.exit(program_id)?;
                }
                anchor_lang::idl::IdlInstruction::Write { data } => {
                    let mut bumps = <IdlAccounts as anchor_lang::Bumps>::Bumps::default();
                    let mut reallocs = std::collections::BTreeSet::new();
                    let mut accounts = IdlAccounts::try_accounts(
                        program_id,
                        &mut accounts,
                        &[],
                        &mut bumps,
                        &mut reallocs,
                    )?;
                    __idl_write(program_id, &mut accounts, data)?;
                    accounts.exit(program_id)?;
                }
                anchor_lang::idl::IdlInstruction::SetAuthority { new_authority } => {
                    let mut bumps = <IdlAccounts as anchor_lang::Bumps>::Bumps::default();
                    let mut reallocs = std::collections::BTreeSet::new();
                    let mut accounts = IdlAccounts::try_accounts(
                        program_id,
                        &mut accounts,
                        &[],
                        &mut bumps,
                        &mut reallocs,
                    )?;
                    __idl_set_authority(program_id, &mut accounts, new_authority)?;
                    accounts.exit(program_id)?;
                }
                anchor_lang::idl::IdlInstruction::SetBuffer => {
                    let mut bumps = <IdlSetBuffer as anchor_lang::Bumps>::Bumps::default();
                    let mut reallocs = std::collections::BTreeSet::new();
                    let mut accounts = IdlSetBuffer::try_accounts(
                        program_id,
                        &mut accounts,
                        &[],
                        &mut bumps,
                        &mut reallocs,
                    )?;
                    __idl_set_buffer(program_id, &mut accounts)?;
                    accounts.exit(program_id)?;
                }
            }
            Ok(())
        }
        use anchor_lang::idl::ERASED_AUTHORITY;
        pub struct IdlAccount {
            pub authority: Pubkey,
            pub data_len: u32,
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for IdlAccount {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field2_finish(
                    f,
                    "IdlAccount",
                    "authority",
                    &self.authority,
                    "data_len",
                    &&self.data_len,
                )
            }
        }
        impl borsh::ser::BorshSerialize for IdlAccount
        where
            Pubkey: borsh::ser::BorshSerialize,
            u32: borsh::ser::BorshSerialize,
        {
            fn serialize<W: borsh::maybestd::io::Write>(
                &self,
                writer: &mut W,
            ) -> ::core::result::Result<(), borsh::maybestd::io::Error> {
                borsh::BorshSerialize::serialize(&self.authority, writer)?;
                borsh::BorshSerialize::serialize(&self.data_len, writer)?;
                Ok(())
            }
        }
        impl anchor_lang::idl::build::IdlBuild for IdlAccount {
            fn create_type() -> Option<anchor_lang::idl::types::IdlTypeDef> {
                Some(anchor_lang::idl::types::IdlTypeDef {
                    name: Self::get_full_path(),
                    docs: ::alloc::vec::Vec::new(),
                    serialization: anchor_lang::idl::types::IdlSerialization::default(),
                    repr: None,
                    generics: ::alloc::vec::Vec::new(),
                    ty: anchor_lang::idl::types::IdlTypeDefTy::Struct {
                        fields: Some(
                            anchor_lang::idl::types::IdlDefinedFields::Named(
                                <[_]>::into_vec(
                                    ::alloc::boxed::box_new([
                                        anchor_lang::idl::types::IdlField {
                                            name: "authority".into(),
                                            docs: ::alloc::vec::Vec::new(),
                                            ty: anchor_lang::idl::types::IdlType::Pubkey,
                                        },
                                        anchor_lang::idl::types::IdlField {
                                            name: "data_len".into(),
                                            docs: ::alloc::vec::Vec::new(),
                                            ty: anchor_lang::idl::types::IdlType::U32,
                                        },
                                    ]),
                                ),
                            ),
                        ),
                    },
                })
            }
            fn insert_types(
                types: &mut std::collections::BTreeMap<
                    String,
                    anchor_lang::idl::types::IdlTypeDef,
                >,
            ) {}
            fn get_full_path() -> String {
                ::alloc::__export::must_use({
                    ::alloc::fmt::format(
                        format_args!(
                            "{0}::{1}",
                            "raydium_cp_swap::__private::__idl",
                            "IdlAccount",
                        ),
                    )
                })
            }
        }
        impl borsh::de::BorshDeserialize for IdlAccount
        where
            Pubkey: borsh::BorshDeserialize,
            u32: borsh::BorshDeserialize,
        {
            fn deserialize_reader<R: borsh::maybestd::io::Read>(
                reader: &mut R,
            ) -> ::core::result::Result<Self, borsh::maybestd::io::Error> {
                Ok(Self {
                    authority: borsh::BorshDeserialize::deserialize_reader(reader)?,
                    data_len: borsh::BorshDeserialize::deserialize_reader(reader)?,
                })
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for IdlAccount {
            #[inline]
            fn clone(&self) -> IdlAccount {
                IdlAccount {
                    authority: ::core::clone::Clone::clone(&self.authority),
                    data_len: ::core::clone::Clone::clone(&self.data_len),
                }
            }
        }
        #[automatically_derived]
        impl anchor_lang::AccountSerialize for IdlAccount {
            fn try_serialize<W: std::io::Write>(
                &self,
                writer: &mut W,
            ) -> anchor_lang::Result<()> {
                if writer.write_all(IdlAccount::DISCRIMINATOR).is_err() {
                    return Err(
                        anchor_lang::error::ErrorCode::AccountDidNotSerialize.into(),
                    );
                }
                if AnchorSerialize::serialize(self, writer).is_err() {
                    return Err(
                        anchor_lang::error::ErrorCode::AccountDidNotSerialize.into(),
                    );
                }
                Ok(())
            }
        }
        #[automatically_derived]
        impl anchor_lang::AccountDeserialize for IdlAccount {
            fn try_deserialize(buf: &mut &[u8]) -> anchor_lang::Result<Self> {
                if buf.len() < IdlAccount::DISCRIMINATOR.len() {
                    return Err(
                        anchor_lang::error::ErrorCode::AccountDiscriminatorNotFound
                            .into(),
                    );
                }
                let given_disc = &buf[..IdlAccount::DISCRIMINATOR.len()];
                if IdlAccount::DISCRIMINATOR != given_disc {
                    return Err(
                        anchor_lang::error::Error::from(anchor_lang::error::AnchorError {
                                error_name: anchor_lang::error::ErrorCode::AccountDiscriminatorMismatch
                                    .name(),
                                error_code_number: anchor_lang::error::ErrorCode::AccountDiscriminatorMismatch
                                    .into(),
                                error_msg: anchor_lang::error::ErrorCode::AccountDiscriminatorMismatch
                                    .to_string(),
                                error_origin: Some(
                                    anchor_lang::error::ErrorOrigin::Source(anchor_lang::error::Source {
                                        filename: "programs/cp-swap/src/lib.rs",
                                        line: 67u32,
                                    }),
                                ),
                                compared_values: None,
                            })
                            .with_account_name("IdlAccount"),
                    );
                }
                Self::try_deserialize_unchecked(buf)
            }
            fn try_deserialize_unchecked(buf: &mut &[u8]) -> anchor_lang::Result<Self> {
                let mut data: &[u8] = &buf[IdlAccount::DISCRIMINATOR.len()..];
                AnchorDeserialize::deserialize(&mut data)
                    .map_err(|_| {
                        anchor_lang::error::ErrorCode::AccountDidNotDeserialize.into()
                    })
            }
        }
        #[automatically_derived]
        impl anchor_lang::Discriminator for IdlAccount {
            const DISCRIMINATOR: &'static [u8] = &[24, 70, 98, 191, 58, 144, 123, 158];
        }
        impl IdlAccount {
            pub fn address(program_id: &Pubkey) -> Pubkey {
                let program_signer = Pubkey::find_program_address(&[], program_id).0;
                Pubkey::create_with_seed(&program_signer, IdlAccount::seed(), program_id)
                    .expect("Seed is always valid")
            }
            pub fn seed() -> &'static str {
                "anchor:idl"
            }
        }
        impl anchor_lang::Owner for IdlAccount {
            fn owner() -> Pubkey {
                crate::ID
            }
        }
        pub struct IdlCreateAccounts<'info> {
            #[account(signer)]
            pub from: AccountInfo<'info>,
            #[account(mut)]
            pub to: AccountInfo<'info>,
            #[account(seeds = [], bump)]
            pub base: AccountInfo<'info>,
            pub system_program: Program<'info, System>,
            #[account(executable)]
            pub program: AccountInfo<'info>,
        }
        #[automatically_derived]
        impl<'info> anchor_lang::Accounts<'info, IdlCreateAccountsBumps>
        for IdlCreateAccounts<'info>
        where
            'info: 'info,
        {
            #[inline(never)]
            fn try_accounts(
                __program_id: &anchor_lang::solana_program::pubkey::Pubkey,
                __accounts: &mut &'info [anchor_lang::solana_program::account_info::AccountInfo<
                    'info,
                >],
                __ix_data: &[u8],
                __bumps: &mut IdlCreateAccountsBumps,
                __reallocs: &mut std::collections::BTreeSet<
                    anchor_lang::solana_program::pubkey::Pubkey,
                >,
            ) -> anchor_lang::Result<Self> {
                let from: AccountInfo = anchor_lang::Accounts::try_accounts(
                        __program_id,
                        __accounts,
                        __ix_data,
                        __bumps,
                        __reallocs,
                    )
                    .map_err(|e| e.with_account_name("from"))?;
                let to: AccountInfo = anchor_lang::Accounts::try_accounts(
                        __program_id,
                        __accounts,
                        __ix_data,
                        __bumps,
                        __reallocs,
                    )
                    .map_err(|e| e.with_account_name("to"))?;
                let base: AccountInfo = anchor_lang::Accounts::try_accounts(
                        __program_id,
                        __accounts,
                        __ix_data,
                        __bumps,
                        __reallocs,
                    )
                    .map_err(|e| e.with_account_name("base"))?;
                let system_program: anchor_lang::accounts::program::Program<System> = anchor_lang::Accounts::try_accounts(
                        __program_id,
                        __accounts,
                        __ix_data,
                        __bumps,
                        __reallocs,
                    )
                    .map_err(|e| e.with_account_name("system_program"))?;
                let program: AccountInfo = anchor_lang::Accounts::try_accounts(
                        __program_id,
                        __accounts,
                        __ix_data,
                        __bumps,
                        __reallocs,
                    )
                    .map_err(|e| e.with_account_name("program"))?;
                if !&from.is_signer {
                    return Err(
                        anchor_lang::error::Error::from(
                                anchor_lang::error::ErrorCode::ConstraintSigner,
                            )
                            .with_account_name("from"),
                    );
                }
                if !&to.is_writable {
                    return Err(
                        anchor_lang::error::Error::from(
                                anchor_lang::error::ErrorCode::ConstraintMut,
                            )
                            .with_account_name("to"),
                    );
                }
                let (__pda_address, __bump) = Pubkey::find_program_address(
                    &[],
                    &__program_id,
                );
                __bumps.base = __bump;
                if base.key() != __pda_address {
                    return Err(
                        anchor_lang::error::Error::from(
                                anchor_lang::error::ErrorCode::ConstraintSeeds,
                            )
                            .with_account_name("base")
                            .with_pubkeys((base.key(), __pda_address)),
                    );
                }
                if !&program.executable {
                    return Err(
                        anchor_lang::error::Error::from(
                                anchor_lang::error::ErrorCode::ConstraintExecutable,
                            )
                            .with_account_name("program"),
                    );
                }
                Ok(IdlCreateAccounts {
                    from,
                    to,
                    base,
                    system_program,
                    program,
                })
            }
        }
        #[automatically_derived]
        impl<'info> anchor_lang::ToAccountInfos<'info> for IdlCreateAccounts<'info>
        where
            'info: 'info,
        {
            fn to_account_infos(
                &self,
            ) -> Vec<anchor_lang::solana_program::account_info::AccountInfo<'info>> {
                let mut account_infos = ::alloc::vec::Vec::new();
                account_infos.extend(self.from.to_account_infos());
                account_infos.extend(self.to.to_account_infos());
                account_infos.extend(self.base.to_account_infos());
                account_infos.extend(self.system_program.to_account_infos());
                account_infos.extend(self.program.to_account_infos());
                account_infos
            }
        }
        #[automatically_derived]
        impl<'info> anchor_lang::ToAccountMetas for IdlCreateAccounts<'info> {
            fn to_account_metas(
                &self,
                is_signer: Option<bool>,
            ) -> Vec<anchor_lang::solana_program::instruction::AccountMeta> {
                let mut account_metas = ::alloc::vec::Vec::new();
                account_metas.extend(self.from.to_account_metas(Some(true)));
                account_metas.extend(self.to.to_account_metas(None));
                account_metas.extend(self.base.to_account_metas(None));
                account_metas.extend(self.system_program.to_account_metas(None));
                account_metas.extend(self.program.to_account_metas(None));
                account_metas
            }
        }
        #[automatically_derived]
        impl<'info> anchor_lang::AccountsFinalize<'info, IdlCreateAccountsBumps>
        for IdlCreateAccounts<'info>
        where
            'info: 'info,
        {
            fn finalize(
                &mut self,
                program_id: &anchor_lang::solana_program::pubkey::Pubkey,
                _remaining: &[anchor_lang::solana_program::account_info::AccountInfo<
                    'info,
                >],
                _ix_data: &[u8],
                _bumps: &IdlCreateAccountsBumps,
            ) -> anchor_lang::Result<()> {
                anchor_lang::AccountsFinalize::finalize(
                        &mut self.system_program,
                        program_id,
                        _remaining,
                        _ix_data,
                        _bumps,
                    )
                    .map_err(|e| e.with_account_name("system_program"))?;
                Ok(())
            }
        }
        #[automatically_derived]
        impl<'info> anchor_lang::AccountsExit<'info> for IdlCreateAccounts<'info>
        where
            'info: 'info,
        {
            fn exit(
                &self,
                program_id: &anchor_lang::solana_program::pubkey::Pubkey,
            ) -> anchor_lang::Result<()> {
                anchor_lang::AccountsExit::exit(&self.to, program_id)
                    .map_err(|e| e.with_account_name("to"))?;
                Ok(())
            }
        }
        pub struct IdlCreateAccountsBumps {
            pub base: u8,
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for IdlCreateAccountsBumps {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field1_finish(
                    f,
                    "IdlCreateAccountsBumps",
                    "base",
                    &&self.base,
                )
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for IdlCreateAccountsBumps {
            #[inline]
            fn clone(&self) -> IdlCreateAccountsBumps {
                IdlCreateAccountsBumps {
                    base: ::core::clone::Clone::clone(&self.base),
                }
            }
        }
        impl Default for IdlCreateAccountsBumps {
            fn default() -> Self {
                IdlCreateAccountsBumps {
                    base: u8::MAX,
                }
            }
        }
        impl<'info> anchor_lang::Bumps for IdlCreateAccounts<'info>
        where
            'info: 'info,
        {
            type Bumps = IdlCreateAccountsBumps;
        }
        /// An internal, Anchor generated module. This is used (as an
        /// implementation detail), to generate a struct for a given
        /// `#[derive(Accounts)]` implementation, where each field is a Pubkey,
        /// instead of an `AccountInfo`. This is useful for clients that want
        /// to generate a list of accounts, without explicitly knowing the
        /// order all the fields should be in.
        ///
        /// To access the struct in this module, one should use the sibling
        /// `accounts` module (also generated), which re-exports this.
        pub(crate) mod __client_accounts_idl_create_accounts {
            use super::*;
            use anchor_lang::prelude::borsh;
            /// Generated client accounts for [`IdlCreateAccounts`].
            pub struct IdlCreateAccounts {
                pub from: Pubkey,
                pub to: Pubkey,
                pub base: Pubkey,
                pub system_program: Pubkey,
                pub program: Pubkey,
            }
            impl borsh::ser::BorshSerialize for IdlCreateAccounts
            where
                Pubkey: borsh::ser::BorshSerialize,
                Pubkey: borsh::ser::BorshSerialize,
                Pubkey: borsh::ser::BorshSerialize,
                Pubkey: borsh::ser::BorshSerialize,
                Pubkey: borsh::ser::BorshSerialize,
            {
                fn serialize<W: borsh::maybestd::io::Write>(
                    &self,
                    writer: &mut W,
                ) -> ::core::result::Result<(), borsh::maybestd::io::Error> {
                    borsh::BorshSerialize::serialize(&self.from, writer)?;
                    borsh::BorshSerialize::serialize(&self.to, writer)?;
                    borsh::BorshSerialize::serialize(&self.base, writer)?;
                    borsh::BorshSerialize::serialize(&self.system_program, writer)?;
                    borsh::BorshSerialize::serialize(&self.program, writer)?;
                    Ok(())
                }
            }
            impl anchor_lang::idl::build::IdlBuild for IdlCreateAccounts {
                fn create_type() -> Option<anchor_lang::idl::types::IdlTypeDef> {
                    Some(anchor_lang::idl::types::IdlTypeDef {
                        name: Self::get_full_path(),
                        docs: <[_]>::into_vec(
                            ::alloc::boxed::box_new([
                                "Generated client accounts for [`IdlCreateAccounts`]."
                                    .into(),
                            ]),
                        ),
                        serialization: anchor_lang::idl::types::IdlSerialization::default(),
                        repr: None,
                        generics: ::alloc::vec::Vec::new(),
                        ty: anchor_lang::idl::types::IdlTypeDefTy::Struct {
                            fields: Some(
                                anchor_lang::idl::types::IdlDefinedFields::Named(
                                    <[_]>::into_vec(
                                        ::alloc::boxed::box_new([
                                            anchor_lang::idl::types::IdlField {
                                                name: "from".into(),
                                                docs: ::alloc::vec::Vec::new(),
                                                ty: anchor_lang::idl::types::IdlType::Pubkey,
                                            },
                                            anchor_lang::idl::types::IdlField {
                                                name: "to".into(),
                                                docs: ::alloc::vec::Vec::new(),
                                                ty: anchor_lang::idl::types::IdlType::Pubkey,
                                            },
                                            anchor_lang::idl::types::IdlField {
                                                name: "base".into(),
                                                docs: ::alloc::vec::Vec::new(),
                                                ty: anchor_lang::idl::types::IdlType::Pubkey,
                                            },
                                            anchor_lang::idl::types::IdlField {
                                                name: "system_program".into(),
                                                docs: ::alloc::vec::Vec::new(),
                                                ty: anchor_lang::idl::types::IdlType::Pubkey,
                                            },
                                            anchor_lang::idl::types::IdlField {
                                                name: "program".into(),
                                                docs: ::alloc::vec::Vec::new(),
                                                ty: anchor_lang::idl::types::IdlType::Pubkey,
                                            },
                                        ]),
                                    ),
                                ),
                            ),
                        },
                    })
                }
                fn insert_types(
                    types: &mut std::collections::BTreeMap<
                        String,
                        anchor_lang::idl::types::IdlTypeDef,
                    >,
                ) {}
                fn get_full_path() -> String {
                    ::alloc::__export::must_use({
                        ::alloc::fmt::format(
                            format_args!(
                                "{0}::{1}",
                                "raydium_cp_swap::__private::__idl::__client_accounts_idl_create_accounts",
                                "IdlCreateAccounts",
                            ),
                        )
                    })
                }
            }
            #[automatically_derived]
            impl anchor_lang::ToAccountMetas for IdlCreateAccounts {
                fn to_account_metas(
                    &self,
                    is_signer: Option<bool>,
                ) -> Vec<anchor_lang::solana_program::instruction::AccountMeta> {
                    let mut account_metas = ::alloc::vec::Vec::new();
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                                self.from,
                                true,
                            ),
                        );
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new(
                                self.to,
                                false,
                            ),
                        );
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                                self.base,
                                false,
                            ),
                        );
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                                self.system_program,
                                false,
                            ),
                        );
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                                self.program,
                                false,
                            ),
                        );
                    account_metas
                }
            }
        }
        /// An internal, Anchor generated module. This is used (as an
        /// implementation detail), to generate a CPI struct for a given
        /// `#[derive(Accounts)]` implementation, where each field is an
        /// AccountInfo.
        ///
        /// To access the struct in this module, one should use the sibling
        /// [`cpi::accounts`] module (also generated), which re-exports this.
        pub(crate) mod __cpi_client_accounts_idl_create_accounts {
            use super::*;
            /// Generated CPI struct of the accounts for [`IdlCreateAccounts`].
            pub struct IdlCreateAccounts<'info> {
                pub from: anchor_lang::solana_program::account_info::AccountInfo<'info>,
                pub to: anchor_lang::solana_program::account_info::AccountInfo<'info>,
                pub base: anchor_lang::solana_program::account_info::AccountInfo<'info>,
                pub system_program: anchor_lang::solana_program::account_info::AccountInfo<
                    'info,
                >,
                pub program: anchor_lang::solana_program::account_info::AccountInfo<
                    'info,
                >,
            }
            #[automatically_derived]
            impl<'info> anchor_lang::ToAccountMetas for IdlCreateAccounts<'info> {
                fn to_account_metas(
                    &self,
                    is_signer: Option<bool>,
                ) -> Vec<anchor_lang::solana_program::instruction::AccountMeta> {
                    let mut account_metas = ::alloc::vec::Vec::new();
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                                anchor_lang::Key::key(&self.from),
                                true,
                            ),
                        );
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new(
                                anchor_lang::Key::key(&self.to),
                                false,
                            ),
                        );
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                                anchor_lang::Key::key(&self.base),
                                false,
                            ),
                        );
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                                anchor_lang::Key::key(&self.system_program),
                                false,
                            ),
                        );
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                                anchor_lang::Key::key(&self.program),
                                false,
                            ),
                        );
                    account_metas
                }
            }
            #[automatically_derived]
            impl<'info> anchor_lang::ToAccountInfos<'info> for IdlCreateAccounts<'info> {
                fn to_account_infos(
                    &self,
                ) -> Vec<anchor_lang::solana_program::account_info::AccountInfo<'info>> {
                    let mut account_infos = ::alloc::vec::Vec::new();
                    account_infos
                        .extend(
                            anchor_lang::ToAccountInfos::to_account_infos(&self.from),
                        );
                    account_infos
                        .extend(anchor_lang::ToAccountInfos::to_account_infos(&self.to));
                    account_infos
                        .extend(
                            anchor_lang::ToAccountInfos::to_account_infos(&self.base),
                        );
                    account_infos
                        .extend(
                            anchor_lang::ToAccountInfos::to_account_infos(
                                &self.system_program,
                            ),
                        );
                    account_infos
                        .extend(
                            anchor_lang::ToAccountInfos::to_account_infos(&self.program),
                        );
                    account_infos
                }
            }
        }
        impl<'info> IdlCreateAccounts<'info> {
            pub fn __anchor_private_gen_idl_accounts(
                accounts: &mut std::collections::BTreeMap<
                    String,
                    anchor_lang::idl::types::IdlAccount,
                >,
                types: &mut std::collections::BTreeMap<
                    String,
                    anchor_lang::idl::types::IdlTypeDef,
                >,
            ) -> Vec<anchor_lang::idl::types::IdlInstructionAccountItem> {
                <[_]>::into_vec(
                    ::alloc::boxed::box_new([
                        anchor_lang::idl::types::IdlInstructionAccountItem::Single(anchor_lang::idl::types::IdlInstructionAccount {
                            name: "from".into(),
                            docs: ::alloc::vec::Vec::new(),
                            writable: false,
                            signer: true,
                            optional: false,
                            address: None,
                            pda: None,
                            relations: ::alloc::vec::Vec::new(),
                        }),
                        anchor_lang::idl::types::IdlInstructionAccountItem::Single(anchor_lang::idl::types::IdlInstructionAccount {
                            name: "to".into(),
                            docs: ::alloc::vec::Vec::new(),
                            writable: true,
                            signer: false,
                            optional: false,
                            address: None,
                            pda: None,
                            relations: ::alloc::vec::Vec::new(),
                        }),
                        anchor_lang::idl::types::IdlInstructionAccountItem::Single(anchor_lang::idl::types::IdlInstructionAccount {
                            name: "base".into(),
                            docs: ::alloc::vec::Vec::new(),
                            writable: false,
                            signer: false,
                            optional: false,
                            address: None,
                            pda: None,
                            relations: ::alloc::vec::Vec::new(),
                        }),
                        anchor_lang::idl::types::IdlInstructionAccountItem::Single(anchor_lang::idl::types::IdlInstructionAccount {
                            name: "system_program".into(),
                            docs: ::alloc::vec::Vec::new(),
                            writable: false,
                            signer: false,
                            optional: false,
                            address: None,
                            pda: None,
                            relations: ::alloc::vec::Vec::new(),
                        }),
                        anchor_lang::idl::types::IdlInstructionAccountItem::Single(anchor_lang::idl::types::IdlInstructionAccount {
                            name: "program".into(),
                            docs: ::alloc::vec::Vec::new(),
                            writable: false,
                            signer: false,
                            optional: false,
                            address: None,
                            pda: None,
                            relations: ::alloc::vec::Vec::new(),
                        }),
                    ]),
                )
            }
            pub fn __anchor_private_gen_light_metadata() -> Option<
                anchor_lang::idl::types::IdlLightInstructionMeta,
            > {
                None
            }
        }
        pub struct IdlAccounts<'info> {
            #[account(mut, has_one = authority)]
            pub idl: Account<'info, IdlAccount>,
            #[account(constraint = authority.key!= &ERASED_AUTHORITY)]
            pub authority: Signer<'info>,
        }
        #[automatically_derived]
        impl<'info> anchor_lang::Accounts<'info, IdlAccountsBumps> for IdlAccounts<'info>
        where
            'info: 'info,
        {
            #[inline(never)]
            fn try_accounts(
                __program_id: &anchor_lang::solana_program::pubkey::Pubkey,
                __accounts: &mut &'info [anchor_lang::solana_program::account_info::AccountInfo<
                    'info,
                >],
                __ix_data: &[u8],
                __bumps: &mut IdlAccountsBumps,
                __reallocs: &mut std::collections::BTreeSet<
                    anchor_lang::solana_program::pubkey::Pubkey,
                >,
            ) -> anchor_lang::Result<Self> {
                let idl: anchor_lang::accounts::account::Account<IdlAccount> = anchor_lang::Accounts::try_accounts(
                        __program_id,
                        __accounts,
                        __ix_data,
                        __bumps,
                        __reallocs,
                    )
                    .map_err(|e| e.with_account_name("idl"))?;
                let authority: Signer = anchor_lang::Accounts::try_accounts(
                        __program_id,
                        __accounts,
                        __ix_data,
                        __bumps,
                        __reallocs,
                    )
                    .map_err(|e| e.with_account_name("authority"))?;
                if !AsRef::<AccountInfo>::as_ref(&idl).is_writable {
                    return Err(
                        anchor_lang::error::Error::from(
                                anchor_lang::error::ErrorCode::ConstraintMut,
                            )
                            .with_account_name("idl"),
                    );
                }
                {
                    let my_key = idl.authority;
                    let target_key = authority.key();
                    if my_key != target_key {
                        return Err(
                            anchor_lang::error::Error::from(
                                    anchor_lang::error::ErrorCode::ConstraintHasOne,
                                )
                                .with_account_name("idl")
                                .with_pubkeys((my_key, target_key)),
                        );
                    }
                }
                if !(authority.key != &ERASED_AUTHORITY) {
                    return Err(
                        anchor_lang::error::Error::from(
                                anchor_lang::error::ErrorCode::ConstraintRaw,
                            )
                            .with_account_name("authority"),
                    );
                }
                Ok(IdlAccounts { idl, authority })
            }
        }
        #[automatically_derived]
        impl<'info> anchor_lang::ToAccountInfos<'info> for IdlAccounts<'info>
        where
            'info: 'info,
        {
            fn to_account_infos(
                &self,
            ) -> Vec<anchor_lang::solana_program::account_info::AccountInfo<'info>> {
                let mut account_infos = ::alloc::vec::Vec::new();
                account_infos.extend(self.idl.to_account_infos());
                account_infos.extend(self.authority.to_account_infos());
                account_infos
            }
        }
        #[automatically_derived]
        impl<'info> anchor_lang::ToAccountMetas for IdlAccounts<'info> {
            fn to_account_metas(
                &self,
                is_signer: Option<bool>,
            ) -> Vec<anchor_lang::solana_program::instruction::AccountMeta> {
                let mut account_metas = ::alloc::vec::Vec::new();
                account_metas.extend(self.idl.to_account_metas(None));
                account_metas.extend(self.authority.to_account_metas(None));
                account_metas
            }
        }
        #[automatically_derived]
        impl<'info> anchor_lang::AccountsFinalize<'info, IdlAccountsBumps>
        for IdlAccounts<'info>
        where
            'info: 'info,
        {
            fn finalize(
                &mut self,
                program_id: &anchor_lang::solana_program::pubkey::Pubkey,
                _remaining: &[anchor_lang::solana_program::account_info::AccountInfo<
                    'info,
                >],
                _ix_data: &[u8],
                _bumps: &IdlAccountsBumps,
            ) -> anchor_lang::Result<()> {
                anchor_lang::AccountsFinalize::finalize(
                        &mut self.idl,
                        program_id,
                        _remaining,
                        _ix_data,
                        _bumps,
                    )
                    .map_err(|e| e.with_account_name("idl"))?;
                Ok(())
            }
        }
        #[automatically_derived]
        impl<'info> anchor_lang::AccountsExit<'info> for IdlAccounts<'info>
        where
            'info: 'info,
        {
            fn exit(
                &self,
                program_id: &anchor_lang::solana_program::pubkey::Pubkey,
            ) -> anchor_lang::Result<()> {
                anchor_lang::AccountsExit::exit(&self.idl, program_id)
                    .map_err(|e| e.with_account_name("idl"))?;
                Ok(())
            }
        }
        pub struct IdlAccountsBumps {}
        #[automatically_derived]
        impl ::core::fmt::Debug for IdlAccountsBumps {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::write_str(f, "IdlAccountsBumps")
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for IdlAccountsBumps {
            #[inline]
            fn clone(&self) -> IdlAccountsBumps {
                IdlAccountsBumps {}
            }
        }
        impl Default for IdlAccountsBumps {
            fn default() -> Self {
                IdlAccountsBumps {}
            }
        }
        impl<'info> anchor_lang::Bumps for IdlAccounts<'info>
        where
            'info: 'info,
        {
            type Bumps = IdlAccountsBumps;
        }
        /// An internal, Anchor generated module. This is used (as an
        /// implementation detail), to generate a struct for a given
        /// `#[derive(Accounts)]` implementation, where each field is a Pubkey,
        /// instead of an `AccountInfo`. This is useful for clients that want
        /// to generate a list of accounts, without explicitly knowing the
        /// order all the fields should be in.
        ///
        /// To access the struct in this module, one should use the sibling
        /// `accounts` module (also generated), which re-exports this.
        pub(crate) mod __client_accounts_idl_accounts {
            use super::*;
            use anchor_lang::prelude::borsh;
            /// Generated client accounts for [`IdlAccounts`].
            pub struct IdlAccounts {
                pub idl: Pubkey,
                pub authority: Pubkey,
            }
            impl borsh::ser::BorshSerialize for IdlAccounts
            where
                Pubkey: borsh::ser::BorshSerialize,
                Pubkey: borsh::ser::BorshSerialize,
            {
                fn serialize<W: borsh::maybestd::io::Write>(
                    &self,
                    writer: &mut W,
                ) -> ::core::result::Result<(), borsh::maybestd::io::Error> {
                    borsh::BorshSerialize::serialize(&self.idl, writer)?;
                    borsh::BorshSerialize::serialize(&self.authority, writer)?;
                    Ok(())
                }
            }
            impl anchor_lang::idl::build::IdlBuild for IdlAccounts {
                fn create_type() -> Option<anchor_lang::idl::types::IdlTypeDef> {
                    Some(anchor_lang::idl::types::IdlTypeDef {
                        name: Self::get_full_path(),
                        docs: <[_]>::into_vec(
                            ::alloc::boxed::box_new([
                                "Generated client accounts for [`IdlAccounts`].".into(),
                            ]),
                        ),
                        serialization: anchor_lang::idl::types::IdlSerialization::default(),
                        repr: None,
                        generics: ::alloc::vec::Vec::new(),
                        ty: anchor_lang::idl::types::IdlTypeDefTy::Struct {
                            fields: Some(
                                anchor_lang::idl::types::IdlDefinedFields::Named(
                                    <[_]>::into_vec(
                                        ::alloc::boxed::box_new([
                                            anchor_lang::idl::types::IdlField {
                                                name: "idl".into(),
                                                docs: ::alloc::vec::Vec::new(),
                                                ty: anchor_lang::idl::types::IdlType::Pubkey,
                                            },
                                            anchor_lang::idl::types::IdlField {
                                                name: "authority".into(),
                                                docs: ::alloc::vec::Vec::new(),
                                                ty: anchor_lang::idl::types::IdlType::Pubkey,
                                            },
                                        ]),
                                    ),
                                ),
                            ),
                        },
                    })
                }
                fn insert_types(
                    types: &mut std::collections::BTreeMap<
                        String,
                        anchor_lang::idl::types::IdlTypeDef,
                    >,
                ) {}
                fn get_full_path() -> String {
                    ::alloc::__export::must_use({
                        ::alloc::fmt::format(
                            format_args!(
                                "{0}::{1}",
                                "raydium_cp_swap::__private::__idl::__client_accounts_idl_accounts",
                                "IdlAccounts",
                            ),
                        )
                    })
                }
            }
            #[automatically_derived]
            impl anchor_lang::ToAccountMetas for IdlAccounts {
                fn to_account_metas(
                    &self,
                    is_signer: Option<bool>,
                ) -> Vec<anchor_lang::solana_program::instruction::AccountMeta> {
                    let mut account_metas = ::alloc::vec::Vec::new();
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new(
                                self.idl,
                                false,
                            ),
                        );
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                                self.authority,
                                true,
                            ),
                        );
                    account_metas
                }
            }
        }
        /// An internal, Anchor generated module. This is used (as an
        /// implementation detail), to generate a CPI struct for a given
        /// `#[derive(Accounts)]` implementation, where each field is an
        /// AccountInfo.
        ///
        /// To access the struct in this module, one should use the sibling
        /// [`cpi::accounts`] module (also generated), which re-exports this.
        pub(crate) mod __cpi_client_accounts_idl_accounts {
            use super::*;
            /// Generated CPI struct of the accounts for [`IdlAccounts`].
            pub struct IdlAccounts<'info> {
                pub idl: anchor_lang::solana_program::account_info::AccountInfo<'info>,
                pub authority: anchor_lang::solana_program::account_info::AccountInfo<
                    'info,
                >,
            }
            #[automatically_derived]
            impl<'info> anchor_lang::ToAccountMetas for IdlAccounts<'info> {
                fn to_account_metas(
                    &self,
                    is_signer: Option<bool>,
                ) -> Vec<anchor_lang::solana_program::instruction::AccountMeta> {
                    let mut account_metas = ::alloc::vec::Vec::new();
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new(
                                anchor_lang::Key::key(&self.idl),
                                false,
                            ),
                        );
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                                anchor_lang::Key::key(&self.authority),
                                true,
                            ),
                        );
                    account_metas
                }
            }
            #[automatically_derived]
            impl<'info> anchor_lang::ToAccountInfos<'info> for IdlAccounts<'info> {
                fn to_account_infos(
                    &self,
                ) -> Vec<anchor_lang::solana_program::account_info::AccountInfo<'info>> {
                    let mut account_infos = ::alloc::vec::Vec::new();
                    account_infos
                        .extend(
                            anchor_lang::ToAccountInfos::to_account_infos(&self.idl),
                        );
                    account_infos
                        .extend(
                            anchor_lang::ToAccountInfos::to_account_infos(
                                &self.authority,
                            ),
                        );
                    account_infos
                }
            }
        }
        impl<'info> IdlAccounts<'info> {
            pub fn __anchor_private_gen_idl_accounts(
                accounts: &mut std::collections::BTreeMap<
                    String,
                    anchor_lang::idl::types::IdlAccount,
                >,
                types: &mut std::collections::BTreeMap<
                    String,
                    anchor_lang::idl::types::IdlTypeDef,
                >,
            ) -> Vec<anchor_lang::idl::types::IdlInstructionAccountItem> {
                if let Some(ty) = <IdlAccount>::create_type() {
                    let account = anchor_lang::idl::types::IdlAccount {
                        name: ty.name.clone(),
                        discriminator: IdlAccount::DISCRIMINATOR.into(),
                    };
                    accounts.insert(account.name.clone(), account);
                    types.insert(ty.name.clone(), ty);
                    <IdlAccount>::insert_types(types);
                }
                <[_]>::into_vec(
                    ::alloc::boxed::box_new([
                        anchor_lang::idl::types::IdlInstructionAccountItem::Single(anchor_lang::idl::types::IdlInstructionAccount {
                            name: "idl".into(),
                            docs: ::alloc::vec::Vec::new(),
                            writable: true,
                            signer: false,
                            optional: false,
                            address: None,
                            pda: None,
                            relations: ::alloc::vec::Vec::new(),
                        }),
                        anchor_lang::idl::types::IdlInstructionAccountItem::Single(anchor_lang::idl::types::IdlInstructionAccount {
                            name: "authority".into(),
                            docs: ::alloc::vec::Vec::new(),
                            writable: false,
                            signer: true,
                            optional: false,
                            address: None,
                            pda: None,
                            relations: ::alloc::vec::Vec::new(),
                        }),
                    ]),
                )
            }
            pub fn __anchor_private_gen_light_metadata() -> Option<
                anchor_lang::idl::types::IdlLightInstructionMeta,
            > {
                None
            }
        }
        pub struct IdlResizeAccount<'info> {
            #[account(mut, has_one = authority)]
            pub idl: Account<'info, IdlAccount>,
            #[account(mut, constraint = authority.key!= &ERASED_AUTHORITY)]
            pub authority: Signer<'info>,
            pub system_program: Program<'info, System>,
        }
        #[automatically_derived]
        impl<'info> anchor_lang::Accounts<'info, IdlResizeAccountBumps>
        for IdlResizeAccount<'info>
        where
            'info: 'info,
        {
            #[inline(never)]
            fn try_accounts(
                __program_id: &anchor_lang::solana_program::pubkey::Pubkey,
                __accounts: &mut &'info [anchor_lang::solana_program::account_info::AccountInfo<
                    'info,
                >],
                __ix_data: &[u8],
                __bumps: &mut IdlResizeAccountBumps,
                __reallocs: &mut std::collections::BTreeSet<
                    anchor_lang::solana_program::pubkey::Pubkey,
                >,
            ) -> anchor_lang::Result<Self> {
                let idl: anchor_lang::accounts::account::Account<IdlAccount> = anchor_lang::Accounts::try_accounts(
                        __program_id,
                        __accounts,
                        __ix_data,
                        __bumps,
                        __reallocs,
                    )
                    .map_err(|e| e.with_account_name("idl"))?;
                let authority: Signer = anchor_lang::Accounts::try_accounts(
                        __program_id,
                        __accounts,
                        __ix_data,
                        __bumps,
                        __reallocs,
                    )
                    .map_err(|e| e.with_account_name("authority"))?;
                let system_program: anchor_lang::accounts::program::Program<System> = anchor_lang::Accounts::try_accounts(
                        __program_id,
                        __accounts,
                        __ix_data,
                        __bumps,
                        __reallocs,
                    )
                    .map_err(|e| e.with_account_name("system_program"))?;
                if !AsRef::<AccountInfo>::as_ref(&idl).is_writable {
                    return Err(
                        anchor_lang::error::Error::from(
                                anchor_lang::error::ErrorCode::ConstraintMut,
                            )
                            .with_account_name("idl"),
                    );
                }
                {
                    let my_key = idl.authority;
                    let target_key = authority.key();
                    if my_key != target_key {
                        return Err(
                            anchor_lang::error::Error::from(
                                    anchor_lang::error::ErrorCode::ConstraintHasOne,
                                )
                                .with_account_name("idl")
                                .with_pubkeys((my_key, target_key)),
                        );
                    }
                }
                if !AsRef::<AccountInfo>::as_ref(&authority).is_writable {
                    return Err(
                        anchor_lang::error::Error::from(
                                anchor_lang::error::ErrorCode::ConstraintMut,
                            )
                            .with_account_name("authority"),
                    );
                }
                if !(authority.key != &ERASED_AUTHORITY) {
                    return Err(
                        anchor_lang::error::Error::from(
                                anchor_lang::error::ErrorCode::ConstraintRaw,
                            )
                            .with_account_name("authority"),
                    );
                }
                Ok(IdlResizeAccount {
                    idl,
                    authority,
                    system_program,
                })
            }
        }
        #[automatically_derived]
        impl<'info> anchor_lang::ToAccountInfos<'info> for IdlResizeAccount<'info>
        where
            'info: 'info,
        {
            fn to_account_infos(
                &self,
            ) -> Vec<anchor_lang::solana_program::account_info::AccountInfo<'info>> {
                let mut account_infos = ::alloc::vec::Vec::new();
                account_infos.extend(self.idl.to_account_infos());
                account_infos.extend(self.authority.to_account_infos());
                account_infos.extend(self.system_program.to_account_infos());
                account_infos
            }
        }
        #[automatically_derived]
        impl<'info> anchor_lang::ToAccountMetas for IdlResizeAccount<'info> {
            fn to_account_metas(
                &self,
                is_signer: Option<bool>,
            ) -> Vec<anchor_lang::solana_program::instruction::AccountMeta> {
                let mut account_metas = ::alloc::vec::Vec::new();
                account_metas.extend(self.idl.to_account_metas(None));
                account_metas.extend(self.authority.to_account_metas(None));
                account_metas.extend(self.system_program.to_account_metas(None));
                account_metas
            }
        }
        #[automatically_derived]
        impl<'info> anchor_lang::AccountsFinalize<'info, IdlResizeAccountBumps>
        for IdlResizeAccount<'info>
        where
            'info: 'info,
        {
            fn finalize(
                &mut self,
                program_id: &anchor_lang::solana_program::pubkey::Pubkey,
                _remaining: &[anchor_lang::solana_program::account_info::AccountInfo<
                    'info,
                >],
                _ix_data: &[u8],
                _bumps: &IdlResizeAccountBumps,
            ) -> anchor_lang::Result<()> {
                anchor_lang::AccountsFinalize::finalize(
                        &mut self.idl,
                        program_id,
                        _remaining,
                        _ix_data,
                        _bumps,
                    )
                    .map_err(|e| e.with_account_name("idl"))?;
                anchor_lang::AccountsFinalize::finalize(
                        &mut self.system_program,
                        program_id,
                        _remaining,
                        _ix_data,
                        _bumps,
                    )
                    .map_err(|e| e.with_account_name("system_program"))?;
                Ok(())
            }
        }
        #[automatically_derived]
        impl<'info> anchor_lang::AccountsExit<'info> for IdlResizeAccount<'info>
        where
            'info: 'info,
        {
            fn exit(
                &self,
                program_id: &anchor_lang::solana_program::pubkey::Pubkey,
            ) -> anchor_lang::Result<()> {
                anchor_lang::AccountsExit::exit(&self.idl, program_id)
                    .map_err(|e| e.with_account_name("idl"))?;
                anchor_lang::AccountsExit::exit(&self.authority, program_id)
                    .map_err(|e| e.with_account_name("authority"))?;
                Ok(())
            }
        }
        pub struct IdlResizeAccountBumps {}
        #[automatically_derived]
        impl ::core::fmt::Debug for IdlResizeAccountBumps {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::write_str(f, "IdlResizeAccountBumps")
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for IdlResizeAccountBumps {
            #[inline]
            fn clone(&self) -> IdlResizeAccountBumps {
                IdlResizeAccountBumps {}
            }
        }
        impl Default for IdlResizeAccountBumps {
            fn default() -> Self {
                IdlResizeAccountBumps {}
            }
        }
        impl<'info> anchor_lang::Bumps for IdlResizeAccount<'info>
        where
            'info: 'info,
        {
            type Bumps = IdlResizeAccountBumps;
        }
        /// An internal, Anchor generated module. This is used (as an
        /// implementation detail), to generate a struct for a given
        /// `#[derive(Accounts)]` implementation, where each field is a Pubkey,
        /// instead of an `AccountInfo`. This is useful for clients that want
        /// to generate a list of accounts, without explicitly knowing the
        /// order all the fields should be in.
        ///
        /// To access the struct in this module, one should use the sibling
        /// `accounts` module (also generated), which re-exports this.
        pub(crate) mod __client_accounts_idl_resize_account {
            use super::*;
            use anchor_lang::prelude::borsh;
            /// Generated client accounts for [`IdlResizeAccount`].
            pub struct IdlResizeAccount {
                pub idl: Pubkey,
                pub authority: Pubkey,
                pub system_program: Pubkey,
            }
            impl borsh::ser::BorshSerialize for IdlResizeAccount
            where
                Pubkey: borsh::ser::BorshSerialize,
                Pubkey: borsh::ser::BorshSerialize,
                Pubkey: borsh::ser::BorshSerialize,
            {
                fn serialize<W: borsh::maybestd::io::Write>(
                    &self,
                    writer: &mut W,
                ) -> ::core::result::Result<(), borsh::maybestd::io::Error> {
                    borsh::BorshSerialize::serialize(&self.idl, writer)?;
                    borsh::BorshSerialize::serialize(&self.authority, writer)?;
                    borsh::BorshSerialize::serialize(&self.system_program, writer)?;
                    Ok(())
                }
            }
            impl anchor_lang::idl::build::IdlBuild for IdlResizeAccount {
                fn create_type() -> Option<anchor_lang::idl::types::IdlTypeDef> {
                    Some(anchor_lang::idl::types::IdlTypeDef {
                        name: Self::get_full_path(),
                        docs: <[_]>::into_vec(
                            ::alloc::boxed::box_new([
                                "Generated client accounts for [`IdlResizeAccount`].".into(),
                            ]),
                        ),
                        serialization: anchor_lang::idl::types::IdlSerialization::default(),
                        repr: None,
                        generics: ::alloc::vec::Vec::new(),
                        ty: anchor_lang::idl::types::IdlTypeDefTy::Struct {
                            fields: Some(
                                anchor_lang::idl::types::IdlDefinedFields::Named(
                                    <[_]>::into_vec(
                                        ::alloc::boxed::box_new([
                                            anchor_lang::idl::types::IdlField {
                                                name: "idl".into(),
                                                docs: ::alloc::vec::Vec::new(),
                                                ty: anchor_lang::idl::types::IdlType::Pubkey,
                                            },
                                            anchor_lang::idl::types::IdlField {
                                                name: "authority".into(),
                                                docs: ::alloc::vec::Vec::new(),
                                                ty: anchor_lang::idl::types::IdlType::Pubkey,
                                            },
                                            anchor_lang::idl::types::IdlField {
                                                name: "system_program".into(),
                                                docs: ::alloc::vec::Vec::new(),
                                                ty: anchor_lang::idl::types::IdlType::Pubkey,
                                            },
                                        ]),
                                    ),
                                ),
                            ),
                        },
                    })
                }
                fn insert_types(
                    types: &mut std::collections::BTreeMap<
                        String,
                        anchor_lang::idl::types::IdlTypeDef,
                    >,
                ) {}
                fn get_full_path() -> String {
                    ::alloc::__export::must_use({
                        ::alloc::fmt::format(
                            format_args!(
                                "{0}::{1}",
                                "raydium_cp_swap::__private::__idl::__client_accounts_idl_resize_account",
                                "IdlResizeAccount",
                            ),
                        )
                    })
                }
            }
            #[automatically_derived]
            impl anchor_lang::ToAccountMetas for IdlResizeAccount {
                fn to_account_metas(
                    &self,
                    is_signer: Option<bool>,
                ) -> Vec<anchor_lang::solana_program::instruction::AccountMeta> {
                    let mut account_metas = ::alloc::vec::Vec::new();
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new(
                                self.idl,
                                false,
                            ),
                        );
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new(
                                self.authority,
                                true,
                            ),
                        );
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                                self.system_program,
                                false,
                            ),
                        );
                    account_metas
                }
            }
        }
        /// An internal, Anchor generated module. This is used (as an
        /// implementation detail), to generate a CPI struct for a given
        /// `#[derive(Accounts)]` implementation, where each field is an
        /// AccountInfo.
        ///
        /// To access the struct in this module, one should use the sibling
        /// [`cpi::accounts`] module (also generated), which re-exports this.
        pub(crate) mod __cpi_client_accounts_idl_resize_account {
            use super::*;
            /// Generated CPI struct of the accounts for [`IdlResizeAccount`].
            pub struct IdlResizeAccount<'info> {
                pub idl: anchor_lang::solana_program::account_info::AccountInfo<'info>,
                pub authority: anchor_lang::solana_program::account_info::AccountInfo<
                    'info,
                >,
                pub system_program: anchor_lang::solana_program::account_info::AccountInfo<
                    'info,
                >,
            }
            #[automatically_derived]
            impl<'info> anchor_lang::ToAccountMetas for IdlResizeAccount<'info> {
                fn to_account_metas(
                    &self,
                    is_signer: Option<bool>,
                ) -> Vec<anchor_lang::solana_program::instruction::AccountMeta> {
                    let mut account_metas = ::alloc::vec::Vec::new();
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new(
                                anchor_lang::Key::key(&self.idl),
                                false,
                            ),
                        );
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new(
                                anchor_lang::Key::key(&self.authority),
                                true,
                            ),
                        );
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                                anchor_lang::Key::key(&self.system_program),
                                false,
                            ),
                        );
                    account_metas
                }
            }
            #[automatically_derived]
            impl<'info> anchor_lang::ToAccountInfos<'info> for IdlResizeAccount<'info> {
                fn to_account_infos(
                    &self,
                ) -> Vec<anchor_lang::solana_program::account_info::AccountInfo<'info>> {
                    let mut account_infos = ::alloc::vec::Vec::new();
                    account_infos
                        .extend(
                            anchor_lang::ToAccountInfos::to_account_infos(&self.idl),
                        );
                    account_infos
                        .extend(
                            anchor_lang::ToAccountInfos::to_account_infos(
                                &self.authority,
                            ),
                        );
                    account_infos
                        .extend(
                            anchor_lang::ToAccountInfos::to_account_infos(
                                &self.system_program,
                            ),
                        );
                    account_infos
                }
            }
        }
        impl<'info> IdlResizeAccount<'info> {
            pub fn __anchor_private_gen_idl_accounts(
                accounts: &mut std::collections::BTreeMap<
                    String,
                    anchor_lang::idl::types::IdlAccount,
                >,
                types: &mut std::collections::BTreeMap<
                    String,
                    anchor_lang::idl::types::IdlTypeDef,
                >,
            ) -> Vec<anchor_lang::idl::types::IdlInstructionAccountItem> {
                if let Some(ty) = <IdlAccount>::create_type() {
                    let account = anchor_lang::idl::types::IdlAccount {
                        name: ty.name.clone(),
                        discriminator: IdlAccount::DISCRIMINATOR.into(),
                    };
                    accounts.insert(account.name.clone(), account);
                    types.insert(ty.name.clone(), ty);
                    <IdlAccount>::insert_types(types);
                }
                <[_]>::into_vec(
                    ::alloc::boxed::box_new([
                        anchor_lang::idl::types::IdlInstructionAccountItem::Single(anchor_lang::idl::types::IdlInstructionAccount {
                            name: "idl".into(),
                            docs: ::alloc::vec::Vec::new(),
                            writable: true,
                            signer: false,
                            optional: false,
                            address: None,
                            pda: None,
                            relations: ::alloc::vec::Vec::new(),
                        }),
                        anchor_lang::idl::types::IdlInstructionAccountItem::Single(anchor_lang::idl::types::IdlInstructionAccount {
                            name: "authority".into(),
                            docs: ::alloc::vec::Vec::new(),
                            writable: true,
                            signer: true,
                            optional: false,
                            address: None,
                            pda: None,
                            relations: ::alloc::vec::Vec::new(),
                        }),
                        anchor_lang::idl::types::IdlInstructionAccountItem::Single(anchor_lang::idl::types::IdlInstructionAccount {
                            name: "system_program".into(),
                            docs: ::alloc::vec::Vec::new(),
                            writable: false,
                            signer: false,
                            optional: false,
                            address: None,
                            pda: None,
                            relations: ::alloc::vec::Vec::new(),
                        }),
                    ]),
                )
            }
            pub fn __anchor_private_gen_light_metadata() -> Option<
                anchor_lang::idl::types::IdlLightInstructionMeta,
            > {
                None
            }
        }
        pub struct IdlCreateBuffer<'info> {
            #[account(zero)]
            pub buffer: Account<'info, IdlAccount>,
            #[account(constraint = authority.key!= &ERASED_AUTHORITY)]
            pub authority: Signer<'info>,
        }
        #[automatically_derived]
        impl<'info> anchor_lang::Accounts<'info, IdlCreateBufferBumps>
        for IdlCreateBuffer<'info>
        where
            'info: 'info,
        {
            #[inline(never)]
            fn try_accounts(
                __program_id: &anchor_lang::solana_program::pubkey::Pubkey,
                __accounts: &mut &'info [anchor_lang::solana_program::account_info::AccountInfo<
                    'info,
                >],
                __ix_data: &[u8],
                __bumps: &mut IdlCreateBufferBumps,
                __reallocs: &mut std::collections::BTreeSet<
                    anchor_lang::solana_program::pubkey::Pubkey,
                >,
            ) -> anchor_lang::Result<Self> {
                if __accounts.is_empty() {
                    return Err(
                        anchor_lang::error::ErrorCode::AccountNotEnoughKeys.into(),
                    );
                }
                let buffer = &__accounts[0];
                *__accounts = &__accounts[1..];
                let authority: Signer = anchor_lang::Accounts::try_accounts(
                        __program_id,
                        __accounts,
                        __ix_data,
                        __bumps,
                        __reallocs,
                    )
                    .map_err(|e| e.with_account_name("authority"))?;
                let __anchor_rent = Rent::get()?;
                let buffer: anchor_lang::accounts::account::Account<IdlAccount> = {
                    let mut __data: &[u8] = &buffer.try_borrow_data()?;
                    let __disc = &__data[..IdlAccount::DISCRIMINATOR.len()];
                    let __has_disc = __disc.iter().any(|b| *b != 0);
                    if __has_disc {
                        return Err(
                            anchor_lang::error::Error::from(
                                    anchor_lang::error::ErrorCode::ConstraintZero,
                                )
                                .with_account_name("buffer"),
                        );
                    }
                    match anchor_lang::accounts::account::Account::try_from_unchecked(
                        &buffer,
                    ) {
                        Ok(val) => val,
                        Err(e) => return Err(e.with_account_name("buffer")),
                    }
                };
                if !AsRef::<AccountInfo>::as_ref(&buffer).is_writable {
                    return Err(
                        anchor_lang::error::Error::from(
                                anchor_lang::error::ErrorCode::ConstraintMut,
                            )
                            .with_account_name("buffer"),
                    );
                }
                if !__anchor_rent
                    .is_exempt(
                        buffer.to_account_info().lamports(),
                        buffer.to_account_info().try_data_len()?,
                    )
                {
                    return Err(
                        anchor_lang::error::Error::from(
                                anchor_lang::error::ErrorCode::ConstraintRentExempt,
                            )
                            .with_account_name("buffer"),
                    );
                }
                if !(authority.key != &ERASED_AUTHORITY) {
                    return Err(
                        anchor_lang::error::Error::from(
                                anchor_lang::error::ErrorCode::ConstraintRaw,
                            )
                            .with_account_name("authority"),
                    );
                }
                Ok(IdlCreateBuffer {
                    buffer,
                    authority,
                })
            }
        }
        #[automatically_derived]
        impl<'info> anchor_lang::ToAccountInfos<'info> for IdlCreateBuffer<'info>
        where
            'info: 'info,
        {
            fn to_account_infos(
                &self,
            ) -> Vec<anchor_lang::solana_program::account_info::AccountInfo<'info>> {
                let mut account_infos = ::alloc::vec::Vec::new();
                account_infos.extend(self.buffer.to_account_infos());
                account_infos.extend(self.authority.to_account_infos());
                account_infos
            }
        }
        #[automatically_derived]
        impl<'info> anchor_lang::ToAccountMetas for IdlCreateBuffer<'info> {
            fn to_account_metas(
                &self,
                is_signer: Option<bool>,
            ) -> Vec<anchor_lang::solana_program::instruction::AccountMeta> {
                let mut account_metas = ::alloc::vec::Vec::new();
                account_metas.extend(self.buffer.to_account_metas(None));
                account_metas.extend(self.authority.to_account_metas(None));
                account_metas
            }
        }
        #[automatically_derived]
        impl<'info> anchor_lang::AccountsFinalize<'info, IdlCreateBufferBumps>
        for IdlCreateBuffer<'info>
        where
            'info: 'info,
        {
            fn finalize(
                &mut self,
                program_id: &anchor_lang::solana_program::pubkey::Pubkey,
                _remaining: &[anchor_lang::solana_program::account_info::AccountInfo<
                    'info,
                >],
                _ix_data: &[u8],
                _bumps: &IdlCreateBufferBumps,
            ) -> anchor_lang::Result<()> {
                anchor_lang::AccountsFinalize::finalize(
                        &mut self.buffer,
                        program_id,
                        _remaining,
                        _ix_data,
                        _bumps,
                    )
                    .map_err(|e| e.with_account_name("buffer"))?;
                Ok(())
            }
        }
        #[automatically_derived]
        impl<'info> anchor_lang::AccountsExit<'info> for IdlCreateBuffer<'info>
        where
            'info: 'info,
        {
            fn exit(
                &self,
                program_id: &anchor_lang::solana_program::pubkey::Pubkey,
            ) -> anchor_lang::Result<()> {
                anchor_lang::AccountsExit::exit(&self.buffer, program_id)
                    .map_err(|e| e.with_account_name("buffer"))?;
                Ok(())
            }
        }
        pub struct IdlCreateBufferBumps {}
        #[automatically_derived]
        impl ::core::fmt::Debug for IdlCreateBufferBumps {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::write_str(f, "IdlCreateBufferBumps")
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for IdlCreateBufferBumps {
            #[inline]
            fn clone(&self) -> IdlCreateBufferBumps {
                IdlCreateBufferBumps {}
            }
        }
        impl Default for IdlCreateBufferBumps {
            fn default() -> Self {
                IdlCreateBufferBumps {}
            }
        }
        impl<'info> anchor_lang::Bumps for IdlCreateBuffer<'info>
        where
            'info: 'info,
        {
            type Bumps = IdlCreateBufferBumps;
        }
        /// An internal, Anchor generated module. This is used (as an
        /// implementation detail), to generate a struct for a given
        /// `#[derive(Accounts)]` implementation, where each field is a Pubkey,
        /// instead of an `AccountInfo`. This is useful for clients that want
        /// to generate a list of accounts, without explicitly knowing the
        /// order all the fields should be in.
        ///
        /// To access the struct in this module, one should use the sibling
        /// `accounts` module (also generated), which re-exports this.
        pub(crate) mod __client_accounts_idl_create_buffer {
            use super::*;
            use anchor_lang::prelude::borsh;
            /// Generated client accounts for [`IdlCreateBuffer`].
            pub struct IdlCreateBuffer {
                pub buffer: Pubkey,
                pub authority: Pubkey,
            }
            impl borsh::ser::BorshSerialize for IdlCreateBuffer
            where
                Pubkey: borsh::ser::BorshSerialize,
                Pubkey: borsh::ser::BorshSerialize,
            {
                fn serialize<W: borsh::maybestd::io::Write>(
                    &self,
                    writer: &mut W,
                ) -> ::core::result::Result<(), borsh::maybestd::io::Error> {
                    borsh::BorshSerialize::serialize(&self.buffer, writer)?;
                    borsh::BorshSerialize::serialize(&self.authority, writer)?;
                    Ok(())
                }
            }
            impl anchor_lang::idl::build::IdlBuild for IdlCreateBuffer {
                fn create_type() -> Option<anchor_lang::idl::types::IdlTypeDef> {
                    Some(anchor_lang::idl::types::IdlTypeDef {
                        name: Self::get_full_path(),
                        docs: <[_]>::into_vec(
                            ::alloc::boxed::box_new([
                                "Generated client accounts for [`IdlCreateBuffer`].".into(),
                            ]),
                        ),
                        serialization: anchor_lang::idl::types::IdlSerialization::default(),
                        repr: None,
                        generics: ::alloc::vec::Vec::new(),
                        ty: anchor_lang::idl::types::IdlTypeDefTy::Struct {
                            fields: Some(
                                anchor_lang::idl::types::IdlDefinedFields::Named(
                                    <[_]>::into_vec(
                                        ::alloc::boxed::box_new([
                                            anchor_lang::idl::types::IdlField {
                                                name: "buffer".into(),
                                                docs: ::alloc::vec::Vec::new(),
                                                ty: anchor_lang::idl::types::IdlType::Pubkey,
                                            },
                                            anchor_lang::idl::types::IdlField {
                                                name: "authority".into(),
                                                docs: ::alloc::vec::Vec::new(),
                                                ty: anchor_lang::idl::types::IdlType::Pubkey,
                                            },
                                        ]),
                                    ),
                                ),
                            ),
                        },
                    })
                }
                fn insert_types(
                    types: &mut std::collections::BTreeMap<
                        String,
                        anchor_lang::idl::types::IdlTypeDef,
                    >,
                ) {}
                fn get_full_path() -> String {
                    ::alloc::__export::must_use({
                        ::alloc::fmt::format(
                            format_args!(
                                "{0}::{1}",
                                "raydium_cp_swap::__private::__idl::__client_accounts_idl_create_buffer",
                                "IdlCreateBuffer",
                            ),
                        )
                    })
                }
            }
            #[automatically_derived]
            impl anchor_lang::ToAccountMetas for IdlCreateBuffer {
                fn to_account_metas(
                    &self,
                    is_signer: Option<bool>,
                ) -> Vec<anchor_lang::solana_program::instruction::AccountMeta> {
                    let mut account_metas = ::alloc::vec::Vec::new();
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new(
                                self.buffer,
                                false,
                            ),
                        );
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                                self.authority,
                                true,
                            ),
                        );
                    account_metas
                }
            }
        }
        /// An internal, Anchor generated module. This is used (as an
        /// implementation detail), to generate a CPI struct for a given
        /// `#[derive(Accounts)]` implementation, where each field is an
        /// AccountInfo.
        ///
        /// To access the struct in this module, one should use the sibling
        /// [`cpi::accounts`] module (also generated), which re-exports this.
        pub(crate) mod __cpi_client_accounts_idl_create_buffer {
            use super::*;
            /// Generated CPI struct of the accounts for [`IdlCreateBuffer`].
            pub struct IdlCreateBuffer<'info> {
                pub buffer: anchor_lang::solana_program::account_info::AccountInfo<
                    'info,
                >,
                pub authority: anchor_lang::solana_program::account_info::AccountInfo<
                    'info,
                >,
            }
            #[automatically_derived]
            impl<'info> anchor_lang::ToAccountMetas for IdlCreateBuffer<'info> {
                fn to_account_metas(
                    &self,
                    is_signer: Option<bool>,
                ) -> Vec<anchor_lang::solana_program::instruction::AccountMeta> {
                    let mut account_metas = ::alloc::vec::Vec::new();
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new(
                                anchor_lang::Key::key(&self.buffer),
                                false,
                            ),
                        );
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                                anchor_lang::Key::key(&self.authority),
                                true,
                            ),
                        );
                    account_metas
                }
            }
            #[automatically_derived]
            impl<'info> anchor_lang::ToAccountInfos<'info> for IdlCreateBuffer<'info> {
                fn to_account_infos(
                    &self,
                ) -> Vec<anchor_lang::solana_program::account_info::AccountInfo<'info>> {
                    let mut account_infos = ::alloc::vec::Vec::new();
                    account_infos
                        .extend(
                            anchor_lang::ToAccountInfos::to_account_infos(&self.buffer),
                        );
                    account_infos
                        .extend(
                            anchor_lang::ToAccountInfos::to_account_infos(
                                &self.authority,
                            ),
                        );
                    account_infos
                }
            }
        }
        impl<'info> IdlCreateBuffer<'info> {
            pub fn __anchor_private_gen_idl_accounts(
                accounts: &mut std::collections::BTreeMap<
                    String,
                    anchor_lang::idl::types::IdlAccount,
                >,
                types: &mut std::collections::BTreeMap<
                    String,
                    anchor_lang::idl::types::IdlTypeDef,
                >,
            ) -> Vec<anchor_lang::idl::types::IdlInstructionAccountItem> {
                if let Some(ty) = <IdlAccount>::create_type() {
                    let account = anchor_lang::idl::types::IdlAccount {
                        name: ty.name.clone(),
                        discriminator: IdlAccount::DISCRIMINATOR.into(),
                    };
                    accounts.insert(account.name.clone(), account);
                    types.insert(ty.name.clone(), ty);
                    <IdlAccount>::insert_types(types);
                }
                <[_]>::into_vec(
                    ::alloc::boxed::box_new([
                        anchor_lang::idl::types::IdlInstructionAccountItem::Single(anchor_lang::idl::types::IdlInstructionAccount {
                            name: "buffer".into(),
                            docs: ::alloc::vec::Vec::new(),
                            writable: true,
                            signer: false,
                            optional: false,
                            address: None,
                            pda: None,
                            relations: ::alloc::vec::Vec::new(),
                        }),
                        anchor_lang::idl::types::IdlInstructionAccountItem::Single(anchor_lang::idl::types::IdlInstructionAccount {
                            name: "authority".into(),
                            docs: ::alloc::vec::Vec::new(),
                            writable: false,
                            signer: true,
                            optional: false,
                            address: None,
                            pda: None,
                            relations: ::alloc::vec::Vec::new(),
                        }),
                    ]),
                )
            }
            pub fn __anchor_private_gen_light_metadata() -> Option<
                anchor_lang::idl::types::IdlLightInstructionMeta,
            > {
                None
            }
        }
        pub struct IdlSetBuffer<'info> {
            #[account(mut, constraint = buffer.authority = = idl.authority)]
            pub buffer: Account<'info, IdlAccount>,
            #[account(mut, has_one = authority)]
            pub idl: Account<'info, IdlAccount>,
            #[account(constraint = authority.key!= &ERASED_AUTHORITY)]
            pub authority: Signer<'info>,
        }
        #[automatically_derived]
        impl<'info> anchor_lang::Accounts<'info, IdlSetBufferBumps>
        for IdlSetBuffer<'info>
        where
            'info: 'info,
        {
            #[inline(never)]
            fn try_accounts(
                __program_id: &anchor_lang::solana_program::pubkey::Pubkey,
                __accounts: &mut &'info [anchor_lang::solana_program::account_info::AccountInfo<
                    'info,
                >],
                __ix_data: &[u8],
                __bumps: &mut IdlSetBufferBumps,
                __reallocs: &mut std::collections::BTreeSet<
                    anchor_lang::solana_program::pubkey::Pubkey,
                >,
            ) -> anchor_lang::Result<Self> {
                let buffer: anchor_lang::accounts::account::Account<IdlAccount> = anchor_lang::Accounts::try_accounts(
                        __program_id,
                        __accounts,
                        __ix_data,
                        __bumps,
                        __reallocs,
                    )
                    .map_err(|e| e.with_account_name("buffer"))?;
                let idl: anchor_lang::accounts::account::Account<IdlAccount> = anchor_lang::Accounts::try_accounts(
                        __program_id,
                        __accounts,
                        __ix_data,
                        __bumps,
                        __reallocs,
                    )
                    .map_err(|e| e.with_account_name("idl"))?;
                let authority: Signer = anchor_lang::Accounts::try_accounts(
                        __program_id,
                        __accounts,
                        __ix_data,
                        __bumps,
                        __reallocs,
                    )
                    .map_err(|e| e.with_account_name("authority"))?;
                if !AsRef::<AccountInfo>::as_ref(&buffer).is_writable {
                    return Err(
                        anchor_lang::error::Error::from(
                                anchor_lang::error::ErrorCode::ConstraintMut,
                            )
                            .with_account_name("buffer"),
                    );
                }
                if !(buffer.authority == idl.authority) {
                    return Err(
                        anchor_lang::error::Error::from(
                                anchor_lang::error::ErrorCode::ConstraintRaw,
                            )
                            .with_account_name("buffer"),
                    );
                }
                if !AsRef::<AccountInfo>::as_ref(&idl).is_writable {
                    return Err(
                        anchor_lang::error::Error::from(
                                anchor_lang::error::ErrorCode::ConstraintMut,
                            )
                            .with_account_name("idl"),
                    );
                }
                {
                    let my_key = idl.authority;
                    let target_key = authority.key();
                    if my_key != target_key {
                        return Err(
                            anchor_lang::error::Error::from(
                                    anchor_lang::error::ErrorCode::ConstraintHasOne,
                                )
                                .with_account_name("idl")
                                .with_pubkeys((my_key, target_key)),
                        );
                    }
                }
                if !(authority.key != &ERASED_AUTHORITY) {
                    return Err(
                        anchor_lang::error::Error::from(
                                anchor_lang::error::ErrorCode::ConstraintRaw,
                            )
                            .with_account_name("authority"),
                    );
                }
                Ok(IdlSetBuffer {
                    buffer,
                    idl,
                    authority,
                })
            }
        }
        #[automatically_derived]
        impl<'info> anchor_lang::ToAccountInfos<'info> for IdlSetBuffer<'info>
        where
            'info: 'info,
        {
            fn to_account_infos(
                &self,
            ) -> Vec<anchor_lang::solana_program::account_info::AccountInfo<'info>> {
                let mut account_infos = ::alloc::vec::Vec::new();
                account_infos.extend(self.buffer.to_account_infos());
                account_infos.extend(self.idl.to_account_infos());
                account_infos.extend(self.authority.to_account_infos());
                account_infos
            }
        }
        #[automatically_derived]
        impl<'info> anchor_lang::ToAccountMetas for IdlSetBuffer<'info> {
            fn to_account_metas(
                &self,
                is_signer: Option<bool>,
            ) -> Vec<anchor_lang::solana_program::instruction::AccountMeta> {
                let mut account_metas = ::alloc::vec::Vec::new();
                account_metas.extend(self.buffer.to_account_metas(None));
                account_metas.extend(self.idl.to_account_metas(None));
                account_metas.extend(self.authority.to_account_metas(None));
                account_metas
            }
        }
        #[automatically_derived]
        impl<'info> anchor_lang::AccountsFinalize<'info, IdlSetBufferBumps>
        for IdlSetBuffer<'info>
        where
            'info: 'info,
        {
            fn finalize(
                &mut self,
                program_id: &anchor_lang::solana_program::pubkey::Pubkey,
                _remaining: &[anchor_lang::solana_program::account_info::AccountInfo<
                    'info,
                >],
                _ix_data: &[u8],
                _bumps: &IdlSetBufferBumps,
            ) -> anchor_lang::Result<()> {
                anchor_lang::AccountsFinalize::finalize(
                        &mut self.buffer,
                        program_id,
                        _remaining,
                        _ix_data,
                        _bumps,
                    )
                    .map_err(|e| e.with_account_name("buffer"))?;
                anchor_lang::AccountsFinalize::finalize(
                        &mut self.idl,
                        program_id,
                        _remaining,
                        _ix_data,
                        _bumps,
                    )
                    .map_err(|e| e.with_account_name("idl"))?;
                Ok(())
            }
        }
        #[automatically_derived]
        impl<'info> anchor_lang::AccountsExit<'info> for IdlSetBuffer<'info>
        where
            'info: 'info,
        {
            fn exit(
                &self,
                program_id: &anchor_lang::solana_program::pubkey::Pubkey,
            ) -> anchor_lang::Result<()> {
                anchor_lang::AccountsExit::exit(&self.buffer, program_id)
                    .map_err(|e| e.with_account_name("buffer"))?;
                anchor_lang::AccountsExit::exit(&self.idl, program_id)
                    .map_err(|e| e.with_account_name("idl"))?;
                Ok(())
            }
        }
        pub struct IdlSetBufferBumps {}
        #[automatically_derived]
        impl ::core::fmt::Debug for IdlSetBufferBumps {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::write_str(f, "IdlSetBufferBumps")
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for IdlSetBufferBumps {
            #[inline]
            fn clone(&self) -> IdlSetBufferBumps {
                IdlSetBufferBumps {}
            }
        }
        impl Default for IdlSetBufferBumps {
            fn default() -> Self {
                IdlSetBufferBumps {}
            }
        }
        impl<'info> anchor_lang::Bumps for IdlSetBuffer<'info>
        where
            'info: 'info,
        {
            type Bumps = IdlSetBufferBumps;
        }
        /// An internal, Anchor generated module. This is used (as an
        /// implementation detail), to generate a struct for a given
        /// `#[derive(Accounts)]` implementation, where each field is a Pubkey,
        /// instead of an `AccountInfo`. This is useful for clients that want
        /// to generate a list of accounts, without explicitly knowing the
        /// order all the fields should be in.
        ///
        /// To access the struct in this module, one should use the sibling
        /// `accounts` module (also generated), which re-exports this.
        pub(crate) mod __client_accounts_idl_set_buffer {
            use super::*;
            use anchor_lang::prelude::borsh;
            /// Generated client accounts for [`IdlSetBuffer`].
            pub struct IdlSetBuffer {
                pub buffer: Pubkey,
                pub idl: Pubkey,
                pub authority: Pubkey,
            }
            impl borsh::ser::BorshSerialize for IdlSetBuffer
            where
                Pubkey: borsh::ser::BorshSerialize,
                Pubkey: borsh::ser::BorshSerialize,
                Pubkey: borsh::ser::BorshSerialize,
            {
                fn serialize<W: borsh::maybestd::io::Write>(
                    &self,
                    writer: &mut W,
                ) -> ::core::result::Result<(), borsh::maybestd::io::Error> {
                    borsh::BorshSerialize::serialize(&self.buffer, writer)?;
                    borsh::BorshSerialize::serialize(&self.idl, writer)?;
                    borsh::BorshSerialize::serialize(&self.authority, writer)?;
                    Ok(())
                }
            }
            impl anchor_lang::idl::build::IdlBuild for IdlSetBuffer {
                fn create_type() -> Option<anchor_lang::idl::types::IdlTypeDef> {
                    Some(anchor_lang::idl::types::IdlTypeDef {
                        name: Self::get_full_path(),
                        docs: <[_]>::into_vec(
                            ::alloc::boxed::box_new([
                                "Generated client accounts for [`IdlSetBuffer`].".into(),
                            ]),
                        ),
                        serialization: anchor_lang::idl::types::IdlSerialization::default(),
                        repr: None,
                        generics: ::alloc::vec::Vec::new(),
                        ty: anchor_lang::idl::types::IdlTypeDefTy::Struct {
                            fields: Some(
                                anchor_lang::idl::types::IdlDefinedFields::Named(
                                    <[_]>::into_vec(
                                        ::alloc::boxed::box_new([
                                            anchor_lang::idl::types::IdlField {
                                                name: "buffer".into(),
                                                docs: ::alloc::vec::Vec::new(),
                                                ty: anchor_lang::idl::types::IdlType::Pubkey,
                                            },
                                            anchor_lang::idl::types::IdlField {
                                                name: "idl".into(),
                                                docs: ::alloc::vec::Vec::new(),
                                                ty: anchor_lang::idl::types::IdlType::Pubkey,
                                            },
                                            anchor_lang::idl::types::IdlField {
                                                name: "authority".into(),
                                                docs: ::alloc::vec::Vec::new(),
                                                ty: anchor_lang::idl::types::IdlType::Pubkey,
                                            },
                                        ]),
                                    ),
                                ),
                            ),
                        },
                    })
                }
                fn insert_types(
                    types: &mut std::collections::BTreeMap<
                        String,
                        anchor_lang::idl::types::IdlTypeDef,
                    >,
                ) {}
                fn get_full_path() -> String {
                    ::alloc::__export::must_use({
                        ::alloc::fmt::format(
                            format_args!(
                                "{0}::{1}",
                                "raydium_cp_swap::__private::__idl::__client_accounts_idl_set_buffer",
                                "IdlSetBuffer",
                            ),
                        )
                    })
                }
            }
            #[automatically_derived]
            impl anchor_lang::ToAccountMetas for IdlSetBuffer {
                fn to_account_metas(
                    &self,
                    is_signer: Option<bool>,
                ) -> Vec<anchor_lang::solana_program::instruction::AccountMeta> {
                    let mut account_metas = ::alloc::vec::Vec::new();
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new(
                                self.buffer,
                                false,
                            ),
                        );
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new(
                                self.idl,
                                false,
                            ),
                        );
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                                self.authority,
                                true,
                            ),
                        );
                    account_metas
                }
            }
        }
        /// An internal, Anchor generated module. This is used (as an
        /// implementation detail), to generate a CPI struct for a given
        /// `#[derive(Accounts)]` implementation, where each field is an
        /// AccountInfo.
        ///
        /// To access the struct in this module, one should use the sibling
        /// [`cpi::accounts`] module (also generated), which re-exports this.
        pub(crate) mod __cpi_client_accounts_idl_set_buffer {
            use super::*;
            /// Generated CPI struct of the accounts for [`IdlSetBuffer`].
            pub struct IdlSetBuffer<'info> {
                pub buffer: anchor_lang::solana_program::account_info::AccountInfo<
                    'info,
                >,
                pub idl: anchor_lang::solana_program::account_info::AccountInfo<'info>,
                pub authority: anchor_lang::solana_program::account_info::AccountInfo<
                    'info,
                >,
            }
            #[automatically_derived]
            impl<'info> anchor_lang::ToAccountMetas for IdlSetBuffer<'info> {
                fn to_account_metas(
                    &self,
                    is_signer: Option<bool>,
                ) -> Vec<anchor_lang::solana_program::instruction::AccountMeta> {
                    let mut account_metas = ::alloc::vec::Vec::new();
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new(
                                anchor_lang::Key::key(&self.buffer),
                                false,
                            ),
                        );
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new(
                                anchor_lang::Key::key(&self.idl),
                                false,
                            ),
                        );
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                                anchor_lang::Key::key(&self.authority),
                                true,
                            ),
                        );
                    account_metas
                }
            }
            #[automatically_derived]
            impl<'info> anchor_lang::ToAccountInfos<'info> for IdlSetBuffer<'info> {
                fn to_account_infos(
                    &self,
                ) -> Vec<anchor_lang::solana_program::account_info::AccountInfo<'info>> {
                    let mut account_infos = ::alloc::vec::Vec::new();
                    account_infos
                        .extend(
                            anchor_lang::ToAccountInfos::to_account_infos(&self.buffer),
                        );
                    account_infos
                        .extend(
                            anchor_lang::ToAccountInfos::to_account_infos(&self.idl),
                        );
                    account_infos
                        .extend(
                            anchor_lang::ToAccountInfos::to_account_infos(
                                &self.authority,
                            ),
                        );
                    account_infos
                }
            }
        }
        impl<'info> IdlSetBuffer<'info> {
            pub fn __anchor_private_gen_idl_accounts(
                accounts: &mut std::collections::BTreeMap<
                    String,
                    anchor_lang::idl::types::IdlAccount,
                >,
                types: &mut std::collections::BTreeMap<
                    String,
                    anchor_lang::idl::types::IdlTypeDef,
                >,
            ) -> Vec<anchor_lang::idl::types::IdlInstructionAccountItem> {
                if let Some(ty) = <IdlAccount>::create_type() {
                    let account = anchor_lang::idl::types::IdlAccount {
                        name: ty.name.clone(),
                        discriminator: IdlAccount::DISCRIMINATOR.into(),
                    };
                    accounts.insert(account.name.clone(), account);
                    types.insert(ty.name.clone(), ty);
                    <IdlAccount>::insert_types(types);
                }
                if let Some(ty) = <IdlAccount>::create_type() {
                    let account = anchor_lang::idl::types::IdlAccount {
                        name: ty.name.clone(),
                        discriminator: IdlAccount::DISCRIMINATOR.into(),
                    };
                    accounts.insert(account.name.clone(), account);
                    types.insert(ty.name.clone(), ty);
                    <IdlAccount>::insert_types(types);
                }
                <[_]>::into_vec(
                    ::alloc::boxed::box_new([
                        anchor_lang::idl::types::IdlInstructionAccountItem::Single(anchor_lang::idl::types::IdlInstructionAccount {
                            name: "buffer".into(),
                            docs: ::alloc::vec::Vec::new(),
                            writable: true,
                            signer: false,
                            optional: false,
                            address: None,
                            pda: None,
                            relations: ::alloc::vec::Vec::new(),
                        }),
                        anchor_lang::idl::types::IdlInstructionAccountItem::Single(anchor_lang::idl::types::IdlInstructionAccount {
                            name: "idl".into(),
                            docs: ::alloc::vec::Vec::new(),
                            writable: true,
                            signer: false,
                            optional: false,
                            address: None,
                            pda: None,
                            relations: ::alloc::vec::Vec::new(),
                        }),
                        anchor_lang::idl::types::IdlInstructionAccountItem::Single(anchor_lang::idl::types::IdlInstructionAccount {
                            name: "authority".into(),
                            docs: ::alloc::vec::Vec::new(),
                            writable: false,
                            signer: true,
                            optional: false,
                            address: None,
                            pda: None,
                            relations: ::alloc::vec::Vec::new(),
                        }),
                    ]),
                )
            }
            pub fn __anchor_private_gen_light_metadata() -> Option<
                anchor_lang::idl::types::IdlLightInstructionMeta,
            > {
                None
            }
        }
        pub struct IdlCloseAccount<'info> {
            #[account(mut, has_one = authority, close = sol_destination)]
            pub account: Account<'info, IdlAccount>,
            #[account(constraint = authority.key!= &ERASED_AUTHORITY)]
            pub authority: Signer<'info>,
            #[account(mut)]
            pub sol_destination: AccountInfo<'info>,
        }
        #[automatically_derived]
        impl<'info> anchor_lang::Accounts<'info, IdlCloseAccountBumps>
        for IdlCloseAccount<'info>
        where
            'info: 'info,
        {
            #[inline(never)]
            fn try_accounts(
                __program_id: &anchor_lang::solana_program::pubkey::Pubkey,
                __accounts: &mut &'info [anchor_lang::solana_program::account_info::AccountInfo<
                    'info,
                >],
                __ix_data: &[u8],
                __bumps: &mut IdlCloseAccountBumps,
                __reallocs: &mut std::collections::BTreeSet<
                    anchor_lang::solana_program::pubkey::Pubkey,
                >,
            ) -> anchor_lang::Result<Self> {
                let account: anchor_lang::accounts::account::Account<IdlAccount> = anchor_lang::Accounts::try_accounts(
                        __program_id,
                        __accounts,
                        __ix_data,
                        __bumps,
                        __reallocs,
                    )
                    .map_err(|e| e.with_account_name("account"))?;
                let authority: Signer = anchor_lang::Accounts::try_accounts(
                        __program_id,
                        __accounts,
                        __ix_data,
                        __bumps,
                        __reallocs,
                    )
                    .map_err(|e| e.with_account_name("authority"))?;
                let sol_destination: AccountInfo = anchor_lang::Accounts::try_accounts(
                        __program_id,
                        __accounts,
                        __ix_data,
                        __bumps,
                        __reallocs,
                    )
                    .map_err(|e| e.with_account_name("sol_destination"))?;
                if !AsRef::<AccountInfo>::as_ref(&account).is_writable {
                    return Err(
                        anchor_lang::error::Error::from(
                                anchor_lang::error::ErrorCode::ConstraintMut,
                            )
                            .with_account_name("account"),
                    );
                }
                {
                    let my_key = account.authority;
                    let target_key = authority.key();
                    if my_key != target_key {
                        return Err(
                            anchor_lang::error::Error::from(
                                    anchor_lang::error::ErrorCode::ConstraintHasOne,
                                )
                                .with_account_name("account")
                                .with_pubkeys((my_key, target_key)),
                        );
                    }
                }
                {
                    if account.key() == sol_destination.key() {
                        return Err(
                            anchor_lang::error::Error::from(
                                    anchor_lang::error::ErrorCode::ConstraintClose,
                                )
                                .with_account_name("account"),
                        );
                    }
                }
                if !(authority.key != &ERASED_AUTHORITY) {
                    return Err(
                        anchor_lang::error::Error::from(
                                anchor_lang::error::ErrorCode::ConstraintRaw,
                            )
                            .with_account_name("authority"),
                    );
                }
                if !&sol_destination.is_writable {
                    return Err(
                        anchor_lang::error::Error::from(
                                anchor_lang::error::ErrorCode::ConstraintMut,
                            )
                            .with_account_name("sol_destination"),
                    );
                }
                Ok(IdlCloseAccount {
                    account,
                    authority,
                    sol_destination,
                })
            }
        }
        #[automatically_derived]
        impl<'info> anchor_lang::ToAccountInfos<'info> for IdlCloseAccount<'info>
        where
            'info: 'info,
        {
            fn to_account_infos(
                &self,
            ) -> Vec<anchor_lang::solana_program::account_info::AccountInfo<'info>> {
                let mut account_infos = ::alloc::vec::Vec::new();
                account_infos.extend(self.account.to_account_infos());
                account_infos.extend(self.authority.to_account_infos());
                account_infos.extend(self.sol_destination.to_account_infos());
                account_infos
            }
        }
        #[automatically_derived]
        impl<'info> anchor_lang::ToAccountMetas for IdlCloseAccount<'info> {
            fn to_account_metas(
                &self,
                is_signer: Option<bool>,
            ) -> Vec<anchor_lang::solana_program::instruction::AccountMeta> {
                let mut account_metas = ::alloc::vec::Vec::new();
                account_metas.extend(self.account.to_account_metas(None));
                account_metas.extend(self.authority.to_account_metas(None));
                account_metas.extend(self.sol_destination.to_account_metas(None));
                account_metas
            }
        }
        #[automatically_derived]
        impl<'info> anchor_lang::AccountsFinalize<'info, IdlCloseAccountBumps>
        for IdlCloseAccount<'info>
        where
            'info: 'info,
        {
            fn finalize(
                &mut self,
                program_id: &anchor_lang::solana_program::pubkey::Pubkey,
                _remaining: &[anchor_lang::solana_program::account_info::AccountInfo<
                    'info,
                >],
                _ix_data: &[u8],
                _bumps: &IdlCloseAccountBumps,
            ) -> anchor_lang::Result<()> {
                anchor_lang::AccountsFinalize::finalize(
                        &mut self.account,
                        program_id,
                        _remaining,
                        _ix_data,
                        _bumps,
                    )
                    .map_err(|e| e.with_account_name("account"))?;
                Ok(())
            }
        }
        #[automatically_derived]
        impl<'info> anchor_lang::AccountsExit<'info> for IdlCloseAccount<'info>
        where
            'info: 'info,
        {
            fn exit(
                &self,
                program_id: &anchor_lang::solana_program::pubkey::Pubkey,
            ) -> anchor_lang::Result<()> {
                {
                    let sol_destination = &self.sol_destination;
                    anchor_lang::AccountsClose::close(
                            &self.account,
                            sol_destination.to_account_info(),
                        )
                        .map_err(|e| e.with_account_name("account"))?;
                }
                anchor_lang::AccountsExit::exit(&self.sol_destination, program_id)
                    .map_err(|e| e.with_account_name("sol_destination"))?;
                Ok(())
            }
        }
        pub struct IdlCloseAccountBumps {}
        #[automatically_derived]
        impl ::core::fmt::Debug for IdlCloseAccountBumps {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::write_str(f, "IdlCloseAccountBumps")
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for IdlCloseAccountBumps {
            #[inline]
            fn clone(&self) -> IdlCloseAccountBumps {
                IdlCloseAccountBumps {}
            }
        }
        impl Default for IdlCloseAccountBumps {
            fn default() -> Self {
                IdlCloseAccountBumps {}
            }
        }
        impl<'info> anchor_lang::Bumps for IdlCloseAccount<'info>
        where
            'info: 'info,
        {
            type Bumps = IdlCloseAccountBumps;
        }
        /// An internal, Anchor generated module. This is used (as an
        /// implementation detail), to generate a struct for a given
        /// `#[derive(Accounts)]` implementation, where each field is a Pubkey,
        /// instead of an `AccountInfo`. This is useful for clients that want
        /// to generate a list of accounts, without explicitly knowing the
        /// order all the fields should be in.
        ///
        /// To access the struct in this module, one should use the sibling
        /// `accounts` module (also generated), which re-exports this.
        pub(crate) mod __client_accounts_idl_close_account {
            use super::*;
            use anchor_lang::prelude::borsh;
            /// Generated client accounts for [`IdlCloseAccount`].
            pub struct IdlCloseAccount {
                pub account: Pubkey,
                pub authority: Pubkey,
                pub sol_destination: Pubkey,
            }
            impl borsh::ser::BorshSerialize for IdlCloseAccount
            where
                Pubkey: borsh::ser::BorshSerialize,
                Pubkey: borsh::ser::BorshSerialize,
                Pubkey: borsh::ser::BorshSerialize,
            {
                fn serialize<W: borsh::maybestd::io::Write>(
                    &self,
                    writer: &mut W,
                ) -> ::core::result::Result<(), borsh::maybestd::io::Error> {
                    borsh::BorshSerialize::serialize(&self.account, writer)?;
                    borsh::BorshSerialize::serialize(&self.authority, writer)?;
                    borsh::BorshSerialize::serialize(&self.sol_destination, writer)?;
                    Ok(())
                }
            }
            impl anchor_lang::idl::build::IdlBuild for IdlCloseAccount {
                fn create_type() -> Option<anchor_lang::idl::types::IdlTypeDef> {
                    Some(anchor_lang::idl::types::IdlTypeDef {
                        name: Self::get_full_path(),
                        docs: <[_]>::into_vec(
                            ::alloc::boxed::box_new([
                                "Generated client accounts for [`IdlCloseAccount`].".into(),
                            ]),
                        ),
                        serialization: anchor_lang::idl::types::IdlSerialization::default(),
                        repr: None,
                        generics: ::alloc::vec::Vec::new(),
                        ty: anchor_lang::idl::types::IdlTypeDefTy::Struct {
                            fields: Some(
                                anchor_lang::idl::types::IdlDefinedFields::Named(
                                    <[_]>::into_vec(
                                        ::alloc::boxed::box_new([
                                            anchor_lang::idl::types::IdlField {
                                                name: "account".into(),
                                                docs: ::alloc::vec::Vec::new(),
                                                ty: anchor_lang::idl::types::IdlType::Pubkey,
                                            },
                                            anchor_lang::idl::types::IdlField {
                                                name: "authority".into(),
                                                docs: ::alloc::vec::Vec::new(),
                                                ty: anchor_lang::idl::types::IdlType::Pubkey,
                                            },
                                            anchor_lang::idl::types::IdlField {
                                                name: "sol_destination".into(),
                                                docs: ::alloc::vec::Vec::new(),
                                                ty: anchor_lang::idl::types::IdlType::Pubkey,
                                            },
                                        ]),
                                    ),
                                ),
                            ),
                        },
                    })
                }
                fn insert_types(
                    types: &mut std::collections::BTreeMap<
                        String,
                        anchor_lang::idl::types::IdlTypeDef,
                    >,
                ) {}
                fn get_full_path() -> String {
                    ::alloc::__export::must_use({
                        ::alloc::fmt::format(
                            format_args!(
                                "{0}::{1}",
                                "raydium_cp_swap::__private::__idl::__client_accounts_idl_close_account",
                                "IdlCloseAccount",
                            ),
                        )
                    })
                }
            }
            #[automatically_derived]
            impl anchor_lang::ToAccountMetas for IdlCloseAccount {
                fn to_account_metas(
                    &self,
                    is_signer: Option<bool>,
                ) -> Vec<anchor_lang::solana_program::instruction::AccountMeta> {
                    let mut account_metas = ::alloc::vec::Vec::new();
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new(
                                self.account,
                                false,
                            ),
                        );
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                                self.authority,
                                true,
                            ),
                        );
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new(
                                self.sol_destination,
                                false,
                            ),
                        );
                    account_metas
                }
            }
        }
        /// An internal, Anchor generated module. This is used (as an
        /// implementation detail), to generate a CPI struct for a given
        /// `#[derive(Accounts)]` implementation, where each field is an
        /// AccountInfo.
        ///
        /// To access the struct in this module, one should use the sibling
        /// [`cpi::accounts`] module (also generated), which re-exports this.
        pub(crate) mod __cpi_client_accounts_idl_close_account {
            use super::*;
            /// Generated CPI struct of the accounts for [`IdlCloseAccount`].
            pub struct IdlCloseAccount<'info> {
                pub account: anchor_lang::solana_program::account_info::AccountInfo<
                    'info,
                >,
                pub authority: anchor_lang::solana_program::account_info::AccountInfo<
                    'info,
                >,
                pub sol_destination: anchor_lang::solana_program::account_info::AccountInfo<
                    'info,
                >,
            }
            #[automatically_derived]
            impl<'info> anchor_lang::ToAccountMetas for IdlCloseAccount<'info> {
                fn to_account_metas(
                    &self,
                    is_signer: Option<bool>,
                ) -> Vec<anchor_lang::solana_program::instruction::AccountMeta> {
                    let mut account_metas = ::alloc::vec::Vec::new();
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new(
                                anchor_lang::Key::key(&self.account),
                                false,
                            ),
                        );
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                                anchor_lang::Key::key(&self.authority),
                                true,
                            ),
                        );
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new(
                                anchor_lang::Key::key(&self.sol_destination),
                                false,
                            ),
                        );
                    account_metas
                }
            }
            #[automatically_derived]
            impl<'info> anchor_lang::ToAccountInfos<'info> for IdlCloseAccount<'info> {
                fn to_account_infos(
                    &self,
                ) -> Vec<anchor_lang::solana_program::account_info::AccountInfo<'info>> {
                    let mut account_infos = ::alloc::vec::Vec::new();
                    account_infos
                        .extend(
                            anchor_lang::ToAccountInfos::to_account_infos(&self.account),
                        );
                    account_infos
                        .extend(
                            anchor_lang::ToAccountInfos::to_account_infos(
                                &self.authority,
                            ),
                        );
                    account_infos
                        .extend(
                            anchor_lang::ToAccountInfos::to_account_infos(
                                &self.sol_destination,
                            ),
                        );
                    account_infos
                }
            }
        }
        impl<'info> IdlCloseAccount<'info> {
            pub fn __anchor_private_gen_idl_accounts(
                accounts: &mut std::collections::BTreeMap<
                    String,
                    anchor_lang::idl::types::IdlAccount,
                >,
                types: &mut std::collections::BTreeMap<
                    String,
                    anchor_lang::idl::types::IdlTypeDef,
                >,
            ) -> Vec<anchor_lang::idl::types::IdlInstructionAccountItem> {
                if let Some(ty) = <IdlAccount>::create_type() {
                    let account = anchor_lang::idl::types::IdlAccount {
                        name: ty.name.clone(),
                        discriminator: IdlAccount::DISCRIMINATOR.into(),
                    };
                    accounts.insert(account.name.clone(), account);
                    types.insert(ty.name.clone(), ty);
                    <IdlAccount>::insert_types(types);
                }
                <[_]>::into_vec(
                    ::alloc::boxed::box_new([
                        anchor_lang::idl::types::IdlInstructionAccountItem::Single(anchor_lang::idl::types::IdlInstructionAccount {
                            name: "account".into(),
                            docs: ::alloc::vec::Vec::new(),
                            writable: true,
                            signer: false,
                            optional: false,
                            address: None,
                            pda: None,
                            relations: ::alloc::vec::Vec::new(),
                        }),
                        anchor_lang::idl::types::IdlInstructionAccountItem::Single(anchor_lang::idl::types::IdlInstructionAccount {
                            name: "authority".into(),
                            docs: ::alloc::vec::Vec::new(),
                            writable: false,
                            signer: true,
                            optional: false,
                            address: None,
                            pda: None,
                            relations: ::alloc::vec::Vec::new(),
                        }),
                        anchor_lang::idl::types::IdlInstructionAccountItem::Single(anchor_lang::idl::types::IdlInstructionAccount {
                            name: "sol_destination".into(),
                            docs: ::alloc::vec::Vec::new(),
                            writable: true,
                            signer: false,
                            optional: false,
                            address: None,
                            pda: None,
                            relations: ::alloc::vec::Vec::new(),
                        }),
                    ]),
                )
            }
            pub fn __anchor_private_gen_light_metadata() -> Option<
                anchor_lang::idl::types::IdlLightInstructionMeta,
            > {
                None
            }
        }
        use std::cell::{Ref, RefMut};
        pub trait IdlTrailingData<'info> {
            fn trailing_data(self) -> Ref<'info, [u8]>;
            fn trailing_data_mut(self) -> RefMut<'info, [u8]>;
        }
        impl<'a, 'info: 'a> IdlTrailingData<'a> for &'a Account<'info, IdlAccount> {
            fn trailing_data(self) -> Ref<'a, [u8]> {
                let info: &AccountInfo<'info> = self.as_ref();
                Ref::map(info.try_borrow_data().unwrap(), |d| &d[44..])
            }
            fn trailing_data_mut(self) -> RefMut<'a, [u8]> {
                let info: &AccountInfo<'info> = self.as_ref();
                RefMut::map(info.try_borrow_mut_data().unwrap(), |d| &mut d[44..])
            }
        }
        #[inline(never)]
        pub fn __idl_create_account(
            program_id: &Pubkey,
            accounts: &mut IdlCreateAccounts,
            data_len: u64,
        ) -> anchor_lang::Result<()> {
            ::solana_msg::sol_log("Instruction: IdlCreateAccount");
            if program_id != accounts.program.key {
                return Err(
                    anchor_lang::error::ErrorCode::IdlInstructionInvalidProgram.into(),
                );
            }
            let from = accounts.from.key;
            let (base, nonce) = Pubkey::find_program_address(&[], program_id);
            let seed = IdlAccount::seed();
            let owner = accounts.program.key;
            let to = Pubkey::create_with_seed(&base, seed, owner).unwrap();
            let space = std::cmp::min(
                IdlAccount::DISCRIMINATOR.len() + 32 + 4 + data_len as usize,
                10_000,
            );
            let rent = Rent::get()?;
            let lamports = rent.minimum_balance(space);
            let seeds = &[&[nonce][..]];
            let ix = anchor_lang::solana_program::system_instruction::create_account_with_seed(
                from,
                &to,
                &base,
                seed,
                lamports,
                space as u64,
                owner,
            );
            anchor_lang::solana_program::program::invoke_signed(
                &ix,
                &[
                    accounts.from.clone(),
                    accounts.to.clone(),
                    accounts.base.clone(),
                    accounts.system_program.to_account_info(),
                ],
                &[seeds],
            )?;
            let mut idl_account = {
                let mut account_data = accounts.to.try_borrow_data()?;
                let mut account_data_slice: &[u8] = &account_data;
                IdlAccount::try_deserialize_unchecked(&mut account_data_slice)?
            };
            idl_account.authority = *accounts.from.key;
            let mut data = accounts.to.try_borrow_mut_data()?;
            let dst: &mut [u8] = &mut data;
            let mut cursor = std::io::Cursor::new(dst);
            idl_account.try_serialize(&mut cursor)?;
            Ok(())
        }
        #[inline(never)]
        pub fn __idl_resize_account(
            program_id: &Pubkey,
            accounts: &mut IdlResizeAccount,
            data_len: u64,
        ) -> anchor_lang::Result<()> {
            ::solana_msg::sol_log("Instruction: IdlResizeAccount");
            let data_len: usize = data_len as usize;
            if accounts.idl.data_len != 0 {
                return Err(anchor_lang::error::ErrorCode::IdlAccountNotEmpty.into());
            }
            let idl_ref = AsRef::<AccountInfo>::as_ref(&accounts.idl);
            let new_account_space = idl_ref
                .data_len()
                .checked_add(
                    std::cmp::min(
                        data_len
                            .checked_sub(idl_ref.data_len())
                            .expect(
                                "data_len should always be >= the current account space",
                            ),
                        10_000,
                    ),
                )
                .unwrap();
            if new_account_space > idl_ref.data_len() {
                let sysvar_rent = Rent::get()?;
                let new_rent_minimum = sysvar_rent.minimum_balance(new_account_space);
                anchor_lang::system_program::transfer(
                    anchor_lang::context::CpiContext::new(
                        accounts.system_program.to_account_info(),
                        anchor_lang::system_program::Transfer {
                            from: accounts.authority.to_account_info(),
                            to: accounts.idl.to_account_info(),
                        },
                    ),
                    new_rent_minimum.checked_sub(idl_ref.lamports()).unwrap(),
                )?;
                idl_ref.realloc(new_account_space, false)?;
            }
            Ok(())
        }
        #[inline(never)]
        pub fn __idl_close_account(
            program_id: &Pubkey,
            accounts: &mut IdlCloseAccount,
        ) -> anchor_lang::Result<()> {
            ::solana_msg::sol_log("Instruction: IdlCloseAccount");
            Ok(())
        }
        #[inline(never)]
        pub fn __idl_create_buffer(
            program_id: &Pubkey,
            accounts: &mut IdlCreateBuffer,
        ) -> anchor_lang::Result<()> {
            ::solana_msg::sol_log("Instruction: IdlCreateBuffer");
            let mut buffer = &mut accounts.buffer;
            buffer.authority = *accounts.authority.key;
            Ok(())
        }
        #[inline(never)]
        pub fn __idl_write(
            program_id: &Pubkey,
            accounts: &mut IdlAccounts,
            idl_data: Vec<u8>,
        ) -> anchor_lang::Result<()> {
            ::solana_msg::sol_log("Instruction: IdlWrite");
            let prev_len: usize = ::std::convert::TryInto::<
                usize,
            >::try_into(accounts.idl.data_len)
                .unwrap();
            let new_len: usize = prev_len.checked_add(idl_data.len()).unwrap() as usize;
            accounts.idl.data_len = accounts
                .idl
                .data_len
                .checked_add(
                    ::std::convert::TryInto::<u32>::try_into(idl_data.len()).unwrap(),
                )
                .unwrap();
            use IdlTrailingData;
            let mut idl_bytes = accounts.idl.trailing_data_mut();
            let idl_expansion = &mut idl_bytes[prev_len..new_len];
            if idl_expansion.len() != idl_data.len() {
                return Err(
                    anchor_lang::error::Error::from(anchor_lang::error::AnchorError {
                            error_name: anchor_lang::error::ErrorCode::RequireEqViolated
                                .name(),
                            error_code_number: anchor_lang::error::ErrorCode::RequireEqViolated
                                .into(),
                            error_msg: anchor_lang::error::ErrorCode::RequireEqViolated
                                .to_string(),
                            error_origin: Some(
                                anchor_lang::error::ErrorOrigin::Source(anchor_lang::error::Source {
                                    filename: "programs/cp-swap/src/lib.rs",
                                    line: 67u32,
                                }),
                            ),
                            compared_values: None,
                        })
                        .with_values((idl_expansion.len(), idl_data.len())),
                );
            }
            idl_expansion.copy_from_slice(&idl_data[..]);
            Ok(())
        }
        #[inline(never)]
        pub fn __idl_set_authority(
            program_id: &Pubkey,
            accounts: &mut IdlAccounts,
            new_authority: Pubkey,
        ) -> anchor_lang::Result<()> {
            ::solana_msg::sol_log("Instruction: IdlSetAuthority");
            accounts.idl.authority = new_authority;
            Ok(())
        }
        #[inline(never)]
        pub fn __idl_set_buffer(
            program_id: &Pubkey,
            accounts: &mut IdlSetBuffer,
        ) -> anchor_lang::Result<()> {
            ::solana_msg::sol_log("Instruction: IdlSetBuffer");
            accounts.idl.data_len = accounts.buffer.data_len;
            use IdlTrailingData;
            let buffer_len = ::std::convert::TryInto::<
                usize,
            >::try_into(accounts.buffer.data_len)
                .unwrap();
            let mut target = accounts.idl.trailing_data_mut();
            let source = &accounts.buffer.trailing_data()[..buffer_len];
            if target.len() < buffer_len {
                return Err(
                    anchor_lang::error::Error::from(anchor_lang::error::AnchorError {
                            error_name: anchor_lang::error::ErrorCode::RequireGteViolated
                                .name(),
                            error_code_number: anchor_lang::error::ErrorCode::RequireGteViolated
                                .into(),
                            error_msg: anchor_lang::error::ErrorCode::RequireGteViolated
                                .to_string(),
                            error_origin: Some(
                                anchor_lang::error::ErrorOrigin::Source(anchor_lang::error::Source {
                                    filename: "programs/cp-swap/src/lib.rs",
                                    line: 67u32,
                                }),
                            ),
                            compared_values: None,
                        })
                        .with_values((target.len(), buffer_len)),
                );
            }
            target[..buffer_len].copy_from_slice(source);
            Ok(())
        }
    }
    /// __global mod defines wrapped handlers for global instructions.
    pub mod __global {
        use super::*;
        #[inline(never)]
        pub fn create_amm_config<'info>(
            __program_id: &Pubkey,
            __accounts: &'info [AccountInfo<'info>],
            __ix_data: &[u8],
        ) -> anchor_lang::Result<()> {
            ::solana_msg::sol_log("Instruction: CreateAmmConfig");
            let ix = instruction::CreateAmmConfig::deserialize(&mut &__ix_data[..])
                .map_err(|_| {
                    anchor_lang::error::ErrorCode::InstructionDidNotDeserialize
                })?;
            let instruction::CreateAmmConfig {
                index,
                trade_fee_rate,
                protocol_fee_rate,
                fund_fee_rate,
                create_pool_fee,
            } = ix;
            let mut __bumps = <CreateAmmConfig as anchor_lang::Bumps>::Bumps::default();
            let mut __reallocs = std::collections::BTreeSet::new();
            let mut __remaining_accounts: &[AccountInfo] = __accounts;
            let mut __accounts = CreateAmmConfig::try_accounts(
                __program_id,
                &mut __remaining_accounts,
                __ix_data,
                &mut __bumps,
                &mut __reallocs,
            )?;
            let __bumps_for_finalize = __bumps.clone();
            let result = raydium_cp_swap::create_amm_config(
                anchor_lang::context::Context::new(
                    __program_id,
                    &mut __accounts,
                    __remaining_accounts,
                    __bumps,
                ),
                index,
                trade_fee_rate,
                protocol_fee_rate,
                fund_fee_rate,
                create_pool_fee,
            )?;
            anchor_lang::AccountsFinalize::finalize(
                &mut __accounts,
                __program_id,
                __remaining_accounts,
                __ix_data,
                &__bumps_for_finalize,
            )?;
            __accounts.exit(__program_id)
        }
        #[inline(never)]
        pub fn update_amm_config<'info>(
            __program_id: &Pubkey,
            __accounts: &'info [AccountInfo<'info>],
            __ix_data: &[u8],
        ) -> anchor_lang::Result<()> {
            ::solana_msg::sol_log("Instruction: UpdateAmmConfig");
            let ix = instruction::UpdateAmmConfig::deserialize(&mut &__ix_data[..])
                .map_err(|_| {
                    anchor_lang::error::ErrorCode::InstructionDidNotDeserialize
                })?;
            let instruction::UpdateAmmConfig { param, value } = ix;
            let mut __bumps = <UpdateAmmConfig as anchor_lang::Bumps>::Bumps::default();
            let mut __reallocs = std::collections::BTreeSet::new();
            let mut __remaining_accounts: &[AccountInfo] = __accounts;
            let mut __accounts = UpdateAmmConfig::try_accounts(
                __program_id,
                &mut __remaining_accounts,
                __ix_data,
                &mut __bumps,
                &mut __reallocs,
            )?;
            let __bumps_for_finalize = __bumps.clone();
            let result = raydium_cp_swap::update_amm_config(
                anchor_lang::context::Context::new(
                    __program_id,
                    &mut __accounts,
                    __remaining_accounts,
                    __bumps,
                ),
                param,
                value,
            )?;
            anchor_lang::AccountsFinalize::finalize(
                &mut __accounts,
                __program_id,
                __remaining_accounts,
                __ix_data,
                &__bumps_for_finalize,
            )?;
            __accounts.exit(__program_id)
        }
        #[inline(never)]
        pub fn update_pool_status<'info>(
            __program_id: &Pubkey,
            __accounts: &'info [AccountInfo<'info>],
            __ix_data: &[u8],
        ) -> anchor_lang::Result<()> {
            ::solana_msg::sol_log("Instruction: UpdatePoolStatus");
            let ix = instruction::UpdatePoolStatus::deserialize(&mut &__ix_data[..])
                .map_err(|_| {
                    anchor_lang::error::ErrorCode::InstructionDidNotDeserialize
                })?;
            let instruction::UpdatePoolStatus { status } = ix;
            let mut __bumps = <UpdatePoolStatus as anchor_lang::Bumps>::Bumps::default();
            let mut __reallocs = std::collections::BTreeSet::new();
            let mut __remaining_accounts: &[AccountInfo] = __accounts;
            let mut __accounts = UpdatePoolStatus::try_accounts(
                __program_id,
                &mut __remaining_accounts,
                __ix_data,
                &mut __bumps,
                &mut __reallocs,
            )?;
            let __bumps_for_finalize = __bumps.clone();
            let result = raydium_cp_swap::update_pool_status(
                anchor_lang::context::Context::new(
                    __program_id,
                    &mut __accounts,
                    __remaining_accounts,
                    __bumps,
                ),
                status,
            )?;
            anchor_lang::AccountsFinalize::finalize(
                &mut __accounts,
                __program_id,
                __remaining_accounts,
                __ix_data,
                &__bumps_for_finalize,
            )?;
            __accounts.exit(__program_id)
        }
        #[inline(never)]
        pub fn collect_protocol_fee<'info>(
            __program_id: &Pubkey,
            __accounts: &'info [AccountInfo<'info>],
            __ix_data: &[u8],
        ) -> anchor_lang::Result<()> {
            ::solana_msg::sol_log("Instruction: CollectProtocolFee");
            let ix = instruction::CollectProtocolFee::deserialize(&mut &__ix_data[..])
                .map_err(|_| {
                    anchor_lang::error::ErrorCode::InstructionDidNotDeserialize
                })?;
            let instruction::CollectProtocolFee {
                amount_0_requested,
                amount_1_requested,
            } = ix;
            let mut __bumps = <CollectProtocolFee as anchor_lang::Bumps>::Bumps::default();
            let mut __reallocs = std::collections::BTreeSet::new();
            let mut __remaining_accounts: &[AccountInfo] = __accounts;
            let mut __accounts = CollectProtocolFee::try_accounts(
                __program_id,
                &mut __remaining_accounts,
                __ix_data,
                &mut __bumps,
                &mut __reallocs,
            )?;
            let __bumps_for_finalize = __bumps.clone();
            let result = raydium_cp_swap::collect_protocol_fee(
                anchor_lang::context::Context::new(
                    __program_id,
                    &mut __accounts,
                    __remaining_accounts,
                    __bumps,
                ),
                amount_0_requested,
                amount_1_requested,
            )?;
            anchor_lang::AccountsFinalize::finalize(
                &mut __accounts,
                __program_id,
                __remaining_accounts,
                __ix_data,
                &__bumps_for_finalize,
            )?;
            __accounts.exit(__program_id)
        }
        #[inline(never)]
        pub fn collect_fund_fee<'info>(
            __program_id: &Pubkey,
            __accounts: &'info [AccountInfo<'info>],
            __ix_data: &[u8],
        ) -> anchor_lang::Result<()> {
            ::solana_msg::sol_log("Instruction: CollectFundFee");
            let ix = instruction::CollectFundFee::deserialize(&mut &__ix_data[..])
                .map_err(|_| {
                    anchor_lang::error::ErrorCode::InstructionDidNotDeserialize
                })?;
            let instruction::CollectFundFee { amount_0_requested, amount_1_requested } = ix;
            let mut __bumps = <CollectFundFee as anchor_lang::Bumps>::Bumps::default();
            let mut __reallocs = std::collections::BTreeSet::new();
            let mut __remaining_accounts: &[AccountInfo] = __accounts;
            let mut __accounts = CollectFundFee::try_accounts(
                __program_id,
                &mut __remaining_accounts,
                __ix_data,
                &mut __bumps,
                &mut __reallocs,
            )?;
            let __bumps_for_finalize = __bumps.clone();
            let result = raydium_cp_swap::collect_fund_fee(
                anchor_lang::context::Context::new(
                    __program_id,
                    &mut __accounts,
                    __remaining_accounts,
                    __bumps,
                ),
                amount_0_requested,
                amount_1_requested,
            )?;
            anchor_lang::AccountsFinalize::finalize(
                &mut __accounts,
                __program_id,
                __remaining_accounts,
                __ix_data,
                &__bumps_for_finalize,
            )?;
            __accounts.exit(__program_id)
        }
        #[inline(never)]
        pub fn initialize<'info>(
            __program_id: &Pubkey,
            __accounts: &'info [AccountInfo<'info>],
            __ix_data: &[u8],
        ) -> anchor_lang::Result<()> {
            ::solana_msg::sol_log("Instruction: Initialize");
            let ix = instruction::Initialize::deserialize(&mut &__ix_data[..])
                .map_err(|_| {
                    anchor_lang::error::ErrorCode::InstructionDidNotDeserialize
                })?;
            let instruction::Initialize {
                init_amount_0,
                init_amount_1,
                open_time,
                compression_params,
            } = ix;
            let mut __bumps = <Initialize as anchor_lang::Bumps>::Bumps::default();
            let mut __reallocs = std::collections::BTreeSet::new();
            let mut __remaining_accounts: &[AccountInfo] = __accounts;
            let mut __accounts = Initialize::try_accounts(
                __program_id,
                &mut __remaining_accounts,
                __ix_data,
                &mut __bumps,
                &mut __reallocs,
            )?;
            let __bumps_for_finalize = __bumps.clone();
            let result = raydium_cp_swap::initialize(
                anchor_lang::context::Context::new(
                    __program_id,
                    &mut __accounts,
                    __remaining_accounts,
                    __bumps,
                ),
                init_amount_0,
                init_amount_1,
                open_time,
                compression_params,
            )?;
            anchor_lang::AccountsFinalize::finalize(
                &mut __accounts,
                __program_id,
                __remaining_accounts,
                __ix_data,
                &__bumps_for_finalize,
            )?;
            __accounts.exit(__program_id)
        }
        #[inline(never)]
        pub fn deposit<'info>(
            __program_id: &Pubkey,
            __accounts: &'info [AccountInfo<'info>],
            __ix_data: &[u8],
        ) -> anchor_lang::Result<()> {
            ::solana_msg::sol_log("Instruction: Deposit");
            let ix = instruction::Deposit::deserialize(&mut &__ix_data[..])
                .map_err(|_| {
                    anchor_lang::error::ErrorCode::InstructionDidNotDeserialize
                })?;
            let instruction::Deposit {
                lp_token_amount,
                maximum_token_0_amount,
                maximum_token_1_amount,
            } = ix;
            let mut __bumps = <Deposit as anchor_lang::Bumps>::Bumps::default();
            let mut __reallocs = std::collections::BTreeSet::new();
            let mut __remaining_accounts: &[AccountInfo] = __accounts;
            let mut __accounts = Deposit::try_accounts(
                __program_id,
                &mut __remaining_accounts,
                __ix_data,
                &mut __bumps,
                &mut __reallocs,
            )?;
            let __bumps_for_finalize = __bumps.clone();
            let result = raydium_cp_swap::deposit(
                anchor_lang::context::Context::new(
                    __program_id,
                    &mut __accounts,
                    __remaining_accounts,
                    __bumps,
                ),
                lp_token_amount,
                maximum_token_0_amount,
                maximum_token_1_amount,
            )?;
            anchor_lang::AccountsFinalize::finalize(
                &mut __accounts,
                __program_id,
                __remaining_accounts,
                __ix_data,
                &__bumps_for_finalize,
            )?;
            __accounts.exit(__program_id)
        }
        #[inline(never)]
        pub fn withdraw<'info>(
            __program_id: &Pubkey,
            __accounts: &'info [AccountInfo<'info>],
            __ix_data: &[u8],
        ) -> anchor_lang::Result<()> {
            ::solana_msg::sol_log("Instruction: Withdraw");
            let ix = instruction::Withdraw::deserialize(&mut &__ix_data[..])
                .map_err(|_| {
                    anchor_lang::error::ErrorCode::InstructionDidNotDeserialize
                })?;
            let instruction::Withdraw {
                lp_token_amount,
                minimum_token_0_amount,
                minimum_token_1_amount,
            } = ix;
            let mut __bumps = <Withdraw as anchor_lang::Bumps>::Bumps::default();
            let mut __reallocs = std::collections::BTreeSet::new();
            let mut __remaining_accounts: &[AccountInfo] = __accounts;
            let mut __accounts = Withdraw::try_accounts(
                __program_id,
                &mut __remaining_accounts,
                __ix_data,
                &mut __bumps,
                &mut __reallocs,
            )?;
            let __bumps_for_finalize = __bumps.clone();
            let result = raydium_cp_swap::withdraw(
                anchor_lang::context::Context::new(
                    __program_id,
                    &mut __accounts,
                    __remaining_accounts,
                    __bumps,
                ),
                lp_token_amount,
                minimum_token_0_amount,
                minimum_token_1_amount,
            )?;
            anchor_lang::AccountsFinalize::finalize(
                &mut __accounts,
                __program_id,
                __remaining_accounts,
                __ix_data,
                &__bumps_for_finalize,
            )?;
            __accounts.exit(__program_id)
        }
        #[inline(never)]
        pub fn swap_base_input<'info>(
            __program_id: &Pubkey,
            __accounts: &'info [AccountInfo<'info>],
            __ix_data: &[u8],
        ) -> anchor_lang::Result<()> {
            ::solana_msg::sol_log("Instruction: SwapBaseInput");
            let ix = instruction::SwapBaseInput::deserialize(&mut &__ix_data[..])
                .map_err(|_| {
                    anchor_lang::error::ErrorCode::InstructionDidNotDeserialize
                })?;
            let instruction::SwapBaseInput { amount_in, minimum_amount_out } = ix;
            let mut __bumps = <Swap as anchor_lang::Bumps>::Bumps::default();
            let mut __reallocs = std::collections::BTreeSet::new();
            let mut __remaining_accounts: &[AccountInfo] = __accounts;
            let mut __accounts = Swap::try_accounts(
                __program_id,
                &mut __remaining_accounts,
                __ix_data,
                &mut __bumps,
                &mut __reallocs,
            )?;
            let __bumps_for_finalize = __bumps.clone();
            let result = raydium_cp_swap::swap_base_input(
                anchor_lang::context::Context::new(
                    __program_id,
                    &mut __accounts,
                    __remaining_accounts,
                    __bumps,
                ),
                amount_in,
                minimum_amount_out,
            )?;
            anchor_lang::AccountsFinalize::finalize(
                &mut __accounts,
                __program_id,
                __remaining_accounts,
                __ix_data,
                &__bumps_for_finalize,
            )?;
            __accounts.exit(__program_id)
        }
        #[inline(never)]
        pub fn swap_base_output<'info>(
            __program_id: &Pubkey,
            __accounts: &'info [AccountInfo<'info>],
            __ix_data: &[u8],
        ) -> anchor_lang::Result<()> {
            ::solana_msg::sol_log("Instruction: SwapBaseOutput");
            let ix = instruction::SwapBaseOutput::deserialize(&mut &__ix_data[..])
                .map_err(|_| {
                    anchor_lang::error::ErrorCode::InstructionDidNotDeserialize
                })?;
            let instruction::SwapBaseOutput { max_amount_in, amount_out } = ix;
            let mut __bumps = <Swap as anchor_lang::Bumps>::Bumps::default();
            let mut __reallocs = std::collections::BTreeSet::new();
            let mut __remaining_accounts: &[AccountInfo] = __accounts;
            let mut __accounts = Swap::try_accounts(
                __program_id,
                &mut __remaining_accounts,
                __ix_data,
                &mut __bumps,
                &mut __reallocs,
            )?;
            let __bumps_for_finalize = __bumps.clone();
            let result = raydium_cp_swap::swap_base_output(
                anchor_lang::context::Context::new(
                    __program_id,
                    &mut __accounts,
                    __remaining_accounts,
                    __bumps,
                ),
                max_amount_in,
                amount_out,
            )?;
            anchor_lang::AccountsFinalize::finalize(
                &mut __accounts,
                __program_id,
                __remaining_accounts,
                __ix_data,
                &__bumps_for_finalize,
            )?;
            __accounts.exit(__program_id)
        }
        #[inline(never)]
        pub fn decompress_accounts_idempotent<'info>(
            __program_id: &Pubkey,
            __accounts: &'info [AccountInfo<'info>],
            __ix_data: &[u8],
        ) -> anchor_lang::Result<()> {
            ::solana_msg::sol_log("Instruction: DecompressAccountsIdempotent");
            let ix = instruction::DecompressAccountsIdempotent::deserialize(
                    &mut &__ix_data[..],
                )
                .map_err(|_| {
                    anchor_lang::error::ErrorCode::InstructionDidNotDeserialize
                })?;
            let instruction::DecompressAccountsIdempotent {
                proof,
                compressed_accounts,
                system_accounts_offset,
            } = ix;
            let mut __bumps = <DecompressAccountsIdempotent as anchor_lang::Bumps>::Bumps::default();
            let mut __reallocs = std::collections::BTreeSet::new();
            let mut __remaining_accounts: &[AccountInfo] = __accounts;
            let mut __accounts = DecompressAccountsIdempotent::try_accounts(
                __program_id,
                &mut __remaining_accounts,
                __ix_data,
                &mut __bumps,
                &mut __reallocs,
            )?;
            let __bumps_for_finalize = __bumps.clone();
            let result = raydium_cp_swap::decompress_accounts_idempotent(
                anchor_lang::context::Context::new(
                    __program_id,
                    &mut __accounts,
                    __remaining_accounts,
                    __bumps,
                ),
                proof,
                compressed_accounts,
                system_accounts_offset,
            )?;
            anchor_lang::AccountsFinalize::finalize(
                &mut __accounts,
                __program_id,
                __remaining_accounts,
                __ix_data,
                &__bumps_for_finalize,
            )?;
            __accounts.exit(__program_id)
        }
        #[inline(never)]
        pub fn compress_accounts_idempotent<'info>(
            __program_id: &Pubkey,
            __accounts: &'info [AccountInfo<'info>],
            __ix_data: &[u8],
        ) -> anchor_lang::Result<()> {
            ::solana_msg::sol_log("Instruction: CompressAccountsIdempotent");
            let ix = instruction::CompressAccountsIdempotent::deserialize(
                    &mut &__ix_data[..],
                )
                .map_err(|_| {
                    anchor_lang::error::ErrorCode::InstructionDidNotDeserialize
                })?;
            let instruction::CompressAccountsIdempotent {
                proof,
                compressed_accounts,
                signer_seeds,
                system_accounts_offset,
            } = ix;
            let mut __bumps = <CompressAccountsIdempotent as anchor_lang::Bumps>::Bumps::default();
            let mut __reallocs = std::collections::BTreeSet::new();
            let mut __remaining_accounts: &[AccountInfo] = __accounts;
            let mut __accounts = CompressAccountsIdempotent::try_accounts(
                __program_id,
                &mut __remaining_accounts,
                __ix_data,
                &mut __bumps,
                &mut __reallocs,
            )?;
            let __bumps_for_finalize = __bumps.clone();
            let result = raydium_cp_swap::compress_accounts_idempotent(
                anchor_lang::context::Context::new(
                    __program_id,
                    &mut __accounts,
                    __remaining_accounts,
                    __bumps,
                ),
                proof,
                compressed_accounts,
                signer_seeds,
                system_accounts_offset,
            )?;
            anchor_lang::AccountsFinalize::finalize(
                &mut __accounts,
                __program_id,
                __remaining_accounts,
                __ix_data,
                &__bumps_for_finalize,
            )?;
            __accounts.exit(__program_id)
        }
        #[inline(never)]
        pub fn initialize_compression_config<'info>(
            __program_id: &Pubkey,
            __accounts: &'info [AccountInfo<'info>],
            __ix_data: &[u8],
        ) -> anchor_lang::Result<()> {
            ::solana_msg::sol_log("Instruction: InitializeCompressionConfig");
            let ix = instruction::InitializeCompressionConfig::deserialize(
                    &mut &__ix_data[..],
                )
                .map_err(|_| {
                    anchor_lang::error::ErrorCode::InstructionDidNotDeserialize
                })?;
            let instruction::InitializeCompressionConfig {
                compression_delay,
                rent_recipient,
                address_space,
            } = ix;
            let mut __bumps = <InitializeCompressionConfig as anchor_lang::Bumps>::Bumps::default();
            let mut __reallocs = std::collections::BTreeSet::new();
            let mut __remaining_accounts: &[AccountInfo] = __accounts;
            let mut __accounts = InitializeCompressionConfig::try_accounts(
                __program_id,
                &mut __remaining_accounts,
                __ix_data,
                &mut __bumps,
                &mut __reallocs,
            )?;
            let __bumps_for_finalize = __bumps.clone();
            let result = raydium_cp_swap::initialize_compression_config(
                anchor_lang::context::Context::new(
                    __program_id,
                    &mut __accounts,
                    __remaining_accounts,
                    __bumps,
                ),
                compression_delay,
                rent_recipient,
                address_space,
            )?;
            anchor_lang::AccountsFinalize::finalize(
                &mut __accounts,
                __program_id,
                __remaining_accounts,
                __ix_data,
                &__bumps_for_finalize,
            )?;
            __accounts.exit(__program_id)
        }
        #[inline(never)]
        pub fn update_compression_config<'info>(
            __program_id: &Pubkey,
            __accounts: &'info [AccountInfo<'info>],
            __ix_data: &[u8],
        ) -> anchor_lang::Result<()> {
            ::solana_msg::sol_log("Instruction: UpdateCompressionConfig");
            let ix = instruction::UpdateCompressionConfig::deserialize(
                    &mut &__ix_data[..],
                )
                .map_err(|_| {
                    anchor_lang::error::ErrorCode::InstructionDidNotDeserialize
                })?;
            let instruction::UpdateCompressionConfig {
                new_compression_delay,
                new_rent_recipient,
                new_address_space,
                new_update_authority,
            } = ix;
            let mut __bumps = <UpdateCompressionConfig as anchor_lang::Bumps>::Bumps::default();
            let mut __reallocs = std::collections::BTreeSet::new();
            let mut __remaining_accounts: &[AccountInfo] = __accounts;
            let mut __accounts = UpdateCompressionConfig::try_accounts(
                __program_id,
                &mut __remaining_accounts,
                __ix_data,
                &mut __bumps,
                &mut __reallocs,
            )?;
            let __bumps_for_finalize = __bumps.clone();
            let result = raydium_cp_swap::update_compression_config(
                anchor_lang::context::Context::new(
                    __program_id,
                    &mut __accounts,
                    __remaining_accounts,
                    __bumps,
                ),
                new_compression_delay,
                new_rent_recipient,
                new_address_space,
                new_update_authority,
            )?;
            anchor_lang::AccountsFinalize::finalize(
                &mut __accounts,
                __program_id,
                __remaining_accounts,
                __ix_data,
                &__bumps_for_finalize,
            )?;
            __accounts.exit(__program_id)
        }
    }
}
#[allow(non_snake_case)]
/// ZK Compression: Auto-generates compress/decompress instructions for the
/// specified accounts. Derives decompress_accounts_idempotent,
/// compress_accounts_idempotent, initialize_compression_config, and
/// update_compression_config, as well as all relevant structs. Everything is
/// auto-added to the program IDL for consumption by clients.
pub mod raydium_cp_swap {
    use super::*;
    /// # Arguments
    ///
    /// * `ctx`- The accounts needed by instruction.
    /// * `index` - The index of amm config, there may be multiple config.
    /// * `trade_fee_rate` - Trade fee rate, can be changed.
    /// * `protocol_fee_rate` - The rate of protocol fee within trade fee.
    /// * `fund_fee_rate` - The rate of fund fee within trade fee.
    ///
    pub fn create_amm_config(
        ctx: Context<CreateAmmConfig>,
        index: u16,
        trade_fee_rate: u64,
        protocol_fee_rate: u64,
        fund_fee_rate: u64,
        create_pool_fee: u64,
    ) -> Result<()> {
        {
            match trade_fee_rate < FEE_RATE_DENOMINATOR_VALUE {
                true => {}
                _ => {
                    ::core::panicking::panic(
                        "assertion failed: trade_fee_rate < FEE_RATE_DENOMINATOR_VALUE",
                    )
                }
            }
        };
        {
            match protocol_fee_rate <= FEE_RATE_DENOMINATOR_VALUE {
                true => {}
                _ => {
                    ::core::panicking::panic(
                        "assertion failed: protocol_fee_rate <= FEE_RATE_DENOMINATOR_VALUE",
                    )
                }
            }
        };
        {
            match fund_fee_rate <= FEE_RATE_DENOMINATOR_VALUE {
                true => {}
                _ => {
                    ::core::panicking::panic(
                        "assertion failed: fund_fee_rate <= FEE_RATE_DENOMINATOR_VALUE",
                    )
                }
            }
        };
        {
            match fund_fee_rate + protocol_fee_rate <= FEE_RATE_DENOMINATOR_VALUE {
                true => {}
                _ => {
                    ::core::panicking::panic(
                        "assertion failed: fund_fee_rate + protocol_fee_rate <= FEE_RATE_DENOMINATOR_VALUE",
                    )
                }
            }
        };
        instructions::create_amm_config(
            ctx,
            index,
            trade_fee_rate,
            protocol_fee_rate,
            fund_fee_rate,
            create_pool_fee,
        )
    }
    /// Updates the owner of the amm config
    /// Must be called by the current owner or admin
    ///
    /// # Arguments
    ///
    /// * `ctx`- The context of accounts
    /// * `trade_fee_rate`- The new trade fee rate of amm config, be set when `param` is 0
    /// * `protocol_fee_rate`- The new protocol fee rate of amm config, be set when `param` is 1
    /// * `fund_fee_rate`- The new fund fee rate of amm config, be set when `param` is 2
    /// * `new_owner`- The config's new owner, be set when `param` is 3
    /// * `new_fund_owner`- The config's new fund owner, be set when `param` is 4
    /// * `param`- The value can be 0 | 1 | 2 | 3 | 4, otherwise will report a error
    ///
    pub fn update_amm_config(
        ctx: Context<UpdateAmmConfig>,
        param: u8,
        value: u64,
    ) -> Result<()> {
        instructions::update_amm_config(ctx, param, value)
    }
    /// Update pool status for given value
    ///
    /// # Arguments
    ///
    /// * `ctx`- The context of accounts
    /// * `status` - The value of status
    ///
    pub fn update_pool_status(ctx: Context<UpdatePoolStatus>, status: u8) -> Result<()> {
        instructions::update_pool_status(ctx, status)
    }
    /// Collect the protocol fee accrued to the pool
    ///
    /// # Arguments
    ///
    /// * `ctx` - The context of accounts
    /// * `amount_0_requested` - The maximum amount of token_0 to send, can be 0 to collect fees in only token_1
    /// * `amount_1_requested` - The maximum amount of token_1 to send, can be 0 to collect fees in only token_0
    ///
    pub fn collect_protocol_fee(
        ctx: Context<CollectProtocolFee>,
        amount_0_requested: u64,
        amount_1_requested: u64,
    ) -> Result<()> {
        instructions::collect_protocol_fee(ctx, amount_0_requested, amount_1_requested)
    }
    /// Collect the fund fee accrued to the pool
    ///
    /// # Arguments
    ///
    /// * `ctx` - The context of accounts
    /// * `amount_0_requested` - The maximum amount of token_0 to send, can be 0 to collect fees in only token_1
    /// * `amount_1_requested` - The maximum amount of token_1 to send, can be 0 to collect fees in only token_0
    ///
    pub fn collect_fund_fee(
        ctx: Context<CollectFundFee>,
        amount_0_requested: u64,
        amount_1_requested: u64,
    ) -> Result<()> {
        instructions::collect_fund_fee(ctx, amount_0_requested, amount_1_requested)
    }
    /// Creates a pool for the given token pair and the initial price
    ///
    /// # Arguments
    ///
    /// * `ctx`- The context of accounts
    /// * `init_amount_0` - the initial amount_0 to deposit
    /// * `init_amount_1` - the initial amount_1 to deposit
    /// * `open_time` - the timestamp allowed for swap
    ///
    pub fn initialize<'info>(
        ctx: Context<'_, '_, '_, 'info, Initialize<'info>>,
        init_amount_0: u64,
        init_amount_1: u64,
        open_time: u64,
        compression_params: InitializeCompressionParams,
    ) -> Result<()> {
        instructions::initialize(
            ctx,
            init_amount_0,
            init_amount_1,
            open_time,
            compression_params,
        )
    }
    /// Deposit lp token to the pool
    ///
    /// # Arguments
    ///
    /// * `ctx`- The context of accounts
    /// * `lp_token_amount` - Pool token amount to transfer. token_a and token_b amount are set by the current exchange rate and size of the pool
    /// * `maximum_token_0_amount` -  Maximum token 0 amount to deposit, prevents excessive slippage
    /// * `maximum_token_1_amount` - Maximum token 1 amount to deposit, prevents excessive slippage
    ///
    pub fn deposit(
        ctx: Context<Deposit>,
        lp_token_amount: u64,
        maximum_token_0_amount: u64,
        maximum_token_1_amount: u64,
    ) -> Result<()> {
        instructions::deposit(
            ctx,
            lp_token_amount,
            maximum_token_0_amount,
            maximum_token_1_amount,
        )
    }
    /// Withdraw lp for token0 and token1
    ///
    /// # Arguments
    ///
    /// * `ctx`- The context of accounts
    /// * `lp_token_amount` - Amount of pool tokens to burn. User receives an output of token a and b based on the percentage of the pool tokens that are returned.
    /// * `minimum_token_0_amount` -  Minimum amount of token 0 to receive, prevents excessive slippage
    /// * `minimum_token_1_amount` -  Minimum amount of token 1 to receive, prevents excessive slippage
    ///
    pub fn withdraw(
        ctx: Context<Withdraw>,
        lp_token_amount: u64,
        minimum_token_0_amount: u64,
        minimum_token_1_amount: u64,
    ) -> Result<()> {
        instructions::withdraw(
            ctx,
            lp_token_amount,
            minimum_token_0_amount,
            minimum_token_1_amount,
        )
    }
    /// Swap the tokens in the pool base input amount
    ///
    /// # Arguments
    ///
    /// * `ctx`- The context of accounts
    /// * `amount_in` -  input amount to transfer, output to DESTINATION is based on the exchange rate
    /// * `minimum_amount_out` -  Minimum amount of output token, prevents excessive slippage
    ///
    pub fn swap_base_input(
        ctx: Context<Swap>,
        amount_in: u64,
        minimum_amount_out: u64,
    ) -> Result<()> {
        instructions::swap_base_input(ctx, amount_in, minimum_amount_out)
    }
    /// Swap the tokens in the pool base output amount
    ///
    /// # Arguments
    ///
    /// * `ctx`- The context of accounts
    /// * `max_amount_in` -  input amount prevents excessive slippage
    /// * `amount_out` -  amount of output token
    ///
    pub fn swap_base_output(
        ctx: Context<Swap>,
        max_amount_in: u64,
        amount_out: u64,
    ) -> Result<()> {
        instructions::swap_base_output(ctx, max_amount_in, amount_out)
    }
    pub struct DecompressAccountsIdempotent<'info> {
        #[account(mut)]
        pub fee_payer: Signer<'info>,
        /// The global config account
        /// CHECK: load_checked.
        pub config: AccountInfo<'info>,
        /// UNCHECKED: Anyone can pay to init PDAs.
        #[account(mut)]
        pub rent_payer: Signer<'info>,
        /// UNCHECKED: Anyone can pay to init compressed tokens.
        #[account(mut)]
        pub ctoken_rent_sponsor: AccountInfo<'info>,
        /// Compressed token program (always required in mixed variant)
        /// CHECK: Program ID validated to be cTokenmWW8bLPjZEBAUgYy3zKxQZW6VKi7bqNFEVv3m
        pub ctoken_program: UncheckedAccount<'info>,
        /// CPI authority PDA of the compressed token program (always required in mixed variant)
        /// CHECK: PDA derivation validated with seeds ["cpi_authority"] and bump 254
        pub ctoken_cpi_authority: UncheckedAccount<'info>,
        /// CHECK: CToken CompressibleConfig account
        pub ctoken_config: UncheckedAccount<'info>,
    }
    #[automatically_derived]
    impl<'info> anchor_lang::Accounts<'info, DecompressAccountsIdempotentBumps>
    for DecompressAccountsIdempotent<'info>
    where
        'info: 'info,
    {
        #[inline(never)]
        fn try_accounts(
            __program_id: &anchor_lang::solana_program::pubkey::Pubkey,
            __accounts: &mut &'info [anchor_lang::solana_program::account_info::AccountInfo<
                'info,
            >],
            __ix_data: &[u8],
            __bumps: &mut DecompressAccountsIdempotentBumps,
            __reallocs: &mut std::collections::BTreeSet<
                anchor_lang::solana_program::pubkey::Pubkey,
            >,
        ) -> anchor_lang::Result<Self> {
            let fee_payer: Signer = anchor_lang::Accounts::try_accounts(
                    __program_id,
                    __accounts,
                    __ix_data,
                    __bumps,
                    __reallocs,
                )
                .map_err(|e| e.with_account_name("fee_payer"))?;
            let config: AccountInfo = anchor_lang::Accounts::try_accounts(
                    __program_id,
                    __accounts,
                    __ix_data,
                    __bumps,
                    __reallocs,
                )
                .map_err(|e| e.with_account_name("config"))?;
            let rent_payer: Signer = anchor_lang::Accounts::try_accounts(
                    __program_id,
                    __accounts,
                    __ix_data,
                    __bumps,
                    __reallocs,
                )
                .map_err(|e| e.with_account_name("rent_payer"))?;
            let ctoken_rent_sponsor: AccountInfo = anchor_lang::Accounts::try_accounts(
                    __program_id,
                    __accounts,
                    __ix_data,
                    __bumps,
                    __reallocs,
                )
                .map_err(|e| e.with_account_name("ctoken_rent_sponsor"))?;
            let ctoken_program: UncheckedAccount = anchor_lang::Accounts::try_accounts(
                    __program_id,
                    __accounts,
                    __ix_data,
                    __bumps,
                    __reallocs,
                )
                .map_err(|e| e.with_account_name("ctoken_program"))?;
            let ctoken_cpi_authority: UncheckedAccount = anchor_lang::Accounts::try_accounts(
                    __program_id,
                    __accounts,
                    __ix_data,
                    __bumps,
                    __reallocs,
                )
                .map_err(|e| e.with_account_name("ctoken_cpi_authority"))?;
            let ctoken_config: UncheckedAccount = anchor_lang::Accounts::try_accounts(
                    __program_id,
                    __accounts,
                    __ix_data,
                    __bumps,
                    __reallocs,
                )
                .map_err(|e| e.with_account_name("ctoken_config"))?;
            if !AsRef::<AccountInfo>::as_ref(&fee_payer).is_writable {
                return Err(
                    anchor_lang::error::Error::from(
                            anchor_lang::error::ErrorCode::ConstraintMut,
                        )
                        .with_account_name("fee_payer"),
                );
            }
            if !AsRef::<AccountInfo>::as_ref(&rent_payer).is_writable {
                return Err(
                    anchor_lang::error::Error::from(
                            anchor_lang::error::ErrorCode::ConstraintMut,
                        )
                        .with_account_name("rent_payer"),
                );
            }
            if !&ctoken_rent_sponsor.is_writable {
                return Err(
                    anchor_lang::error::Error::from(
                            anchor_lang::error::ErrorCode::ConstraintMut,
                        )
                        .with_account_name("ctoken_rent_sponsor"),
                );
            }
            Ok(DecompressAccountsIdempotent {
                fee_payer,
                config,
                rent_payer,
                ctoken_rent_sponsor,
                ctoken_program,
                ctoken_cpi_authority,
                ctoken_config,
            })
        }
    }
    #[automatically_derived]
    impl<'info> anchor_lang::ToAccountInfos<'info>
    for DecompressAccountsIdempotent<'info>
    where
        'info: 'info,
    {
        fn to_account_infos(
            &self,
        ) -> Vec<anchor_lang::solana_program::account_info::AccountInfo<'info>> {
            let mut account_infos = ::alloc::vec::Vec::new();
            account_infos.extend(self.fee_payer.to_account_infos());
            account_infos.extend(self.config.to_account_infos());
            account_infos.extend(self.rent_payer.to_account_infos());
            account_infos.extend(self.ctoken_rent_sponsor.to_account_infos());
            account_infos.extend(self.ctoken_program.to_account_infos());
            account_infos.extend(self.ctoken_cpi_authority.to_account_infos());
            account_infos.extend(self.ctoken_config.to_account_infos());
            account_infos
        }
    }
    #[automatically_derived]
    impl<'info> anchor_lang::ToAccountMetas for DecompressAccountsIdempotent<'info> {
        fn to_account_metas(
            &self,
            is_signer: Option<bool>,
        ) -> Vec<anchor_lang::solana_program::instruction::AccountMeta> {
            let mut account_metas = ::alloc::vec::Vec::new();
            account_metas.extend(self.fee_payer.to_account_metas(None));
            account_metas.extend(self.config.to_account_metas(None));
            account_metas.extend(self.rent_payer.to_account_metas(None));
            account_metas.extend(self.ctoken_rent_sponsor.to_account_metas(None));
            account_metas.extend(self.ctoken_program.to_account_metas(None));
            account_metas.extend(self.ctoken_cpi_authority.to_account_metas(None));
            account_metas.extend(self.ctoken_config.to_account_metas(None));
            account_metas
        }
    }
    #[automatically_derived]
    impl<'info> anchor_lang::AccountsFinalize<'info, DecompressAccountsIdempotentBumps>
    for DecompressAccountsIdempotent<'info>
    where
        'info: 'info,
    {
        fn finalize(
            &mut self,
            program_id: &anchor_lang::solana_program::pubkey::Pubkey,
            _remaining: &[anchor_lang::solana_program::account_info::AccountInfo<'info>],
            _ix_data: &[u8],
            _bumps: &DecompressAccountsIdempotentBumps,
        ) -> anchor_lang::Result<()> {
            Ok(())
        }
    }
    #[automatically_derived]
    impl<'info> anchor_lang::AccountsExit<'info> for DecompressAccountsIdempotent<'info>
    where
        'info: 'info,
    {
        fn exit(
            &self,
            program_id: &anchor_lang::solana_program::pubkey::Pubkey,
        ) -> anchor_lang::Result<()> {
            anchor_lang::AccountsExit::exit(&self.fee_payer, program_id)
                .map_err(|e| e.with_account_name("fee_payer"))?;
            anchor_lang::AccountsExit::exit(&self.rent_payer, program_id)
                .map_err(|e| e.with_account_name("rent_payer"))?;
            anchor_lang::AccountsExit::exit(&self.ctoken_rent_sponsor, program_id)
                .map_err(|e| e.with_account_name("ctoken_rent_sponsor"))?;
            Ok(())
        }
    }
    pub struct DecompressAccountsIdempotentBumps {}
    #[automatically_derived]
    impl ::core::fmt::Debug for DecompressAccountsIdempotentBumps {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::write_str(f, "DecompressAccountsIdempotentBumps")
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for DecompressAccountsIdempotentBumps {
        #[inline]
        fn clone(&self) -> DecompressAccountsIdempotentBumps {
            DecompressAccountsIdempotentBumps {
            }
        }
    }
    impl Default for DecompressAccountsIdempotentBumps {
        fn default() -> Self {
            DecompressAccountsIdempotentBumps {
            }
        }
    }
    impl<'info> anchor_lang::Bumps for DecompressAccountsIdempotent<'info>
    where
        'info: 'info,
    {
        type Bumps = DecompressAccountsIdempotentBumps;
    }
    /// An internal, Anchor generated module. This is used (as an
    /// implementation detail), to generate a struct for a given
    /// `#[derive(Accounts)]` implementation, where each field is a Pubkey,
    /// instead of an `AccountInfo`. This is useful for clients that want
    /// to generate a list of accounts, without explicitly knowing the
    /// order all the fields should be in.
    ///
    /// To access the struct in this module, one should use the sibling
    /// `accounts` module (also generated), which re-exports this.
    pub(crate) mod __client_accounts_decompress_accounts_idempotent {
        use super::*;
        use anchor_lang::prelude::borsh;
        /// Generated client accounts for [`DecompressAccountsIdempotent`].
        pub struct DecompressAccountsIdempotent {
            pub fee_payer: Pubkey,
            ///The global config account
            pub config: Pubkey,
            ///UNCHECKED: Anyone can pay to init PDAs.
            pub rent_payer: Pubkey,
            ///UNCHECKED: Anyone can pay to init compressed tokens.
            pub ctoken_rent_sponsor: Pubkey,
            ///Compressed token program (always required in mixed variant)
            pub ctoken_program: Pubkey,
            ///CPI authority PDA of the compressed token program (always required in mixed variant)
            pub ctoken_cpi_authority: Pubkey,
            pub ctoken_config: Pubkey,
        }
        impl borsh::ser::BorshSerialize for DecompressAccountsIdempotent
        where
            Pubkey: borsh::ser::BorshSerialize,
            Pubkey: borsh::ser::BorshSerialize,
            Pubkey: borsh::ser::BorshSerialize,
            Pubkey: borsh::ser::BorshSerialize,
            Pubkey: borsh::ser::BorshSerialize,
            Pubkey: borsh::ser::BorshSerialize,
            Pubkey: borsh::ser::BorshSerialize,
        {
            fn serialize<W: borsh::maybestd::io::Write>(
                &self,
                writer: &mut W,
            ) -> ::core::result::Result<(), borsh::maybestd::io::Error> {
                borsh::BorshSerialize::serialize(&self.fee_payer, writer)?;
                borsh::BorshSerialize::serialize(&self.config, writer)?;
                borsh::BorshSerialize::serialize(&self.rent_payer, writer)?;
                borsh::BorshSerialize::serialize(&self.ctoken_rent_sponsor, writer)?;
                borsh::BorshSerialize::serialize(&self.ctoken_program, writer)?;
                borsh::BorshSerialize::serialize(&self.ctoken_cpi_authority, writer)?;
                borsh::BorshSerialize::serialize(&self.ctoken_config, writer)?;
                Ok(())
            }
        }
        impl anchor_lang::idl::build::IdlBuild for DecompressAccountsIdempotent {
            fn create_type() -> Option<anchor_lang::idl::types::IdlTypeDef> {
                Some(anchor_lang::idl::types::IdlTypeDef {
                    name: Self::get_full_path(),
                    docs: <[_]>::into_vec(
                        ::alloc::boxed::box_new([
                            "Generated client accounts for [`DecompressAccountsIdempotent`]."
                                .into(),
                        ]),
                    ),
                    serialization: anchor_lang::idl::types::IdlSerialization::default(),
                    repr: None,
                    generics: ::alloc::vec::Vec::new(),
                    ty: anchor_lang::idl::types::IdlTypeDefTy::Struct {
                        fields: Some(
                            anchor_lang::idl::types::IdlDefinedFields::Named(
                                <[_]>::into_vec(
                                    ::alloc::boxed::box_new([
                                        anchor_lang::idl::types::IdlField {
                                            name: "fee_payer".into(),
                                            docs: ::alloc::vec::Vec::new(),
                                            ty: anchor_lang::idl::types::IdlType::Pubkey,
                                        },
                                        anchor_lang::idl::types::IdlField {
                                            name: "config".into(),
                                            docs: <[_]>::into_vec(
                                                ::alloc::boxed::box_new([
                                                    "The global config account".into(),
                                                ]),
                                            ),
                                            ty: anchor_lang::idl::types::IdlType::Pubkey,
                                        },
                                        anchor_lang::idl::types::IdlField {
                                            name: "rent_payer".into(),
                                            docs: <[_]>::into_vec(
                                                ::alloc::boxed::box_new([
                                                    "UNCHECKED: Anyone can pay to init PDAs.".into(),
                                                ]),
                                            ),
                                            ty: anchor_lang::idl::types::IdlType::Pubkey,
                                        },
                                        anchor_lang::idl::types::IdlField {
                                            name: "ctoken_rent_sponsor".into(),
                                            docs: <[_]>::into_vec(
                                                ::alloc::boxed::box_new([
                                                    "UNCHECKED: Anyone can pay to init compressed tokens."
                                                        .into(),
                                                ]),
                                            ),
                                            ty: anchor_lang::idl::types::IdlType::Pubkey,
                                        },
                                        anchor_lang::idl::types::IdlField {
                                            name: "ctoken_program".into(),
                                            docs: <[_]>::into_vec(
                                                ::alloc::boxed::box_new([
                                                    "Compressed token program (always required in mixed variant)"
                                                        .into(),
                                                ]),
                                            ),
                                            ty: anchor_lang::idl::types::IdlType::Pubkey,
                                        },
                                        anchor_lang::idl::types::IdlField {
                                            name: "ctoken_cpi_authority".into(),
                                            docs: <[_]>::into_vec(
                                                ::alloc::boxed::box_new([
                                                    "CPI authority PDA of the compressed token program (always required in mixed variant)"
                                                        .into(),
                                                ]),
                                            ),
                                            ty: anchor_lang::idl::types::IdlType::Pubkey,
                                        },
                                        anchor_lang::idl::types::IdlField {
                                            name: "ctoken_config".into(),
                                            docs: ::alloc::vec::Vec::new(),
                                            ty: anchor_lang::idl::types::IdlType::Pubkey,
                                        },
                                    ]),
                                ),
                            ),
                        ),
                    },
                })
            }
            fn insert_types(
                types: &mut std::collections::BTreeMap<
                    String,
                    anchor_lang::idl::types::IdlTypeDef,
                >,
            ) {}
            fn get_full_path() -> String {
                ::alloc::__export::must_use({
                    ::alloc::fmt::format(
                        format_args!(
                            "{0}::{1}",
                            "raydium_cp_swap::raydium_cp_swap::__client_accounts_decompress_accounts_idempotent",
                            "DecompressAccountsIdempotent",
                        ),
                    )
                })
            }
        }
        #[automatically_derived]
        impl anchor_lang::ToAccountMetas for DecompressAccountsIdempotent {
            fn to_account_metas(
                &self,
                is_signer: Option<bool>,
            ) -> Vec<anchor_lang::solana_program::instruction::AccountMeta> {
                let mut account_metas = ::alloc::vec::Vec::new();
                account_metas
                    .push(
                        anchor_lang::solana_program::instruction::AccountMeta::new(
                            self.fee_payer,
                            true,
                        ),
                    );
                account_metas
                    .push(
                        anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                            self.config,
                            false,
                        ),
                    );
                account_metas
                    .push(
                        anchor_lang::solana_program::instruction::AccountMeta::new(
                            self.rent_payer,
                            true,
                        ),
                    );
                account_metas
                    .push(
                        anchor_lang::solana_program::instruction::AccountMeta::new(
                            self.ctoken_rent_sponsor,
                            false,
                        ),
                    );
                account_metas
                    .push(
                        anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                            self.ctoken_program,
                            false,
                        ),
                    );
                account_metas
                    .push(
                        anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                            self.ctoken_cpi_authority,
                            false,
                        ),
                    );
                account_metas
                    .push(
                        anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                            self.ctoken_config,
                            false,
                        ),
                    );
                account_metas
            }
        }
    }
    /// An internal, Anchor generated module. This is used (as an
    /// implementation detail), to generate a CPI struct for a given
    /// `#[derive(Accounts)]` implementation, where each field is an
    /// AccountInfo.
    ///
    /// To access the struct in this module, one should use the sibling
    /// [`cpi::accounts`] module (also generated), which re-exports this.
    pub(crate) mod __cpi_client_accounts_decompress_accounts_idempotent {
        use super::*;
        /// Generated CPI struct of the accounts for [`DecompressAccountsIdempotent`].
        pub struct DecompressAccountsIdempotent<'info> {
            pub fee_payer: anchor_lang::solana_program::account_info::AccountInfo<'info>,
            ///The global config account
            pub config: anchor_lang::solana_program::account_info::AccountInfo<'info>,
            ///UNCHECKED: Anyone can pay to init PDAs.
            pub rent_payer: anchor_lang::solana_program::account_info::AccountInfo<
                'info,
            >,
            ///UNCHECKED: Anyone can pay to init compressed tokens.
            pub ctoken_rent_sponsor: anchor_lang::solana_program::account_info::AccountInfo<
                'info,
            >,
            ///Compressed token program (always required in mixed variant)
            pub ctoken_program: anchor_lang::solana_program::account_info::AccountInfo<
                'info,
            >,
            ///CPI authority PDA of the compressed token program (always required in mixed variant)
            pub ctoken_cpi_authority: anchor_lang::solana_program::account_info::AccountInfo<
                'info,
            >,
            pub ctoken_config: anchor_lang::solana_program::account_info::AccountInfo<
                'info,
            >,
        }
        #[automatically_derived]
        impl<'info> anchor_lang::ToAccountMetas for DecompressAccountsIdempotent<'info> {
            fn to_account_metas(
                &self,
                is_signer: Option<bool>,
            ) -> Vec<anchor_lang::solana_program::instruction::AccountMeta> {
                let mut account_metas = ::alloc::vec::Vec::new();
                account_metas
                    .push(
                        anchor_lang::solana_program::instruction::AccountMeta::new(
                            anchor_lang::Key::key(&self.fee_payer),
                            true,
                        ),
                    );
                account_metas
                    .push(
                        anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                            anchor_lang::Key::key(&self.config),
                            false,
                        ),
                    );
                account_metas
                    .push(
                        anchor_lang::solana_program::instruction::AccountMeta::new(
                            anchor_lang::Key::key(&self.rent_payer),
                            true,
                        ),
                    );
                account_metas
                    .push(
                        anchor_lang::solana_program::instruction::AccountMeta::new(
                            anchor_lang::Key::key(&self.ctoken_rent_sponsor),
                            false,
                        ),
                    );
                account_metas
                    .push(
                        anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                            anchor_lang::Key::key(&self.ctoken_program),
                            false,
                        ),
                    );
                account_metas
                    .push(
                        anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                            anchor_lang::Key::key(&self.ctoken_cpi_authority),
                            false,
                        ),
                    );
                account_metas
                    .push(
                        anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                            anchor_lang::Key::key(&self.ctoken_config),
                            false,
                        ),
                    );
                account_metas
            }
        }
        #[automatically_derived]
        impl<'info> anchor_lang::ToAccountInfos<'info>
        for DecompressAccountsIdempotent<'info> {
            fn to_account_infos(
                &self,
            ) -> Vec<anchor_lang::solana_program::account_info::AccountInfo<'info>> {
                let mut account_infos = ::alloc::vec::Vec::new();
                account_infos
                    .extend(
                        anchor_lang::ToAccountInfos::to_account_infos(&self.fee_payer),
                    );
                account_infos
                    .extend(anchor_lang::ToAccountInfos::to_account_infos(&self.config));
                account_infos
                    .extend(
                        anchor_lang::ToAccountInfos::to_account_infos(&self.rent_payer),
                    );
                account_infos
                    .extend(
                        anchor_lang::ToAccountInfos::to_account_infos(
                            &self.ctoken_rent_sponsor,
                        ),
                    );
                account_infos
                    .extend(
                        anchor_lang::ToAccountInfos::to_account_infos(
                            &self.ctoken_program,
                        ),
                    );
                account_infos
                    .extend(
                        anchor_lang::ToAccountInfos::to_account_infos(
                            &self.ctoken_cpi_authority,
                        ),
                    );
                account_infos
                    .extend(
                        anchor_lang::ToAccountInfos::to_account_infos(
                            &self.ctoken_config,
                        ),
                    );
                account_infos
            }
        }
    }
    impl<'info> DecompressAccountsIdempotent<'info> {
        pub fn __anchor_private_gen_idl_accounts(
            accounts: &mut std::collections::BTreeMap<
                String,
                anchor_lang::idl::types::IdlAccount,
            >,
            types: &mut std::collections::BTreeMap<
                String,
                anchor_lang::idl::types::IdlTypeDef,
            >,
        ) -> Vec<anchor_lang::idl::types::IdlInstructionAccountItem> {
            <[_]>::into_vec(
                ::alloc::boxed::box_new([
                    anchor_lang::idl::types::IdlInstructionAccountItem::Single(anchor_lang::idl::types::IdlInstructionAccount {
                        name: "fee_payer".into(),
                        docs: ::alloc::vec::Vec::new(),
                        writable: true,
                        signer: true,
                        optional: false,
                        address: None,
                        pda: None,
                        relations: ::alloc::vec::Vec::new(),
                    }),
                    anchor_lang::idl::types::IdlInstructionAccountItem::Single(anchor_lang::idl::types::IdlInstructionAccount {
                        name: "config".into(),
                        docs: <[_]>::into_vec(
                            ::alloc::boxed::box_new(["The global config account".into()]),
                        ),
                        writable: false,
                        signer: false,
                        optional: false,
                        address: None,
                        pda: None,
                        relations: ::alloc::vec::Vec::new(),
                    }),
                    anchor_lang::idl::types::IdlInstructionAccountItem::Single(anchor_lang::idl::types::IdlInstructionAccount {
                        name: "rent_payer".into(),
                        docs: <[_]>::into_vec(
                            ::alloc::boxed::box_new([
                                "UNCHECKED: Anyone can pay to init PDAs.".into(),
                            ]),
                        ),
                        writable: true,
                        signer: true,
                        optional: false,
                        address: None,
                        pda: None,
                        relations: ::alloc::vec::Vec::new(),
                    }),
                    anchor_lang::idl::types::IdlInstructionAccountItem::Single(anchor_lang::idl::types::IdlInstructionAccount {
                        name: "ctoken_rent_sponsor".into(),
                        docs: <[_]>::into_vec(
                            ::alloc::boxed::box_new([
                                "UNCHECKED: Anyone can pay to init compressed tokens."
                                    .into(),
                            ]),
                        ),
                        writable: true,
                        signer: false,
                        optional: false,
                        address: None,
                        pda: None,
                        relations: ::alloc::vec::Vec::new(),
                    }),
                    anchor_lang::idl::types::IdlInstructionAccountItem::Single(anchor_lang::idl::types::IdlInstructionAccount {
                        name: "ctoken_program".into(),
                        docs: <[_]>::into_vec(
                            ::alloc::boxed::box_new([
                                "Compressed token program (always required in mixed variant)"
                                    .into(),
                            ]),
                        ),
                        writable: false,
                        signer: false,
                        optional: false,
                        address: None,
                        pda: None,
                        relations: ::alloc::vec::Vec::new(),
                    }),
                    anchor_lang::idl::types::IdlInstructionAccountItem::Single(anchor_lang::idl::types::IdlInstructionAccount {
                        name: "ctoken_cpi_authority".into(),
                        docs: <[_]>::into_vec(
                            ::alloc::boxed::box_new([
                                "CPI authority PDA of the compressed token program (always required in mixed variant)"
                                    .into(),
                            ]),
                        ),
                        writable: false,
                        signer: false,
                        optional: false,
                        address: None,
                        pda: None,
                        relations: ::alloc::vec::Vec::new(),
                    }),
                    anchor_lang::idl::types::IdlInstructionAccountItem::Single(anchor_lang::idl::types::IdlInstructionAccount {
                        name: "ctoken_config".into(),
                        docs: ::alloc::vec::Vec::new(),
                        writable: false,
                        signer: false,
                        optional: false,
                        address: None,
                        pda: None,
                        relations: ::alloc::vec::Vec::new(),
                    }),
                ]),
            )
        }
        pub fn __anchor_private_gen_light_metadata() -> Option<
            anchor_lang::idl::types::IdlLightInstructionMeta,
        > {
            None
        }
    }
    pub(super) mod __macro_helpers {
        use super::*;
        #[inline(never)]
        fn handle_packed_PoolState<'a, 'b, 'info>(
            accounts: &DecompressAccountsIdempotent<'info>,
            cpi_accounts: &light_sdk::cpi::CpiAccountsSmall<'b, 'info>,
            address_space: anchor_lang::prelude::Pubkey,
            solana_accounts: &[anchor_lang::prelude::AccountInfo<'info>],
            remaining_accounts: &[anchor_lang::prelude::AccountInfo<'info>],
            seed_indices: &[u8],
            seed_accounts_offset: u8,
            i: usize,
            packed: &PackedPoolState,
            meta: &light_sdk::instruction::account_meta::CompressedAccountMetaNoLamportsNoAddress,
            post_system_accounts: &[anchor_lang::prelude::AccountInfo<'info>],
            compressed_pda_infos: &mut Vec<
                light_compressed_account::instruction_data::with_account_info::CompressedAccountInfo,
            >,
        ) -> Result<()> {
            let data: PoolState = <PackedPoolState as light_sdk::compressible::Unpack>::unpack(
                    packed,
                    post_system_accounts,
                )
                .map_err(anchor_lang::prelude::ProgramError::from)?;

            ::solana_msg::sol_log(&format!("debug - seed accounts offset: {:?}", seed_accounts_offset));
            let (seeds_vec, derived_pda) = {
                let seeds: &[&[u8]] = &[
                    POOL_SEED.as_bytes(),
                    remaining_accounts[(seed_accounts_offset + seed_indices[0]) as usize]
                        .key
                        .as_ref(),
                    remaining_accounts[(seed_accounts_offset + seed_indices[1]) as usize]
                        .key
                        .as_ref(),
                    remaining_accounts[(seed_accounts_offset + seed_indices[2]) as usize]
                        .key
                        .as_ref(),
                ];
                let (pda, bump) = anchor_lang::prelude::Pubkey::find_program_address(
                    seeds,
                    &crate::ID,
                );
                let mut seeds_vec = Vec::with_capacity(seeds.len() + 1);
                seeds_vec.push(seeds[0usize].to_vec());
                seeds_vec.push(seeds[1usize].to_vec());
                seeds_vec.push(seeds[2usize].to_vec());
                seeds_vec.push(seeds[3usize].to_vec());
                seeds_vec.push(<[_]>::into_vec(::alloc::boxed::box_new([bump])));
                (seeds_vec, pda)
            };
            if derived_pda != *solana_accounts[i].key {
                ::solana_msg::sol_log(
                    &::alloc::__export::must_use({
                        ::alloc::fmt::format(
                            format_args!(
                                "Derived PDA does not match account at index {0}: expected {1:?}, got {2:?}, seeds: {3:?}",
                                i,
                                solana_accounts[i].key,
                                derived_pda,
                                seeds_vec,
                            ),
                        )
                    }),
                );
            }
            let compressed_infos = {
                let seed_refs: Vec<&[u8]> = seeds_vec
                    .iter()
                    .map(|v| v.as_slice())
                    .collect();
                light_sdk::compressible::prepare_account_for_decompression_idempotent::<
                    PoolState,
                >(
                        &crate::ID,
                        data,
                        light_sdk::compressible::into_compressed_meta_with_address(
                            meta,
                            &solana_accounts[i],
                            address_space,
                            &crate::ID,
                        ),
                        &solana_accounts[i],
                        &accounts.rent_payer,
                        cpi_accounts,
                        seed_refs.as_slice(),
                    )
                    .map_err(anchor_lang::prelude::ProgramError::from)?
            };
            compressed_pda_infos.extend(compressed_infos);
            Ok(())
        }
        #[inline(never)]
        fn handle_packed_ObservationState<'a, 'b, 'info>(
            accounts: &DecompressAccountsIdempotent<'info>,
            cpi_accounts: &light_sdk::cpi::CpiAccountsSmall<'b, 'info>,
            address_space: anchor_lang::prelude::Pubkey,
            solana_accounts: &[anchor_lang::prelude::AccountInfo<'info>],
            remaining_accounts: &[anchor_lang::prelude::AccountInfo<'info>],
            seed_indices: &[u8],
            seed_accounts_offset: u8,
            i: usize,
            packed: &PackedObservationState,
            meta: &light_sdk::instruction::account_meta::CompressedAccountMetaNoLamportsNoAddress,
            post_system_accounts: &[anchor_lang::prelude::AccountInfo<'info>],
            compressed_pda_infos: &mut Vec<
                light_compressed_account::instruction_data::with_account_info::CompressedAccountInfo,
            >,
        ) -> Result<()> {
            let data: ObservationState = <PackedObservationState as light_sdk::compressible::Unpack>::unpack(
                    packed,
                    post_system_accounts,
                )
                .map_err(anchor_lang::prelude::ProgramError::from)?;
            let (seeds_vec, derived_pda) = {
                let seeds: &[&[u8]] = &[
                    OBSERVATION_SEED.as_bytes(),
                    remaining_accounts[(seed_accounts_offset + seed_indices[0]) as usize]
                        .key
                        .as_ref(),
                ];
                let (pda, bump) = anchor_lang::prelude::Pubkey::find_program_address(
                    seeds,
                    &crate::ID,
                );
                let mut seeds_vec = Vec::with_capacity(seeds.len() + 1);
                seeds_vec.push(seeds[0usize].to_vec());
                seeds_vec.push(seeds[1usize].to_vec());
                seeds_vec.push(<[_]>::into_vec(::alloc::boxed::box_new([bump])));
                (seeds_vec, pda)
            };
            if derived_pda != *solana_accounts[i].key {
                ::solana_msg::sol_log(
                    &::alloc::__export::must_use({
                        ::alloc::fmt::format(
                            format_args!(
                                "Derived PDA does not match account at index {0}: expected {1:?}, got {2:?}, seeds: {3:?}",
                                i,
                                solana_accounts[i].key,
                                derived_pda,
                                seeds_vec,
                            ),
                        )
                    }),
                );
            }
            let compressed_infos = {
                let seed_refs: Vec<&[u8]> = seeds_vec
                    .iter()
                    .map(|v| v.as_slice())
                    .collect();
                light_sdk::compressible::prepare_account_for_decompression_idempotent::<
                    ObservationState,
                >(
                        &crate::ID,
                        data,
                        light_sdk::compressible::into_compressed_meta_with_address(
                            meta,
                            &solana_accounts[i],
                            address_space,
                            &crate::ID,
                        ),
                        &solana_accounts[i],
                        &accounts.rent_payer,
                        cpi_accounts,
                        seed_refs.as_slice(),
                    )
                    .map_err(anchor_lang::prelude::ProgramError::from)?
            };
            compressed_pda_infos.extend(compressed_infos);
            Ok(())
        }
        #[inline(never)]
        pub fn collect_pda_and_token<'a, 'b, 'info>(
            accounts: &DecompressAccountsIdempotent<'info>,
            cpi_accounts: &light_sdk::cpi::CpiAccountsSmall<'b, 'info>,
            address_space: anchor_lang::prelude::Pubkey,
            compressed_accounts: Vec<CompressedAccountData>,
            solana_accounts: &[anchor_lang::prelude::AccountInfo<'info>],
            remaining_accounts: &[anchor_lang::prelude::AccountInfo<'info>],
            seed_accounts_offset: u8,
        ) -> Result<
            (
                Vec<
                    light_compressed_account::instruction_data::with_account_info::CompressedAccountInfo,
                >,
                Vec<
                    (
                        light_sdk::token::PackedCTokenData<CTokenAccountVariant>,
                        light_sdk::instruction::account_meta::CompressedAccountMetaNoLamportsNoAddress,
                        Vec<u8>,
                        Vec<u8>,
                    ),
                >,
            ),
        > {
            let post_system_accounts = cpi_accounts.post_system_accounts().unwrap();
            let estimated_capacity = compressed_accounts.len();
            let mut compressed_pda_infos = Vec::with_capacity(estimated_capacity);
            let mut compressed_token_accounts: Vec<
                (
                    light_sdk::token::PackedCTokenData<CTokenAccountVariant>,
                    light_sdk::instruction::account_meta::CompressedAccountMetaNoLamportsNoAddress,
                    Vec<u8>,
                    Vec<u8>,
                ),
            > = Vec::with_capacity(estimated_capacity);
            for (i, compressed_data) in compressed_accounts.into_iter().enumerate() {
                let meta = compressed_data.meta;
                let seed_indices = compressed_data.seed_indices;
                let authority_indices = compressed_data.authority_indices;
                match compressed_data.data {
                    CompressedAccountVariant::PoolState(_) => {
                        {
                            ::core::panicking::panic_fmt(
                                format_args!(
                                    "internal error: entered unreachable code: {0}",
                                    format_args!(
                                        "Unpacked variants should not be present during decompression - accounts are always packed in-flight",
                                    ),
                                ),
                            );
                        };
                    }
                    CompressedAccountVariant::ObservationState(_) => {
                        {
                            ::core::panicking::panic_fmt(
                                format_args!(
                                    "internal error: entered unreachable code: {0}",
                                    format_args!(
                                        "Unpacked variants should not be present during decompression - accounts are always packed in-flight",
                                    ),
                                ),
                            );
                        };
                    }
                    CompressedAccountVariant::PackedPoolState(packed) => {
                        handle_packed_PoolState(
                            accounts,
                            &cpi_accounts,
                            address_space,
                            solana_accounts,
                            remaining_accounts,
                            &seed_indices,
                            seed_accounts_offset,
                            i,
                            &packed,
                            &meta,
                            post_system_accounts,
                            &mut compressed_pda_infos,
                        )?;
                    }
                    CompressedAccountVariant::PackedObservationState(packed) => {
                        handle_packed_ObservationState(
                            accounts,
                            &cpi_accounts,
                            address_space,
                            solana_accounts,
                            remaining_accounts,
                            &seed_indices,
                            seed_accounts_offset,
                            i,
                            &packed,
                            &meta,
                            post_system_accounts,
                            &mut compressed_pda_infos,
                        )?;
                    }
                    CompressedAccountVariant::PackedCTokenData(mut data) => {
                        data.token_data.version = 3;
                        compressed_token_accounts
                            .push((data, meta, seed_indices, authority_indices));
                    }
                    CompressedAccountVariant::CTokenData(_) => {
                        ::core::panicking::panic(
                            "internal error: entered unreachable code",
                        );
                    }
                }
            }
            Ok((compressed_pda_infos, compressed_token_accounts))
        }
        #[inline(never)]
        fn process_pdas<'b, 'info>(
            compressed_pda_infos: Vec<
                light_compressed_account::instruction_data::with_account_info::CompressedAccountInfo,
            >,
            proof: light_sdk::instruction::ValidityProof,
            cpi_accounts: light_sdk::cpi::CpiAccountsSmall<'b, 'info>,
            has_tokens: bool,
        ) -> Result<()> {
            if has_tokens {
                let fee_payer = cpi_accounts.fee_payer();
                let authority = cpi_accounts.authority().unwrap();
                let cpi_context = cpi_accounts.cpi_context().unwrap();
                let system_cpi_accounts = light_sdk_types::cpi_context_write::CpiContextWriteAccounts {
                    fee_payer,
                    authority,
                    cpi_context,
                    cpi_signer: LIGHT_CPI_SIGNER,
                };
                let cpi_inputs = light_sdk::cpi::CpiInputs::new_first_cpi(
                    compressed_pda_infos,
                    Vec::new(),
                );
                cpi_inputs
                    .invoke_light_system_program_cpi_context(system_cpi_accounts)
                    .map_err(|e| anchor_lang::error::Error::from(e))
            } else {
                let cpi_inputs = light_sdk::cpi::CpiInputs::new(
                    proof,
                    compressed_pda_infos,
                );
                cpi_inputs
                    .invoke_light_system_program_small(cpi_accounts)
                    .map_err(|e| anchor_lang::error::Error::from(e))
            }
        }
        #[inline(never)]
        fn process_tokens<'b, 'info>(
            ctx: &Context<'_, '_, 'info, 'info, DecompressAccountsIdempotent<'info>>,
            ctoken_accounts: Vec<
                (
                    light_sdk::token::PackedCTokenData<CTokenAccountVariant>,
                    light_sdk::instruction::account_meta::CompressedAccountMetaNoLamportsNoAddress,
                    Vec<u8>,
                    Vec<u8>,
                ),
            >,
            proof: light_sdk::instruction::ValidityProof,
            cpi_accounts: light_sdk::cpi::CpiAccountsSmall<'b, 'info>,
            has_pdas: bool,
            seed_accounts_offset: u8,
        ) -> Result<()> {
            let accounts = &ctx.accounts;
            let remaining_accounts = &ctx.remaining_accounts;
            let fee_payer = ctx.accounts.fee_payer.as_ref();
            let ctoken_program = &ctx.accounts.ctoken_program;
            let ctoken_rent_sponsor = &ctx.accounts.ctoken_rent_sponsor;
            let ctoken_cpi_authority = &ctx.accounts.ctoken_cpi_authority;
            let ctoken_config = &ctx.accounts.ctoken_config;
            let config = &ctx.accounts.config;
            let mut token_decompress_indices = Box::new(
                Vec::with_capacity(ctoken_accounts.len()),
            );
            let mut token_signers_seed_groups = Box::new(
                Vec::with_capacity(ctoken_accounts.len()),
            );
            let packed_accounts = cpi_accounts.post_system_accounts().unwrap();
            use crate::ctoken_seed_system::CTokenSeedProvider;
            let authority = cpi_accounts.authority().unwrap();
            let cpi_context = cpi_accounts.cpi_context().unwrap();
            for (token_data, meta, seed_indices, authority_indices) in ctoken_accounts
                .into_iter()
            {
                let owner_index: u8 = token_data.token_data.owner;
                let mint_index: u8 = token_data.token_data.mint;
                let mint_info = packed_accounts[mint_index as usize].to_account_info();
                let owner_info = packed_accounts[owner_index as usize].to_account_info();
                let (ctoken_signer_seeds, derived_token_account_address) = token_data
                    .variant
                    .get_seeds(remaining_accounts, &seed_indices, seed_accounts_offset);
                let (ctoken_authority_seeds, ctoken_authority_pda) = token_data
                    .variant
                    .get_authority_seeds(
                        remaining_accounts,
                        &authority_indices,
                        seed_accounts_offset,
                    );
                if derived_token_account_address != *owner_info.key {
                    ::solana_msg::sol_log(
                        "Derived token account address (PDA) does not match provided owner account",
                    );
                    ::solana_msg::sol_log(
                        &::alloc::__export::must_use({
                            ::alloc::fmt::format(
                                format_args!(
                                    "derived_token_account_address: {0:?}",
                                    derived_token_account_address,
                                ),
                            )
                        }),
                    );
                    ::solana_msg::sol_log(
                        &::alloc::__export::must_use({
                            ::alloc::fmt::format(
                                format_args!("owner_info.key: {0:?}", owner_info.key),
                            )
                        }),
                    );
                    return Err(
                        anchor_lang::error::Error::from(anchor_lang::error::AnchorError {
                            error_name: CompressibleInstructionError::CTokenDecompressionNotImplemented
                                .name(),
                            error_code_number: CompressibleInstructionError::CTokenDecompressionNotImplemented
                                .into(),
                            error_msg: CompressibleInstructionError::CTokenDecompressionNotImplemented
                                .to_string(),
                            error_origin: Some(
                                anchor_lang::error::ErrorOrigin::Source(anchor_lang::error::Source {
                                    filename: "programs/cp-swap/src/lib.rs",
                                    line: 60u32,
                                }),
                            ),
                            compared_values: None,
                        }),
                    );
                }
                {
                    let seed_refs: Vec<&[u8]> = ctoken_signer_seeds
                        .iter()
                        .map(|s| s.as_slice())
                        .collect();
                    let seeds_slice: &[&[u8]] = &seed_refs;
                    light_compressed_token_sdk::instructions::create_token_account::create_ctoken_account_signed(
                            crate::ID,
                            fee_payer.clone().to_account_info(),
                            owner_info.clone(),
                            mint_info.clone(),
                            ctoken_authority_pda,
                            seeds_slice,
                            ctoken_rent_sponsor.clone().to_account_info(),
                            ctoken_config.to_account_info(),
                            Some(1),
                            None,
                        )
                        .map_err(|e| anchor_lang::error::Error::from(
                            anchor_lang::prelude::ProgramError::from(e),
                        ))?;
                }
                let decompress_index = light_compressed_token_sdk::instructions::DecompressFullIndices::from((
                    token_data.token_data,
                    meta,
                    owner_index,
                ));
                token_decompress_indices.push(decompress_index);
                token_signers_seed_groups.push(ctoken_signer_seeds);
            }
            let ctoken_ix = light_compressed_token_sdk::instructions::decompress_full_ctoken_accounts_with_indices(
                    fee_payer.key(),
                    proof,
                    if has_pdas { Some(cpi_context.key()) } else { None },
                    &token_decompress_indices,
                    packed_accounts,
                )
                .map_err(|e| anchor_lang::error::Error::from(
                    anchor_lang::prelude::ProgramError::from(e),
                ))?;
            {
                let signer_seed_refs: Vec<Vec<&[u8]>> = token_signers_seed_groups
                    .iter()
                    .map(|group| group.iter().map(|s| s.as_slice()).collect())
                    .collect();
                let signer_seed_slices: Vec<&[&[u8]]> = signer_seed_refs
                    .iter()
                    .map(|g| g.as_slice())
                    .collect();
                let cpi_slice = cpi_accounts.account_infos_slice();
                let mut account_infos = Vec::with_capacity(
                    5 + cpi_slice.len().saturating_sub(1),
                );
                account_infos.push(fee_payer.to_account_info());
                account_infos.push(ctoken_cpi_authority.to_account_info());
                account_infos.push(ctoken_program.to_account_info());
                account_infos.push(ctoken_rent_sponsor.to_account_info());
                account_infos.push(config.to_account_info());
                if cpi_slice.len() > 1 {
                    account_infos.extend_from_slice(&cpi_slice[1..]);
                }
                anchor_lang::solana_program::program::invoke_signed(
                        &ctoken_ix,
                        account_infos.as_slice(),
                        signer_seed_slices.as_slice(),
                    )
                    .map_err(|e| anchor_lang::error::Error::from(e))?;
            }
            Ok(())
        }
        #[inline(never)]
        pub fn decompress_accounts_idempotent<'info>(
            ctx: Context<'_, '_, 'info, 'info, DecompressAccountsIdempotent<'info>>,
            proof: light_sdk::instruction::ValidityProof,
            compressed_accounts: Vec<CompressedAccountData>,
            system_accounts_offset: u8,
        ) -> Result<()> {
            let compressed_accounts = Box::new(compressed_accounts);
            let seed_accounts_offset = system_accounts_offset
                + compressed_accounts.len() as u8;
            #[inline(never)]
            fn check_account_types(
                compressed_accounts: &[CompressedAccountData],
            ) -> (bool, bool) {
                let (mut has_tokens, mut has_pdas) = (false, false);
                for c in compressed_accounts {
                    match c.data {
                        CompressedAccountVariant::PackedCTokenData(_) => {
                            has_tokens = true;
                        }
                        _ => has_pdas = true,
                    }
                    if has_tokens && has_pdas {
                        break;
                    }
                }
                (has_tokens, has_pdas)
            }
            let (has_tokens, has_pdas) = check_account_types(&*compressed_accounts);
            if !has_tokens && !has_pdas {
                return Ok(());
            }
            decompress_and_invoke(
                ctx,
                proof,
                *compressed_accounts,
                system_accounts_offset,
                seed_accounts_offset,
                has_tokens,
                has_pdas,
            )
        }
        #[inline(never)]
        pub(super) fn decompress_and_invoke<'info>(
            ctx: Context<'_, '_, 'info, 'info, DecompressAccountsIdempotent<'info>>,
            proof: light_sdk::instruction::ValidityProof,
            compressed_accounts: Vec<CompressedAccountData>,
            system_accounts_offset: u8,
            seed_accounts_offset: u8,
            has_tokens: bool,
            has_pdas: bool,
        ) -> Result<()> {
            let compression_config = light_sdk::compressible::CompressibleConfig::load_checked(
                    &ctx.accounts.config,
                    &crate::ID,
                )
                .map_err(|e| anchor_lang::error::Error::from(e))?;
            let address_space = compression_config.address_space[0];
            #[inline(never)]
            pub(super) fn build_cpi_and_collect<'b, 'info>(
                ctx: &'b Context<
                    '_,
                    '_,
                    'info,
                    'info,
                    DecompressAccountsIdempotent<'info>,
                >,
                address_space: anchor_lang::prelude::Pubkey,
                compressed_accounts: Vec<CompressedAccountData>,
                system_accounts_offset: u8,
                seed_accounts_offset: u8,
                has_tokens: bool,
                has_pdas: bool,
            ) -> Result<
                (
                    light_sdk::cpi::CpiAccountsSmall<'b, 'info>,
                    Vec<
                        light_compressed_account::instruction_data::with_account_info::CompressedAccountInfo,
                    >,
                    Vec<
                        (
                            light_sdk::token::PackedCTokenData<CTokenAccountVariant>,
                            light_sdk::instruction::account_meta::CompressedAccountMetaNoLamportsNoAddress,
                            Vec<u8>,
                            Vec<u8>,
                        ),
                    >,
                ),
            > {
                let cpi_accounts = if has_tokens && has_pdas {
                    light_sdk_types::CpiAccountsSmall::new_with_config(
                        ctx.accounts.fee_payer.as_ref(),
                        &ctx.remaining_accounts[system_accounts_offset as usize..],
                        light_sdk_types::CpiAccountsConfig::new_with_cpi_context(
                            LIGHT_CPI_SIGNER,
                        ),
                    )
                } else {
                    light_sdk_types::CpiAccountsSmall::new(
                        ctx.accounts.fee_payer.as_ref(),
                        &ctx.remaining_accounts[system_accounts_offset as usize..],
                        LIGHT_CPI_SIGNER,
                    )
                };
                let solana_accounts = &ctx
                    .remaining_accounts[ctx.remaining_accounts.len()
                    - compressed_accounts.len()..];
                let (compressed_pda_infos, compressed_token_accounts) = collect_pda_and_token(
                        &ctx.accounts,
                        &cpi_accounts,
                        address_space,
                        compressed_accounts,
                        solana_accounts,
                        &ctx.remaining_accounts,
                        seed_accounts_offset,
                    )
                    .map_err(|e| anchor_lang::error::Error::from(e))?;
                Ok((cpi_accounts, compressed_pda_infos, compressed_token_accounts))
            }
            let (cpi_accounts, compressed_pda_infos, compressed_token_accounts) = build_cpi_and_collect(
                &ctx,
                address_space,
                compressed_accounts,
                system_accounts_offset,
                seed_accounts_offset,
                has_tokens,
                has_pdas,
            )?;
            let has_pdas = !compressed_pda_infos.is_empty();
            let has_tokens = !compressed_token_accounts.is_empty();
            if !has_pdas && !has_tokens {
                return Ok(());
            }
            if has_pdas && !has_tokens {
                process_pdas(compressed_pda_infos, proof, cpi_accounts, false)
                    .map_err(|e| anchor_lang::error::Error::from(e))?;
            } else if !has_pdas && has_tokens {
                process_tokens(
                        &ctx,
                        compressed_token_accounts,
                        proof,
                        cpi_accounts,
                        false,
                        seed_accounts_offset,
                    )
                    .map_err(|e| anchor_lang::error::Error::from(e))?;
            } else if has_pdas && has_tokens {
                process_pdas(compressed_pda_infos, proof, cpi_accounts.clone(), true)
                    .map_err(|e| anchor_lang::error::Error::from(e))?;
                process_tokens(
                        &ctx,
                        compressed_token_accounts,
                        proof,
                        cpi_accounts,
                        true,
                        seed_accounts_offset,
                    )
                    .map_err(|e| anchor_lang::error::Error::from(e))?;
            }
            Ok(())
        }
    }
    /// Trait-based system for generic CToken variant seed handling with positional indices
    pub mod ctoken_seed_system {
        use super::*;
        pub trait CTokenSeedProvider {
            /// Get seeds for the token account PDA using positional indices
            ///
            /// # Arguments
            /// * `remaining_accounts` - All remaining accounts passed to the instruction
            /// * `seed_indices` - Indices pointing to seed accounts (relative to seed_accounts_offset)
            /// * `seed_accounts_offset` - Offset where seed accounts section begins in remaining_accounts
            fn get_seeds<'info>(
                &self,
                remaining_accounts: &[anchor_lang::prelude::AccountInfo<'info>],
                seed_indices: &[u8],
                seed_accounts_offset: u8,
            ) -> (Vec<Vec<u8>>, anchor_lang::prelude::Pubkey);
            /// Get authority seeds for signing during compression using positional indices
            fn get_authority_seeds<'info>(
                &self,
                remaining_accounts: &[anchor_lang::prelude::AccountInfo<'info>],
                authority_indices: &[u8],
                seed_accounts_offset: u8,
            ) -> (Vec<Vec<u8>>, anchor_lang::prelude::Pubkey);
        }
    }
    /// Auto-generated decompress_accounts_idempotent instruction
    #[inline(never)]
    pub fn decompress_accounts_idempotent<'info>(
        ctx: Context<'_, '_, 'info, 'info, DecompressAccountsIdempotent<'info>>,
        proof: light_sdk::instruction::ValidityProof,
        compressed_accounts: Vec<CompressedAccountData>,
        system_accounts_offset: u8,
    ) -> Result<()> {
        __macro_helpers::decompress_accounts_idempotent(
            ctx,
            proof,
            compressed_accounts,
            system_accounts_offset,
        )
    }
    pub struct CompressAccountsIdempotent<'info> {
        #[account(mut)]
        pub fee_payer: Signer<'info>,
        /// The global config account
        /// CHECK: Config is validated by the SDK's load_checked method
        pub config: AccountInfo<'info>,
        /// Rent recipient - must match config
        /// CHECK: Rent recipient is validated against the config
        #[account(mut)]
        pub rent_recipient: AccountInfo<'info>,
        /// CHECK: compression_authority must be the rent_authority defined when creating the PDA account.
        #[account(mut)]
        pub compression_authority: AccountInfo<'info>,
        /// CHECK: token_compression_authority must be the rent_authority defined when creating the token account.
        #[account(mut)]
        pub ctoken_compression_authority: AccountInfo<'info>,
        /// Token rent recipient - must match config
        /// CHECK: Token rent recipient is validated against the config
        #[account(mut)]
        pub ctoken_rent_sponsor: AccountInfo<'info>,
        /// Compressed token program (always required in mixed variant)
        /// CHECK: Program ID validated to be cTokenmWW8bLPjZEBAUgYy3zKxQZW6VKi7bqNFEVv3m
        pub ctoken_program: UncheckedAccount<'info>,
        /// CPI authority PDA of the compressed token program (always required in mixed variant)
        /// CHECK: PDA derivation validated with seeds ["cpi_authority"] and bump 254
        pub ctoken_cpi_authority: UncheckedAccount<'info>,
    }
    #[automatically_derived]
    impl<'info> anchor_lang::Accounts<'info, CompressAccountsIdempotentBumps>
    for CompressAccountsIdempotent<'info>
    where
        'info: 'info,
    {
        #[inline(never)]
        fn try_accounts(
            __program_id: &anchor_lang::solana_program::pubkey::Pubkey,
            __accounts: &mut &'info [anchor_lang::solana_program::account_info::AccountInfo<
                'info,
            >],
            __ix_data: &[u8],
            __bumps: &mut CompressAccountsIdempotentBumps,
            __reallocs: &mut std::collections::BTreeSet<
                anchor_lang::solana_program::pubkey::Pubkey,
            >,
        ) -> anchor_lang::Result<Self> {
            let fee_payer: Signer = anchor_lang::Accounts::try_accounts(
                    __program_id,
                    __accounts,
                    __ix_data,
                    __bumps,
                    __reallocs,
                )
                .map_err(|e| e.with_account_name("fee_payer"))?;
            let config: AccountInfo = anchor_lang::Accounts::try_accounts(
                    __program_id,
                    __accounts,
                    __ix_data,
                    __bumps,
                    __reallocs,
                )
                .map_err(|e| e.with_account_name("config"))?;
            let rent_recipient: AccountInfo = anchor_lang::Accounts::try_accounts(
                    __program_id,
                    __accounts,
                    __ix_data,
                    __bumps,
                    __reallocs,
                )
                .map_err(|e| e.with_account_name("rent_recipient"))?;
            let compression_authority: AccountInfo = anchor_lang::Accounts::try_accounts(
                    __program_id,
                    __accounts,
                    __ix_data,
                    __bumps,
                    __reallocs,
                )
                .map_err(|e| e.with_account_name("compression_authority"))?;
            let ctoken_compression_authority: AccountInfo = anchor_lang::Accounts::try_accounts(
                    __program_id,
                    __accounts,
                    __ix_data,
                    __bumps,
                    __reallocs,
                )
                .map_err(|e| e.with_account_name("ctoken_compression_authority"))?;
            let ctoken_rent_sponsor: AccountInfo = anchor_lang::Accounts::try_accounts(
                    __program_id,
                    __accounts,
                    __ix_data,
                    __bumps,
                    __reallocs,
                )
                .map_err(|e| e.with_account_name("ctoken_rent_sponsor"))?;
            let ctoken_program: UncheckedAccount = anchor_lang::Accounts::try_accounts(
                    __program_id,
                    __accounts,
                    __ix_data,
                    __bumps,
                    __reallocs,
                )
                .map_err(|e| e.with_account_name("ctoken_program"))?;
            let ctoken_cpi_authority: UncheckedAccount = anchor_lang::Accounts::try_accounts(
                    __program_id,
                    __accounts,
                    __ix_data,
                    __bumps,
                    __reallocs,
                )
                .map_err(|e| e.with_account_name("ctoken_cpi_authority"))?;
            if !AsRef::<AccountInfo>::as_ref(&fee_payer).is_writable {
                return Err(
                    anchor_lang::error::Error::from(
                            anchor_lang::error::ErrorCode::ConstraintMut,
                        )
                        .with_account_name("fee_payer"),
                );
            }
            if !&rent_recipient.is_writable {
                return Err(
                    anchor_lang::error::Error::from(
                            anchor_lang::error::ErrorCode::ConstraintMut,
                        )
                        .with_account_name("rent_recipient"),
                );
            }
            if !&compression_authority.is_writable {
                return Err(
                    anchor_lang::error::Error::from(
                            anchor_lang::error::ErrorCode::ConstraintMut,
                        )
                        .with_account_name("compression_authority"),
                );
            }
            if !&ctoken_compression_authority.is_writable {
                return Err(
                    anchor_lang::error::Error::from(
                            anchor_lang::error::ErrorCode::ConstraintMut,
                        )
                        .with_account_name("ctoken_compression_authority"),
                );
            }
            if !&ctoken_rent_sponsor.is_writable {
                return Err(
                    anchor_lang::error::Error::from(
                            anchor_lang::error::ErrorCode::ConstraintMut,
                        )
                        .with_account_name("ctoken_rent_sponsor"),
                );
            }
            Ok(CompressAccountsIdempotent {
                fee_payer,
                config,
                rent_recipient,
                compression_authority,
                ctoken_compression_authority,
                ctoken_rent_sponsor,
                ctoken_program,
                ctoken_cpi_authority,
            })
        }
    }
    #[automatically_derived]
    impl<'info> anchor_lang::ToAccountInfos<'info> for CompressAccountsIdempotent<'info>
    where
        'info: 'info,
    {
        fn to_account_infos(
            &self,
        ) -> Vec<anchor_lang::solana_program::account_info::AccountInfo<'info>> {
            let mut account_infos = ::alloc::vec::Vec::new();
            account_infos.extend(self.fee_payer.to_account_infos());
            account_infos.extend(self.config.to_account_infos());
            account_infos.extend(self.rent_recipient.to_account_infos());
            account_infos.extend(self.compression_authority.to_account_infos());
            account_infos.extend(self.ctoken_compression_authority.to_account_infos());
            account_infos.extend(self.ctoken_rent_sponsor.to_account_infos());
            account_infos.extend(self.ctoken_program.to_account_infos());
            account_infos.extend(self.ctoken_cpi_authority.to_account_infos());
            account_infos
        }
    }
    #[automatically_derived]
    impl<'info> anchor_lang::ToAccountMetas for CompressAccountsIdempotent<'info> {
        fn to_account_metas(
            &self,
            is_signer: Option<bool>,
        ) -> Vec<anchor_lang::solana_program::instruction::AccountMeta> {
            let mut account_metas = ::alloc::vec::Vec::new();
            account_metas.extend(self.fee_payer.to_account_metas(None));
            account_metas.extend(self.config.to_account_metas(None));
            account_metas.extend(self.rent_recipient.to_account_metas(None));
            account_metas.extend(self.compression_authority.to_account_metas(None));
            account_metas
                .extend(self.ctoken_compression_authority.to_account_metas(None));
            account_metas.extend(self.ctoken_rent_sponsor.to_account_metas(None));
            account_metas.extend(self.ctoken_program.to_account_metas(None));
            account_metas.extend(self.ctoken_cpi_authority.to_account_metas(None));
            account_metas
        }
    }
    #[automatically_derived]
    impl<'info> anchor_lang::AccountsFinalize<'info, CompressAccountsIdempotentBumps>
    for CompressAccountsIdempotent<'info>
    where
        'info: 'info,
    {
        fn finalize(
            &mut self,
            program_id: &anchor_lang::solana_program::pubkey::Pubkey,
            _remaining: &[anchor_lang::solana_program::account_info::AccountInfo<'info>],
            _ix_data: &[u8],
            _bumps: &CompressAccountsIdempotentBumps,
        ) -> anchor_lang::Result<()> {
            Ok(())
        }
    }
    #[automatically_derived]
    impl<'info> anchor_lang::AccountsExit<'info> for CompressAccountsIdempotent<'info>
    where
        'info: 'info,
    {
        fn exit(
            &self,
            program_id: &anchor_lang::solana_program::pubkey::Pubkey,
        ) -> anchor_lang::Result<()> {
            anchor_lang::AccountsExit::exit(&self.fee_payer, program_id)
                .map_err(|e| e.with_account_name("fee_payer"))?;
            anchor_lang::AccountsExit::exit(&self.rent_recipient, program_id)
                .map_err(|e| e.with_account_name("rent_recipient"))?;
            anchor_lang::AccountsExit::exit(&self.compression_authority, program_id)
                .map_err(|e| e.with_account_name("compression_authority"))?;
            anchor_lang::AccountsExit::exit(
                    &self.ctoken_compression_authority,
                    program_id,
                )
                .map_err(|e| e.with_account_name("ctoken_compression_authority"))?;
            anchor_lang::AccountsExit::exit(&self.ctoken_rent_sponsor, program_id)
                .map_err(|e| e.with_account_name("ctoken_rent_sponsor"))?;
            Ok(())
        }
    }
    pub struct CompressAccountsIdempotentBumps {}
    #[automatically_derived]
    impl ::core::fmt::Debug for CompressAccountsIdempotentBumps {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::write_str(f, "CompressAccountsIdempotentBumps")
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for CompressAccountsIdempotentBumps {
        #[inline]
        fn clone(&self) -> CompressAccountsIdempotentBumps {
            CompressAccountsIdempotentBumps {}
        }
    }
    impl Default for CompressAccountsIdempotentBumps {
        fn default() -> Self {
            CompressAccountsIdempotentBumps {}
        }
    }
    impl<'info> anchor_lang::Bumps for CompressAccountsIdempotent<'info>
    where
        'info: 'info,
    {
        type Bumps = CompressAccountsIdempotentBumps;
    }
    /// An internal, Anchor generated module. This is used (as an
    /// implementation detail), to generate a struct for a given
    /// `#[derive(Accounts)]` implementation, where each field is a Pubkey,
    /// instead of an `AccountInfo`. This is useful for clients that want
    /// to generate a list of accounts, without explicitly knowing the
    /// order all the fields should be in.
    ///
    /// To access the struct in this module, one should use the sibling
    /// `accounts` module (also generated), which re-exports this.
    pub(crate) mod __client_accounts_compress_accounts_idempotent {
        use super::*;
        use anchor_lang::prelude::borsh;
        /// Generated client accounts for [`CompressAccountsIdempotent`].
        pub struct CompressAccountsIdempotent {
            pub fee_payer: Pubkey,
            ///The global config account
            pub config: Pubkey,
            ///Rent recipient - must match config
            pub rent_recipient: Pubkey,
            pub compression_authority: Pubkey,
            pub ctoken_compression_authority: Pubkey,
            ///Token rent recipient - must match config
            pub ctoken_rent_sponsor: Pubkey,
            ///Compressed token program (always required in mixed variant)
            pub ctoken_program: Pubkey,
            ///CPI authority PDA of the compressed token program (always required in mixed variant)
            pub ctoken_cpi_authority: Pubkey,
        }
        impl borsh::ser::BorshSerialize for CompressAccountsIdempotent
        where
            Pubkey: borsh::ser::BorshSerialize,
            Pubkey: borsh::ser::BorshSerialize,
            Pubkey: borsh::ser::BorshSerialize,
            Pubkey: borsh::ser::BorshSerialize,
            Pubkey: borsh::ser::BorshSerialize,
            Pubkey: borsh::ser::BorshSerialize,
            Pubkey: borsh::ser::BorshSerialize,
            Pubkey: borsh::ser::BorshSerialize,
        {
            fn serialize<W: borsh::maybestd::io::Write>(
                &self,
                writer: &mut W,
            ) -> ::core::result::Result<(), borsh::maybestd::io::Error> {
                borsh::BorshSerialize::serialize(&self.fee_payer, writer)?;
                borsh::BorshSerialize::serialize(&self.config, writer)?;
                borsh::BorshSerialize::serialize(&self.rent_recipient, writer)?;
                borsh::BorshSerialize::serialize(&self.compression_authority, writer)?;
                borsh::BorshSerialize::serialize(
                    &self.ctoken_compression_authority,
                    writer,
                )?;
                borsh::BorshSerialize::serialize(&self.ctoken_rent_sponsor, writer)?;
                borsh::BorshSerialize::serialize(&self.ctoken_program, writer)?;
                borsh::BorshSerialize::serialize(&self.ctoken_cpi_authority, writer)?;
                Ok(())
            }
        }
        impl anchor_lang::idl::build::IdlBuild for CompressAccountsIdempotent {
            fn create_type() -> Option<anchor_lang::idl::types::IdlTypeDef> {
                Some(anchor_lang::idl::types::IdlTypeDef {
                    name: Self::get_full_path(),
                    docs: <[_]>::into_vec(
                        ::alloc::boxed::box_new([
                            "Generated client accounts for [`CompressAccountsIdempotent`]."
                                .into(),
                        ]),
                    ),
                    serialization: anchor_lang::idl::types::IdlSerialization::default(),
                    repr: None,
                    generics: ::alloc::vec::Vec::new(),
                    ty: anchor_lang::idl::types::IdlTypeDefTy::Struct {
                        fields: Some(
                            anchor_lang::idl::types::IdlDefinedFields::Named(
                                <[_]>::into_vec(
                                    ::alloc::boxed::box_new([
                                        anchor_lang::idl::types::IdlField {
                                            name: "fee_payer".into(),
                                            docs: ::alloc::vec::Vec::new(),
                                            ty: anchor_lang::idl::types::IdlType::Pubkey,
                                        },
                                        anchor_lang::idl::types::IdlField {
                                            name: "config".into(),
                                            docs: <[_]>::into_vec(
                                                ::alloc::boxed::box_new([
                                                    "The global config account".into(),
                                                ]),
                                            ),
                                            ty: anchor_lang::idl::types::IdlType::Pubkey,
                                        },
                                        anchor_lang::idl::types::IdlField {
                                            name: "rent_recipient".into(),
                                            docs: <[_]>::into_vec(
                                                ::alloc::boxed::box_new([
                                                    "Rent recipient - must match config".into(),
                                                ]),
                                            ),
                                            ty: anchor_lang::idl::types::IdlType::Pubkey,
                                        },
                                        anchor_lang::idl::types::IdlField {
                                            name: "compression_authority".into(),
                                            docs: ::alloc::vec::Vec::new(),
                                            ty: anchor_lang::idl::types::IdlType::Pubkey,
                                        },
                                        anchor_lang::idl::types::IdlField {
                                            name: "ctoken_compression_authority".into(),
                                            docs: ::alloc::vec::Vec::new(),
                                            ty: anchor_lang::idl::types::IdlType::Pubkey,
                                        },
                                        anchor_lang::idl::types::IdlField {
                                            name: "ctoken_rent_sponsor".into(),
                                            docs: <[_]>::into_vec(
                                                ::alloc::boxed::box_new([
                                                    "Token rent recipient - must match config".into(),
                                                ]),
                                            ),
                                            ty: anchor_lang::idl::types::IdlType::Pubkey,
                                        },
                                        anchor_lang::idl::types::IdlField {
                                            name: "ctoken_program".into(),
                                            docs: <[_]>::into_vec(
                                                ::alloc::boxed::box_new([
                                                    "Compressed token program (always required in mixed variant)"
                                                        .into(),
                                                ]),
                                            ),
                                            ty: anchor_lang::idl::types::IdlType::Pubkey,
                                        },
                                        anchor_lang::idl::types::IdlField {
                                            name: "ctoken_cpi_authority".into(),
                                            docs: <[_]>::into_vec(
                                                ::alloc::boxed::box_new([
                                                    "CPI authority PDA of the compressed token program (always required in mixed variant)"
                                                        .into(),
                                                ]),
                                            ),
                                            ty: anchor_lang::idl::types::IdlType::Pubkey,
                                        },
                                    ]),
                                ),
                            ),
                        ),
                    },
                })
            }
            fn insert_types(
                types: &mut std::collections::BTreeMap<
                    String,
                    anchor_lang::idl::types::IdlTypeDef,
                >,
            ) {}
            fn get_full_path() -> String {
                ::alloc::__export::must_use({
                    ::alloc::fmt::format(
                        format_args!(
                            "{0}::{1}",
                            "raydium_cp_swap::raydium_cp_swap::__client_accounts_compress_accounts_idempotent",
                            "CompressAccountsIdempotent",
                        ),
                    )
                })
            }
        }
        #[automatically_derived]
        impl anchor_lang::ToAccountMetas for CompressAccountsIdempotent {
            fn to_account_metas(
                &self,
                is_signer: Option<bool>,
            ) -> Vec<anchor_lang::solana_program::instruction::AccountMeta> {
                let mut account_metas = ::alloc::vec::Vec::new();
                account_metas
                    .push(
                        anchor_lang::solana_program::instruction::AccountMeta::new(
                            self.fee_payer,
                            true,
                        ),
                    );
                account_metas
                    .push(
                        anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                            self.config,
                            false,
                        ),
                    );
                account_metas
                    .push(
                        anchor_lang::solana_program::instruction::AccountMeta::new(
                            self.rent_recipient,
                            false,
                        ),
                    );
                account_metas
                    .push(
                        anchor_lang::solana_program::instruction::AccountMeta::new(
                            self.compression_authority,
                            false,
                        ),
                    );
                account_metas
                    .push(
                        anchor_lang::solana_program::instruction::AccountMeta::new(
                            self.ctoken_compression_authority,
                            false,
                        ),
                    );
                account_metas
                    .push(
                        anchor_lang::solana_program::instruction::AccountMeta::new(
                            self.ctoken_rent_sponsor,
                            false,
                        ),
                    );
                account_metas
                    .push(
                        anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                            self.ctoken_program,
                            false,
                        ),
                    );
                account_metas
                    .push(
                        anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                            self.ctoken_cpi_authority,
                            false,
                        ),
                    );
                account_metas
            }
        }
    }
    /// An internal, Anchor generated module. This is used (as an
    /// implementation detail), to generate a CPI struct for a given
    /// `#[derive(Accounts)]` implementation, where each field is an
    /// AccountInfo.
    ///
    /// To access the struct in this module, one should use the sibling
    /// [`cpi::accounts`] module (also generated), which re-exports this.
    pub(crate) mod __cpi_client_accounts_compress_accounts_idempotent {
        use super::*;
        /// Generated CPI struct of the accounts for [`CompressAccountsIdempotent`].
        pub struct CompressAccountsIdempotent<'info> {
            pub fee_payer: anchor_lang::solana_program::account_info::AccountInfo<'info>,
            ///The global config account
            pub config: anchor_lang::solana_program::account_info::AccountInfo<'info>,
            ///Rent recipient - must match config
            pub rent_recipient: anchor_lang::solana_program::account_info::AccountInfo<
                'info,
            >,
            pub compression_authority: anchor_lang::solana_program::account_info::AccountInfo<
                'info,
            >,
            pub ctoken_compression_authority: anchor_lang::solana_program::account_info::AccountInfo<
                'info,
            >,
            ///Token rent recipient - must match config
            pub ctoken_rent_sponsor: anchor_lang::solana_program::account_info::AccountInfo<
                'info,
            >,
            ///Compressed token program (always required in mixed variant)
            pub ctoken_program: anchor_lang::solana_program::account_info::AccountInfo<
                'info,
            >,
            ///CPI authority PDA of the compressed token program (always required in mixed variant)
            pub ctoken_cpi_authority: anchor_lang::solana_program::account_info::AccountInfo<
                'info,
            >,
        }
        #[automatically_derived]
        impl<'info> anchor_lang::ToAccountMetas for CompressAccountsIdempotent<'info> {
            fn to_account_metas(
                &self,
                is_signer: Option<bool>,
            ) -> Vec<anchor_lang::solana_program::instruction::AccountMeta> {
                let mut account_metas = ::alloc::vec::Vec::new();
                account_metas
                    .push(
                        anchor_lang::solana_program::instruction::AccountMeta::new(
                            anchor_lang::Key::key(&self.fee_payer),
                            true,
                        ),
                    );
                account_metas
                    .push(
                        anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                            anchor_lang::Key::key(&self.config),
                            false,
                        ),
                    );
                account_metas
                    .push(
                        anchor_lang::solana_program::instruction::AccountMeta::new(
                            anchor_lang::Key::key(&self.rent_recipient),
                            false,
                        ),
                    );
                account_metas
                    .push(
                        anchor_lang::solana_program::instruction::AccountMeta::new(
                            anchor_lang::Key::key(&self.compression_authority),
                            false,
                        ),
                    );
                account_metas
                    .push(
                        anchor_lang::solana_program::instruction::AccountMeta::new(
                            anchor_lang::Key::key(&self.ctoken_compression_authority),
                            false,
                        ),
                    );
                account_metas
                    .push(
                        anchor_lang::solana_program::instruction::AccountMeta::new(
                            anchor_lang::Key::key(&self.ctoken_rent_sponsor),
                            false,
                        ),
                    );
                account_metas
                    .push(
                        anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                            anchor_lang::Key::key(&self.ctoken_program),
                            false,
                        ),
                    );
                account_metas
                    .push(
                        anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                            anchor_lang::Key::key(&self.ctoken_cpi_authority),
                            false,
                        ),
                    );
                account_metas
            }
        }
        #[automatically_derived]
        impl<'info> anchor_lang::ToAccountInfos<'info>
        for CompressAccountsIdempotent<'info> {
            fn to_account_infos(
                &self,
            ) -> Vec<anchor_lang::solana_program::account_info::AccountInfo<'info>> {
                let mut account_infos = ::alloc::vec::Vec::new();
                account_infos
                    .extend(
                        anchor_lang::ToAccountInfos::to_account_infos(&self.fee_payer),
                    );
                account_infos
                    .extend(anchor_lang::ToAccountInfos::to_account_infos(&self.config));
                account_infos
                    .extend(
                        anchor_lang::ToAccountInfos::to_account_infos(
                            &self.rent_recipient,
                        ),
                    );
                account_infos
                    .extend(
                        anchor_lang::ToAccountInfos::to_account_infos(
                            &self.compression_authority,
                        ),
                    );
                account_infos
                    .extend(
                        anchor_lang::ToAccountInfos::to_account_infos(
                            &self.ctoken_compression_authority,
                        ),
                    );
                account_infos
                    .extend(
                        anchor_lang::ToAccountInfos::to_account_infos(
                            &self.ctoken_rent_sponsor,
                        ),
                    );
                account_infos
                    .extend(
                        anchor_lang::ToAccountInfos::to_account_infos(
                            &self.ctoken_program,
                        ),
                    );
                account_infos
                    .extend(
                        anchor_lang::ToAccountInfos::to_account_infos(
                            &self.ctoken_cpi_authority,
                        ),
                    );
                account_infos
            }
        }
    }
    impl<'info> CompressAccountsIdempotent<'info> {
        pub fn __anchor_private_gen_idl_accounts(
            accounts: &mut std::collections::BTreeMap<
                String,
                anchor_lang::idl::types::IdlAccount,
            >,
            types: &mut std::collections::BTreeMap<
                String,
                anchor_lang::idl::types::IdlTypeDef,
            >,
        ) -> Vec<anchor_lang::idl::types::IdlInstructionAccountItem> {
            <[_]>::into_vec(
                ::alloc::boxed::box_new([
                    anchor_lang::idl::types::IdlInstructionAccountItem::Single(anchor_lang::idl::types::IdlInstructionAccount {
                        name: "fee_payer".into(),
                        docs: ::alloc::vec::Vec::new(),
                        writable: true,
                        signer: true,
                        optional: false,
                        address: None,
                        pda: None,
                        relations: ::alloc::vec::Vec::new(),
                    }),
                    anchor_lang::idl::types::IdlInstructionAccountItem::Single(anchor_lang::idl::types::IdlInstructionAccount {
                        name: "config".into(),
                        docs: <[_]>::into_vec(
                            ::alloc::boxed::box_new(["The global config account".into()]),
                        ),
                        writable: false,
                        signer: false,
                        optional: false,
                        address: None,
                        pda: None,
                        relations: ::alloc::vec::Vec::new(),
                    }),
                    anchor_lang::idl::types::IdlInstructionAccountItem::Single(anchor_lang::idl::types::IdlInstructionAccount {
                        name: "rent_recipient".into(),
                        docs: <[_]>::into_vec(
                            ::alloc::boxed::box_new([
                                "Rent recipient - must match config".into(),
                            ]),
                        ),
                        writable: true,
                        signer: false,
                        optional: false,
                        address: None,
                        pda: None,
                        relations: ::alloc::vec::Vec::new(),
                    }),
                    anchor_lang::idl::types::IdlInstructionAccountItem::Single(anchor_lang::idl::types::IdlInstructionAccount {
                        name: "compression_authority".into(),
                        docs: ::alloc::vec::Vec::new(),
                        writable: true,
                        signer: false,
                        optional: false,
                        address: None,
                        pda: None,
                        relations: ::alloc::vec::Vec::new(),
                    }),
                    anchor_lang::idl::types::IdlInstructionAccountItem::Single(anchor_lang::idl::types::IdlInstructionAccount {
                        name: "ctoken_compression_authority".into(),
                        docs: ::alloc::vec::Vec::new(),
                        writable: true,
                        signer: false,
                        optional: false,
                        address: None,
                        pda: None,
                        relations: ::alloc::vec::Vec::new(),
                    }),
                    anchor_lang::idl::types::IdlInstructionAccountItem::Single(anchor_lang::idl::types::IdlInstructionAccount {
                        name: "ctoken_rent_sponsor".into(),
                        docs: <[_]>::into_vec(
                            ::alloc::boxed::box_new([
                                "Token rent recipient - must match config".into(),
                            ]),
                        ),
                        writable: true,
                        signer: false,
                        optional: false,
                        address: None,
                        pda: None,
                        relations: ::alloc::vec::Vec::new(),
                    }),
                    anchor_lang::idl::types::IdlInstructionAccountItem::Single(anchor_lang::idl::types::IdlInstructionAccount {
                        name: "ctoken_program".into(),
                        docs: <[_]>::into_vec(
                            ::alloc::boxed::box_new([
                                "Compressed token program (always required in mixed variant)"
                                    .into(),
                            ]),
                        ),
                        writable: false,
                        signer: false,
                        optional: false,
                        address: None,
                        pda: None,
                        relations: ::alloc::vec::Vec::new(),
                    }),
                    anchor_lang::idl::types::IdlInstructionAccountItem::Single(anchor_lang::idl::types::IdlInstructionAccount {
                        name: "ctoken_cpi_authority".into(),
                        docs: <[_]>::into_vec(
                            ::alloc::boxed::box_new([
                                "CPI authority PDA of the compressed token program (always required in mixed variant)"
                                    .into(),
                            ]),
                        ),
                        writable: false,
                        signer: false,
                        optional: false,
                        address: None,
                        pda: None,
                        relations: ::alloc::vec::Vec::new(),
                    }),
                ]),
            )
        }
        pub fn __anchor_private_gen_light_metadata() -> Option<
            anchor_lang::idl::types::IdlLightInstructionMeta,
        > {
            None
        }
    }
    /// Auto-generated compress_accounts_idempotent instruction
    #[inline(never)]
    pub fn compress_accounts_idempotent<'info>(
        ctx: Context<'_, '_, 'info, 'info, CompressAccountsIdempotent<'info>>,
        proof: light_sdk::instruction::ValidityProof,
        compressed_accounts: Vec<
            light_sdk::instruction::account_meta::CompressedAccountMetaNoLamportsNoAddress,
        >,
        signer_seeds: Vec<Vec<Vec<u8>>>,
        system_accounts_offset: u8,
    ) -> Result<()> {
        let proof = light_sdk::instruction::ValidityProof::new(None);
        let compression_config = light_sdk::compressible::CompressibleConfig::load_checked(
            &ctx.accounts.config,
            &crate::ID,
        )?;
        if ctx.accounts.rent_recipient.key() != compression_config.rent_recipient {
            return Err(
                anchor_lang::error::Error::from(anchor_lang::error::AnchorError {
                    error_name: CompressibleInstructionError::InvalidRentRecipient
                        .name(),
                    error_code_number: CompressibleInstructionError::InvalidRentRecipient
                        .into(),
                    error_msg: CompressibleInstructionError::InvalidRentRecipient
                        .to_string(),
                    error_origin: Some(
                        anchor_lang::error::ErrorOrigin::Source(anchor_lang::error::Source {
                            filename: "programs/cp-swap/src/lib.rs",
                            line: 60u32,
                        }),
                    ),
                    compared_values: None,
                }),
            );
        }
        let pda_and_token_accounts_start = ctx.remaining_accounts.len()
            - signer_seeds.len();
        let solana_accounts = &ctx.remaining_accounts[pda_and_token_accounts_start..];
        #[inline(never)]
        fn has_pdas_and_tokens<'info>(
            solana_accounts: &[anchor_lang::prelude::AccountInfo<'info>],
        ) -> (bool, bool) {
            let (mut has_tokens, mut has_pdas) = (false, false);
            for account_info in solana_accounts.iter() {
                if account_info.data_is_empty() {
                    continue;
                }
                if account_info.owner == &light_sdk_types::CTOKEN_PROGRAM_ID.into() {
                    has_tokens = true;
                } else if account_info.owner == &crate::ID {
                    has_pdas = true;
                }
                if has_tokens && has_pdas {
                    break;
                }
            }
            (has_tokens, has_pdas)
        }
        let (has_tokens, has_pdas) = has_pdas_and_tokens(solana_accounts);
        if !has_tokens && !has_pdas {
            return Ok(());
        }
        let cpi_accounts = light_sdk_types::CpiAccountsSmall::new(
            ctx.accounts.fee_payer.as_ref(),
            &ctx.remaining_accounts[system_accounts_offset as usize..],
            LIGHT_CPI_SIGNER,
        );
        let mut compressed_pda_infos = Vec::with_capacity(0);
        let mut token_accounts_to_compress: Vec<
            light_compressed_token_sdk::AccountInfoToCompress<'info>,
        > = Vec::with_capacity(0);
        let mut pda_indices_to_close: Vec<usize> = Vec::with_capacity(0);
        #[inline(never)]
        fn collect_accounts_to_compress<'b, 'info>(
            cpi_accounts: &light_sdk::cpi::CpiAccountsSmall<'b, 'info>,
            compression_config: &light_sdk::compressible::CompressibleConfig,
            solana_accounts: &'info [anchor_lang::prelude::AccountInfo<'info>],
            signer_seeds: &[Vec<Vec<u8>>],
            compressed_accounts: &[light_sdk::instruction::account_meta::CompressedAccountMetaNoLamportsNoAddress],
            token_accounts_to_compress: &mut Vec<
                light_compressed_token_sdk::AccountInfoToCompress<'info>,
            >,
            compressed_pda_infos: &mut Vec<
                light_compressed_account::instruction_data::with_account_info::CompressedAccountInfo,
            >,
            pda_indices_to_close: &mut Vec<usize>,
        ) -> Result<()> {
            let mut pda_meta_index: usize = 0;
            for (i, account_info) in solana_accounts.iter().enumerate() {
                if account_info.data_is_empty() {
                    continue;
                }
                if account_info.owner == &light_sdk_types::CTOKEN_PROGRAM_ID.into() {
                    if let Ok(token_account) = anchor_lang::prelude::InterfaceAccount::<
                        anchor_spl::token_interface::TokenAccount,
                    >::try_from(account_info) {
                        let account_signer_seeds = signer_seeds[i].clone();
                        token_accounts_to_compress
                            .push(light_compressed_token_sdk::AccountInfoToCompress {
                                account_info: token_account.to_account_info(),
                                signer_seeds: account_signer_seeds,
                            });
                    }
                } else if account_info.owner == &crate::ID {
                    let data = account_info.try_borrow_data()?;
                    let discriminator = &data[0..8];
                    let meta = compressed_accounts[pda_meta_index];
                    pda_meta_index += 1;
                    match discriminator {
                        d if d == PoolState::discriminator() => {
                            let mut anchor_account = anchor_lang::prelude::Account::<
                                PoolState,
                            >::try_from(account_info)?;
                            let compressed_info = light_sdk::compressible::compress_account::prepare_account_for_compression::<
                                PoolState,
                            >(
                                &crate::ID,
                                &mut anchor_account,
                                &meta,
                                &cpi_accounts,
                                &compression_config.compression_delay,
                                &compression_config.address_space,
                            )?;
                            compressed_pda_infos.push(compressed_info);
                            pda_indices_to_close.push(i);
                        }
                        d if d == ObservationState::discriminator() => {
                            let mut anchor_account = anchor_lang::prelude::Account::<
                                ObservationState,
                            >::try_from(account_info)?;
                            let compressed_info = light_sdk::compressible::compress_account::prepare_account_for_compression::<
                                ObservationState,
                            >(
                                &crate::ID,
                                &mut anchor_account,
                                &meta,
                                &cpi_accounts,
                                &compression_config.compression_delay,
                                &compression_config.address_space,
                            )?;
                            compressed_pda_infos.push(compressed_info);
                            pda_indices_to_close.push(i);
                        }
                        _ => {
                            {
                                ::core::panicking::panic_fmt(
                                    format_args!(
                                        "Trying to compress with invalid account discriminator",
                                    ),
                                );
                            };
                        }
                    }
                }
            }
            Ok(())
        }
        collect_accounts_to_compress(
            &cpi_accounts,
            &compression_config,
            solana_accounts,
            &signer_seeds,
            &compressed_accounts,
            &mut token_accounts_to_compress,
            &mut compressed_pda_infos,
            &mut pda_indices_to_close,
        )?;
        let has_pdas = !compressed_pda_infos.is_empty();
        let has_tokens = !token_accounts_to_compress.is_empty();
        if has_tokens {
            let system_offset = cpi_accounts.system_accounts_end_offset();
            let post_system = &cpi_accounts.to_account_infos()[system_offset..];
            let output_queue = cpi_accounts
                .tree_accounts()
                .unwrap()[0]
                .to_account_info();
            let cpi_authority = cpi_accounts.authority().unwrap().to_account_info();
            light_compressed_token_sdk::instructions::compress_and_close::compress_and_close_ctoken_accounts_signed(
                &token_accounts_to_compress,
                ctx.accounts.fee_payer.to_account_info(),
                output_queue,
                ctx.accounts.ctoken_rent_sponsor.to_account_info(),
                ctx.accounts.ctoken_cpi_authority.to_account_info(),
                cpi_authority,
                post_system,
                &cpi_accounts.to_account_infos(),
            )?;
        }
        if has_pdas {
            let cpi_inputs = light_sdk::cpi::CpiInputs::new(proof, compressed_pda_infos);
            cpi_inputs.invoke_light_system_program_small(cpi_accounts.clone())?;
            for idx in pda_indices_to_close.into_iter() {
                let mut info = solana_accounts[idx].clone();
                light_sdk::compressible::compress_account_on_init_native::close(
                        &mut info,
                        ctx.accounts.rent_recipient.clone(),
                    )
                    .map_err(|e| anchor_lang::prelude::ProgramError::from(e))?;
            }
        }
        Ok(())
    }
    pub struct InitializeCompressionConfig<'info> {
        #[account(mut)]
        pub payer: Signer<'info>,
        /// CHECK: Config PDA is created and validated by the SDK
        #[account(mut)]
        pub config: AccountInfo<'info>,
        /// The program's data account
        /// CHECK: Program data account is validated by the SDK
        pub program_data: AccountInfo<'info>,
        /// The program's upgrade authority (must sign)
        pub authority: Signer<'info>,
        pub system_program: Program<'info, System>,
    }
    #[automatically_derived]
    impl<'info> anchor_lang::Accounts<'info, InitializeCompressionConfigBumps>
    for InitializeCompressionConfig<'info>
    where
        'info: 'info,
    {
        #[inline(never)]
        fn try_accounts(
            __program_id: &anchor_lang::solana_program::pubkey::Pubkey,
            __accounts: &mut &'info [anchor_lang::solana_program::account_info::AccountInfo<
                'info,
            >],
            __ix_data: &[u8],
            __bumps: &mut InitializeCompressionConfigBumps,
            __reallocs: &mut std::collections::BTreeSet<
                anchor_lang::solana_program::pubkey::Pubkey,
            >,
        ) -> anchor_lang::Result<Self> {
            let payer: Signer = anchor_lang::Accounts::try_accounts(
                    __program_id,
                    __accounts,
                    __ix_data,
                    __bumps,
                    __reallocs,
                )
                .map_err(|e| e.with_account_name("payer"))?;
            let config: AccountInfo = anchor_lang::Accounts::try_accounts(
                    __program_id,
                    __accounts,
                    __ix_data,
                    __bumps,
                    __reallocs,
                )
                .map_err(|e| e.with_account_name("config"))?;
            let program_data: AccountInfo = anchor_lang::Accounts::try_accounts(
                    __program_id,
                    __accounts,
                    __ix_data,
                    __bumps,
                    __reallocs,
                )
                .map_err(|e| e.with_account_name("program_data"))?;
            let authority: Signer = anchor_lang::Accounts::try_accounts(
                    __program_id,
                    __accounts,
                    __ix_data,
                    __bumps,
                    __reallocs,
                )
                .map_err(|e| e.with_account_name("authority"))?;
            let system_program: anchor_lang::accounts::program::Program<System> = anchor_lang::Accounts::try_accounts(
                    __program_id,
                    __accounts,
                    __ix_data,
                    __bumps,
                    __reallocs,
                )
                .map_err(|e| e.with_account_name("system_program"))?;
            if !AsRef::<AccountInfo>::as_ref(&payer).is_writable {
                return Err(
                    anchor_lang::error::Error::from(
                            anchor_lang::error::ErrorCode::ConstraintMut,
                        )
                        .with_account_name("payer"),
                );
            }
            if !&config.is_writable {
                return Err(
                    anchor_lang::error::Error::from(
                            anchor_lang::error::ErrorCode::ConstraintMut,
                        )
                        .with_account_name("config"),
                );
            }
            Ok(InitializeCompressionConfig {
                payer,
                config,
                program_data,
                authority,
                system_program,
            })
        }
    }
    #[automatically_derived]
    impl<'info> anchor_lang::ToAccountInfos<'info> for InitializeCompressionConfig<'info>
    where
        'info: 'info,
    {
        fn to_account_infos(
            &self,
        ) -> Vec<anchor_lang::solana_program::account_info::AccountInfo<'info>> {
            let mut account_infos = ::alloc::vec::Vec::new();
            account_infos.extend(self.payer.to_account_infos());
            account_infos.extend(self.config.to_account_infos());
            account_infos.extend(self.program_data.to_account_infos());
            account_infos.extend(self.authority.to_account_infos());
            account_infos.extend(self.system_program.to_account_infos());
            account_infos
        }
    }
    #[automatically_derived]
    impl<'info> anchor_lang::ToAccountMetas for InitializeCompressionConfig<'info> {
        fn to_account_metas(
            &self,
            is_signer: Option<bool>,
        ) -> Vec<anchor_lang::solana_program::instruction::AccountMeta> {
            let mut account_metas = ::alloc::vec::Vec::new();
            account_metas.extend(self.payer.to_account_metas(None));
            account_metas.extend(self.config.to_account_metas(None));
            account_metas.extend(self.program_data.to_account_metas(None));
            account_metas.extend(self.authority.to_account_metas(None));
            account_metas.extend(self.system_program.to_account_metas(None));
            account_metas
        }
    }
    #[automatically_derived]
    impl<'info> anchor_lang::AccountsFinalize<'info, InitializeCompressionConfigBumps>
    for InitializeCompressionConfig<'info>
    where
        'info: 'info,
    {
        fn finalize(
            &mut self,
            program_id: &anchor_lang::solana_program::pubkey::Pubkey,
            _remaining: &[anchor_lang::solana_program::account_info::AccountInfo<'info>],
            _ix_data: &[u8],
            _bumps: &InitializeCompressionConfigBumps,
        ) -> anchor_lang::Result<()> {
            anchor_lang::AccountsFinalize::finalize(
                    &mut self.system_program,
                    program_id,
                    _remaining,
                    _ix_data,
                    _bumps,
                )
                .map_err(|e| e.with_account_name("system_program"))?;
            Ok(())
        }
    }
    #[automatically_derived]
    impl<'info> anchor_lang::AccountsExit<'info> for InitializeCompressionConfig<'info>
    where
        'info: 'info,
    {
        fn exit(
            &self,
            program_id: &anchor_lang::solana_program::pubkey::Pubkey,
        ) -> anchor_lang::Result<()> {
            anchor_lang::AccountsExit::exit(&self.payer, program_id)
                .map_err(|e| e.with_account_name("payer"))?;
            anchor_lang::AccountsExit::exit(&self.config, program_id)
                .map_err(|e| e.with_account_name("config"))?;
            Ok(())
        }
    }
    pub struct InitializeCompressionConfigBumps {}
    #[automatically_derived]
    impl ::core::fmt::Debug for InitializeCompressionConfigBumps {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::write_str(f, "InitializeCompressionConfigBumps")
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for InitializeCompressionConfigBumps {
        #[inline]
        fn clone(&self) -> InitializeCompressionConfigBumps {
            InitializeCompressionConfigBumps {
            }
        }
    }
    impl Default for InitializeCompressionConfigBumps {
        fn default() -> Self {
            InitializeCompressionConfigBumps {
            }
        }
    }
    impl<'info> anchor_lang::Bumps for InitializeCompressionConfig<'info>
    where
        'info: 'info,
    {
        type Bumps = InitializeCompressionConfigBumps;
    }
    /// An internal, Anchor generated module. This is used (as an
    /// implementation detail), to generate a struct for a given
    /// `#[derive(Accounts)]` implementation, where each field is a Pubkey,
    /// instead of an `AccountInfo`. This is useful for clients that want
    /// to generate a list of accounts, without explicitly knowing the
    /// order all the fields should be in.
    ///
    /// To access the struct in this module, one should use the sibling
    /// `accounts` module (also generated), which re-exports this.
    pub(crate) mod __client_accounts_initialize_compression_config {
        use super::*;
        use anchor_lang::prelude::borsh;
        /// Generated client accounts for [`InitializeCompressionConfig`].
        pub struct InitializeCompressionConfig {
            pub payer: Pubkey,
            pub config: Pubkey,
            ///The program's data account
            pub program_data: Pubkey,
            ///The program's upgrade authority (must sign)
            pub authority: Pubkey,
            pub system_program: Pubkey,
        }
        impl borsh::ser::BorshSerialize for InitializeCompressionConfig
        where
            Pubkey: borsh::ser::BorshSerialize,
            Pubkey: borsh::ser::BorshSerialize,
            Pubkey: borsh::ser::BorshSerialize,
            Pubkey: borsh::ser::BorshSerialize,
            Pubkey: borsh::ser::BorshSerialize,
        {
            fn serialize<W: borsh::maybestd::io::Write>(
                &self,
                writer: &mut W,
            ) -> ::core::result::Result<(), borsh::maybestd::io::Error> {
                borsh::BorshSerialize::serialize(&self.payer, writer)?;
                borsh::BorshSerialize::serialize(&self.config, writer)?;
                borsh::BorshSerialize::serialize(&self.program_data, writer)?;
                borsh::BorshSerialize::serialize(&self.authority, writer)?;
                borsh::BorshSerialize::serialize(&self.system_program, writer)?;
                Ok(())
            }
        }
        impl anchor_lang::idl::build::IdlBuild for InitializeCompressionConfig {
            fn create_type() -> Option<anchor_lang::idl::types::IdlTypeDef> {
                Some(anchor_lang::idl::types::IdlTypeDef {
                    name: Self::get_full_path(),
                    docs: <[_]>::into_vec(
                        ::alloc::boxed::box_new([
                            "Generated client accounts for [`InitializeCompressionConfig`]."
                                .into(),
                        ]),
                    ),
                    serialization: anchor_lang::idl::types::IdlSerialization::default(),
                    repr: None,
                    generics: ::alloc::vec::Vec::new(),
                    ty: anchor_lang::idl::types::IdlTypeDefTy::Struct {
                        fields: Some(
                            anchor_lang::idl::types::IdlDefinedFields::Named(
                                <[_]>::into_vec(
                                    ::alloc::boxed::box_new([
                                        anchor_lang::idl::types::IdlField {
                                            name: "payer".into(),
                                            docs: ::alloc::vec::Vec::new(),
                                            ty: anchor_lang::idl::types::IdlType::Pubkey,
                                        },
                                        anchor_lang::idl::types::IdlField {
                                            name: "config".into(),
                                            docs: ::alloc::vec::Vec::new(),
                                            ty: anchor_lang::idl::types::IdlType::Pubkey,
                                        },
                                        anchor_lang::idl::types::IdlField {
                                            name: "program_data".into(),
                                            docs: <[_]>::into_vec(
                                                ::alloc::boxed::box_new([
                                                    "The program's data account".into(),
                                                ]),
                                            ),
                                            ty: anchor_lang::idl::types::IdlType::Pubkey,
                                        },
                                        anchor_lang::idl::types::IdlField {
                                            name: "authority".into(),
                                            docs: <[_]>::into_vec(
                                                ::alloc::boxed::box_new([
                                                    "The program's upgrade authority (must sign)".into(),
                                                ]),
                                            ),
                                            ty: anchor_lang::idl::types::IdlType::Pubkey,
                                        },
                                        anchor_lang::idl::types::IdlField {
                                            name: "system_program".into(),
                                            docs: ::alloc::vec::Vec::new(),
                                            ty: anchor_lang::idl::types::IdlType::Pubkey,
                                        },
                                    ]),
                                ),
                            ),
                        ),
                    },
                })
            }
            fn insert_types(
                types: &mut std::collections::BTreeMap<
                    String,
                    anchor_lang::idl::types::IdlTypeDef,
                >,
            ) {}
            fn get_full_path() -> String {
                ::alloc::__export::must_use({
                    ::alloc::fmt::format(
                        format_args!(
                            "{0}::{1}",
                            "raydium_cp_swap::raydium_cp_swap::__client_accounts_initialize_compression_config",
                            "InitializeCompressionConfig",
                        ),
                    )
                })
            }
        }
        #[automatically_derived]
        impl anchor_lang::ToAccountMetas for InitializeCompressionConfig {
            fn to_account_metas(
                &self,
                is_signer: Option<bool>,
            ) -> Vec<anchor_lang::solana_program::instruction::AccountMeta> {
                let mut account_metas = ::alloc::vec::Vec::new();
                account_metas
                    .push(
                        anchor_lang::solana_program::instruction::AccountMeta::new(
                            self.payer,
                            true,
                        ),
                    );
                account_metas
                    .push(
                        anchor_lang::solana_program::instruction::AccountMeta::new(
                            self.config,
                            false,
                        ),
                    );
                account_metas
                    .push(
                        anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                            self.program_data,
                            false,
                        ),
                    );
                account_metas
                    .push(
                        anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                            self.authority,
                            true,
                        ),
                    );
                account_metas
                    .push(
                        anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                            self.system_program,
                            false,
                        ),
                    );
                account_metas
            }
        }
    }
    /// An internal, Anchor generated module. This is used (as an
    /// implementation detail), to generate a CPI struct for a given
    /// `#[derive(Accounts)]` implementation, where each field is an
    /// AccountInfo.
    ///
    /// To access the struct in this module, one should use the sibling
    /// [`cpi::accounts`] module (also generated), which re-exports this.
    pub(crate) mod __cpi_client_accounts_initialize_compression_config {
        use super::*;
        /// Generated CPI struct of the accounts for [`InitializeCompressionConfig`].
        pub struct InitializeCompressionConfig<'info> {
            pub payer: anchor_lang::solana_program::account_info::AccountInfo<'info>,
            pub config: anchor_lang::solana_program::account_info::AccountInfo<'info>,
            ///The program's data account
            pub program_data: anchor_lang::solana_program::account_info::AccountInfo<
                'info,
            >,
            ///The program's upgrade authority (must sign)
            pub authority: anchor_lang::solana_program::account_info::AccountInfo<'info>,
            pub system_program: anchor_lang::solana_program::account_info::AccountInfo<
                'info,
            >,
        }
        #[automatically_derived]
        impl<'info> anchor_lang::ToAccountMetas for InitializeCompressionConfig<'info> {
            fn to_account_metas(
                &self,
                is_signer: Option<bool>,
            ) -> Vec<anchor_lang::solana_program::instruction::AccountMeta> {
                let mut account_metas = ::alloc::vec::Vec::new();
                account_metas
                    .push(
                        anchor_lang::solana_program::instruction::AccountMeta::new(
                            anchor_lang::Key::key(&self.payer),
                            true,
                        ),
                    );
                account_metas
                    .push(
                        anchor_lang::solana_program::instruction::AccountMeta::new(
                            anchor_lang::Key::key(&self.config),
                            false,
                        ),
                    );
                account_metas
                    .push(
                        anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                            anchor_lang::Key::key(&self.program_data),
                            false,
                        ),
                    );
                account_metas
                    .push(
                        anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                            anchor_lang::Key::key(&self.authority),
                            true,
                        ),
                    );
                account_metas
                    .push(
                        anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                            anchor_lang::Key::key(&self.system_program),
                            false,
                        ),
                    );
                account_metas
            }
        }
        #[automatically_derived]
        impl<'info> anchor_lang::ToAccountInfos<'info>
        for InitializeCompressionConfig<'info> {
            fn to_account_infos(
                &self,
            ) -> Vec<anchor_lang::solana_program::account_info::AccountInfo<'info>> {
                let mut account_infos = ::alloc::vec::Vec::new();
                account_infos
                    .extend(anchor_lang::ToAccountInfos::to_account_infos(&self.payer));
                account_infos
                    .extend(anchor_lang::ToAccountInfos::to_account_infos(&self.config));
                account_infos
                    .extend(
                        anchor_lang::ToAccountInfos::to_account_infos(&self.program_data),
                    );
                account_infos
                    .extend(
                        anchor_lang::ToAccountInfos::to_account_infos(&self.authority),
                    );
                account_infos
                    .extend(
                        anchor_lang::ToAccountInfos::to_account_infos(
                            &self.system_program,
                        ),
                    );
                account_infos
            }
        }
    }
    impl<'info> InitializeCompressionConfig<'info> {
        pub fn __anchor_private_gen_idl_accounts(
            accounts: &mut std::collections::BTreeMap<
                String,
                anchor_lang::idl::types::IdlAccount,
            >,
            types: &mut std::collections::BTreeMap<
                String,
                anchor_lang::idl::types::IdlTypeDef,
            >,
        ) -> Vec<anchor_lang::idl::types::IdlInstructionAccountItem> {
            <[_]>::into_vec(
                ::alloc::boxed::box_new([
                    anchor_lang::idl::types::IdlInstructionAccountItem::Single(anchor_lang::idl::types::IdlInstructionAccount {
                        name: "payer".into(),
                        docs: ::alloc::vec::Vec::new(),
                        writable: true,
                        signer: true,
                        optional: false,
                        address: None,
                        pda: None,
                        relations: ::alloc::vec::Vec::new(),
                    }),
                    anchor_lang::idl::types::IdlInstructionAccountItem::Single(anchor_lang::idl::types::IdlInstructionAccount {
                        name: "config".into(),
                        docs: ::alloc::vec::Vec::new(),
                        writable: true,
                        signer: false,
                        optional: false,
                        address: None,
                        pda: None,
                        relations: ::alloc::vec::Vec::new(),
                    }),
                    anchor_lang::idl::types::IdlInstructionAccountItem::Single(anchor_lang::idl::types::IdlInstructionAccount {
                        name: "program_data".into(),
                        docs: <[_]>::into_vec(
                            ::alloc::boxed::box_new([
                                "The program's data account".into(),
                            ]),
                        ),
                        writable: false,
                        signer: false,
                        optional: false,
                        address: None,
                        pda: None,
                        relations: ::alloc::vec::Vec::new(),
                    }),
                    anchor_lang::idl::types::IdlInstructionAccountItem::Single(anchor_lang::idl::types::IdlInstructionAccount {
                        name: "authority".into(),
                        docs: <[_]>::into_vec(
                            ::alloc::boxed::box_new([
                                "The program's upgrade authority (must sign)".into(),
                            ]),
                        ),
                        writable: false,
                        signer: true,
                        optional: false,
                        address: None,
                        pda: None,
                        relations: ::alloc::vec::Vec::new(),
                    }),
                    anchor_lang::idl::types::IdlInstructionAccountItem::Single(anchor_lang::idl::types::IdlInstructionAccount {
                        name: "system_program".into(),
                        docs: ::alloc::vec::Vec::new(),
                        writable: false,
                        signer: false,
                        optional: false,
                        address: None,
                        pda: None,
                        relations: ::alloc::vec::Vec::new(),
                    }),
                ]),
            )
        }
        pub fn __anchor_private_gen_light_metadata() -> Option<
            anchor_lang::idl::types::IdlLightInstructionMeta,
        > {
            None
        }
    }
    pub struct UpdateCompressionConfig<'info> {
        /// CHECK: config account is validated by the SDK
        #[account(mut)]
        pub config: AccountInfo<'info>,
        /// CHECK: authority must be the current update authority
        pub authority: Signer<'info>,
    }
    #[automatically_derived]
    impl<'info> anchor_lang::Accounts<'info, UpdateCompressionConfigBumps>
    for UpdateCompressionConfig<'info>
    where
        'info: 'info,
    {
        #[inline(never)]
        fn try_accounts(
            __program_id: &anchor_lang::solana_program::pubkey::Pubkey,
            __accounts: &mut &'info [anchor_lang::solana_program::account_info::AccountInfo<
                'info,
            >],
            __ix_data: &[u8],
            __bumps: &mut UpdateCompressionConfigBumps,
            __reallocs: &mut std::collections::BTreeSet<
                anchor_lang::solana_program::pubkey::Pubkey,
            >,
        ) -> anchor_lang::Result<Self> {
            let config: AccountInfo = anchor_lang::Accounts::try_accounts(
                    __program_id,
                    __accounts,
                    __ix_data,
                    __bumps,
                    __reallocs,
                )
                .map_err(|e| e.with_account_name("config"))?;
            let authority: Signer = anchor_lang::Accounts::try_accounts(
                    __program_id,
                    __accounts,
                    __ix_data,
                    __bumps,
                    __reallocs,
                )
                .map_err(|e| e.with_account_name("authority"))?;
            if !&config.is_writable {
                return Err(
                    anchor_lang::error::Error::from(
                            anchor_lang::error::ErrorCode::ConstraintMut,
                        )
                        .with_account_name("config"),
                );
            }
            Ok(UpdateCompressionConfig {
                config,
                authority,
            })
        }
    }
    #[automatically_derived]
    impl<'info> anchor_lang::ToAccountInfos<'info> for UpdateCompressionConfig<'info>
    where
        'info: 'info,
    {
        fn to_account_infos(
            &self,
        ) -> Vec<anchor_lang::solana_program::account_info::AccountInfo<'info>> {
            let mut account_infos = ::alloc::vec::Vec::new();
            account_infos.extend(self.config.to_account_infos());
            account_infos.extend(self.authority.to_account_infos());
            account_infos
        }
    }
    #[automatically_derived]
    impl<'info> anchor_lang::ToAccountMetas for UpdateCompressionConfig<'info> {
        fn to_account_metas(
            &self,
            is_signer: Option<bool>,
        ) -> Vec<anchor_lang::solana_program::instruction::AccountMeta> {
            let mut account_metas = ::alloc::vec::Vec::new();
            account_metas.extend(self.config.to_account_metas(None));
            account_metas.extend(self.authority.to_account_metas(None));
            account_metas
        }
    }
    #[automatically_derived]
    impl<'info> anchor_lang::AccountsFinalize<'info, UpdateCompressionConfigBumps>
    for UpdateCompressionConfig<'info>
    where
        'info: 'info,
    {
        fn finalize(
            &mut self,
            program_id: &anchor_lang::solana_program::pubkey::Pubkey,
            _remaining: &[anchor_lang::solana_program::account_info::AccountInfo<'info>],
            _ix_data: &[u8],
            _bumps: &UpdateCompressionConfigBumps,
        ) -> anchor_lang::Result<()> {
            Ok(())
        }
    }
    #[automatically_derived]
    impl<'info> anchor_lang::AccountsExit<'info> for UpdateCompressionConfig<'info>
    where
        'info: 'info,
    {
        fn exit(
            &self,
            program_id: &anchor_lang::solana_program::pubkey::Pubkey,
        ) -> anchor_lang::Result<()> {
            anchor_lang::AccountsExit::exit(&self.config, program_id)
                .map_err(|e| e.with_account_name("config"))?;
            Ok(())
        }
    }
    pub struct UpdateCompressionConfigBumps {}
    #[automatically_derived]
    impl ::core::fmt::Debug for UpdateCompressionConfigBumps {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::write_str(f, "UpdateCompressionConfigBumps")
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for UpdateCompressionConfigBumps {
        #[inline]
        fn clone(&self) -> UpdateCompressionConfigBumps {
            UpdateCompressionConfigBumps {}
        }
    }
    impl Default for UpdateCompressionConfigBumps {
        fn default() -> Self {
            UpdateCompressionConfigBumps {}
        }
    }
    impl<'info> anchor_lang::Bumps for UpdateCompressionConfig<'info>
    where
        'info: 'info,
    {
        type Bumps = UpdateCompressionConfigBumps;
    }
    /// An internal, Anchor generated module. This is used (as an
    /// implementation detail), to generate a struct for a given
    /// `#[derive(Accounts)]` implementation, where each field is a Pubkey,
    /// instead of an `AccountInfo`. This is useful for clients that want
    /// to generate a list of accounts, without explicitly knowing the
    /// order all the fields should be in.
    ///
    /// To access the struct in this module, one should use the sibling
    /// `accounts` module (also generated), which re-exports this.
    pub(crate) mod __client_accounts_update_compression_config {
        use super::*;
        use anchor_lang::prelude::borsh;
        /// Generated client accounts for [`UpdateCompressionConfig`].
        pub struct UpdateCompressionConfig {
            pub config: Pubkey,
            pub authority: Pubkey,
        }
        impl borsh::ser::BorshSerialize for UpdateCompressionConfig
        where
            Pubkey: borsh::ser::BorshSerialize,
            Pubkey: borsh::ser::BorshSerialize,
        {
            fn serialize<W: borsh::maybestd::io::Write>(
                &self,
                writer: &mut W,
            ) -> ::core::result::Result<(), borsh::maybestd::io::Error> {
                borsh::BorshSerialize::serialize(&self.config, writer)?;
                borsh::BorshSerialize::serialize(&self.authority, writer)?;
                Ok(())
            }
        }
        impl anchor_lang::idl::build::IdlBuild for UpdateCompressionConfig {
            fn create_type() -> Option<anchor_lang::idl::types::IdlTypeDef> {
                Some(anchor_lang::idl::types::IdlTypeDef {
                    name: Self::get_full_path(),
                    docs: <[_]>::into_vec(
                        ::alloc::boxed::box_new([
                            "Generated client accounts for [`UpdateCompressionConfig`]."
                                .into(),
                        ]),
                    ),
                    serialization: anchor_lang::idl::types::IdlSerialization::default(),
                    repr: None,
                    generics: ::alloc::vec::Vec::new(),
                    ty: anchor_lang::idl::types::IdlTypeDefTy::Struct {
                        fields: Some(
                            anchor_lang::idl::types::IdlDefinedFields::Named(
                                <[_]>::into_vec(
                                    ::alloc::boxed::box_new([
                                        anchor_lang::idl::types::IdlField {
                                            name: "config".into(),
                                            docs: ::alloc::vec::Vec::new(),
                                            ty: anchor_lang::idl::types::IdlType::Pubkey,
                                        },
                                        anchor_lang::idl::types::IdlField {
                                            name: "authority".into(),
                                            docs: ::alloc::vec::Vec::new(),
                                            ty: anchor_lang::idl::types::IdlType::Pubkey,
                                        },
                                    ]),
                                ),
                            ),
                        ),
                    },
                })
            }
            fn insert_types(
                types: &mut std::collections::BTreeMap<
                    String,
                    anchor_lang::idl::types::IdlTypeDef,
                >,
            ) {}
            fn get_full_path() -> String {
                ::alloc::__export::must_use({
                    ::alloc::fmt::format(
                        format_args!(
                            "{0}::{1}",
                            "raydium_cp_swap::raydium_cp_swap::__client_accounts_update_compression_config",
                            "UpdateCompressionConfig",
                        ),
                    )
                })
            }
        }
        #[automatically_derived]
        impl anchor_lang::ToAccountMetas for UpdateCompressionConfig {
            fn to_account_metas(
                &self,
                is_signer: Option<bool>,
            ) -> Vec<anchor_lang::solana_program::instruction::AccountMeta> {
                let mut account_metas = ::alloc::vec::Vec::new();
                account_metas
                    .push(
                        anchor_lang::solana_program::instruction::AccountMeta::new(
                            self.config,
                            false,
                        ),
                    );
                account_metas
                    .push(
                        anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                            self.authority,
                            true,
                        ),
                    );
                account_metas
            }
        }
    }
    /// An internal, Anchor generated module. This is used (as an
    /// implementation detail), to generate a CPI struct for a given
    /// `#[derive(Accounts)]` implementation, where each field is an
    /// AccountInfo.
    ///
    /// To access the struct in this module, one should use the sibling
    /// [`cpi::accounts`] module (also generated), which re-exports this.
    pub(crate) mod __cpi_client_accounts_update_compression_config {
        use super::*;
        /// Generated CPI struct of the accounts for [`UpdateCompressionConfig`].
        pub struct UpdateCompressionConfig<'info> {
            pub config: anchor_lang::solana_program::account_info::AccountInfo<'info>,
            pub authority: anchor_lang::solana_program::account_info::AccountInfo<'info>,
        }
        #[automatically_derived]
        impl<'info> anchor_lang::ToAccountMetas for UpdateCompressionConfig<'info> {
            fn to_account_metas(
                &self,
                is_signer: Option<bool>,
            ) -> Vec<anchor_lang::solana_program::instruction::AccountMeta> {
                let mut account_metas = ::alloc::vec::Vec::new();
                account_metas
                    .push(
                        anchor_lang::solana_program::instruction::AccountMeta::new(
                            anchor_lang::Key::key(&self.config),
                            false,
                        ),
                    );
                account_metas
                    .push(
                        anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                            anchor_lang::Key::key(&self.authority),
                            true,
                        ),
                    );
                account_metas
            }
        }
        #[automatically_derived]
        impl<'info> anchor_lang::ToAccountInfos<'info>
        for UpdateCompressionConfig<'info> {
            fn to_account_infos(
                &self,
            ) -> Vec<anchor_lang::solana_program::account_info::AccountInfo<'info>> {
                let mut account_infos = ::alloc::vec::Vec::new();
                account_infos
                    .extend(anchor_lang::ToAccountInfos::to_account_infos(&self.config));
                account_infos
                    .extend(
                        anchor_lang::ToAccountInfos::to_account_infos(&self.authority),
                    );
                account_infos
            }
        }
    }
    impl<'info> UpdateCompressionConfig<'info> {
        pub fn __anchor_private_gen_idl_accounts(
            accounts: &mut std::collections::BTreeMap<
                String,
                anchor_lang::idl::types::IdlAccount,
            >,
            types: &mut std::collections::BTreeMap<
                String,
                anchor_lang::idl::types::IdlTypeDef,
            >,
        ) -> Vec<anchor_lang::idl::types::IdlInstructionAccountItem> {
            <[_]>::into_vec(
                ::alloc::boxed::box_new([
                    anchor_lang::idl::types::IdlInstructionAccountItem::Single(anchor_lang::idl::types::IdlInstructionAccount {
                        name: "config".into(),
                        docs: ::alloc::vec::Vec::new(),
                        writable: true,
                        signer: false,
                        optional: false,
                        address: None,
                        pda: None,
                        relations: ::alloc::vec::Vec::new(),
                    }),
                    anchor_lang::idl::types::IdlInstructionAccountItem::Single(anchor_lang::idl::types::IdlInstructionAccount {
                        name: "authority".into(),
                        docs: ::alloc::vec::Vec::new(),
                        writable: false,
                        signer: true,
                        optional: false,
                        address: None,
                        pda: None,
                        relations: ::alloc::vec::Vec::new(),
                    }),
                ]),
            )
        }
        pub fn __anchor_private_gen_light_metadata() -> Option<
            anchor_lang::idl::types::IdlLightInstructionMeta,
        > {
            None
        }
    }
    /// Initialize compression config for the program
    #[inline(never)]
    pub fn initialize_compression_config<'info>(
        ctx: Context<'_, '_, '_, 'info, InitializeCompressionConfig<'info>>,
        compression_delay: u32,
        rent_recipient: Pubkey,
        address_space: Vec<Pubkey>,
    ) -> Result<()> {
        light_sdk::compressible::process_initialize_compression_config_checked(
                &ctx.accounts.config.to_account_info(),
                &ctx.accounts.authority.to_account_info(),
                &ctx.accounts.program_data.to_account_info(),
                &rent_recipient,
                address_space,
                compression_delay,
                0,
                &ctx.accounts.payer.to_account_info(),
                &ctx.accounts.system_program.to_account_info(),
                &crate::ID,
            )
            .map_err(|e| anchor_lang::error::Error::from(e))
    }
    /// Update compression config for the program
    #[inline(never)]
    pub fn update_compression_config<'info>(
        ctx: Context<'_, '_, '_, 'info, UpdateCompressionConfig<'info>>,
        new_compression_delay: Option<u32>,
        new_rent_recipient: Option<Pubkey>,
        new_address_space: Option<Vec<Pubkey>>,
        new_update_authority: Option<Pubkey>,
    ) -> Result<()> {
        light_sdk::compressible::process_update_compression_config(
                ctx.accounts.config.as_ref(),
                ctx.accounts.authority.as_ref(),
                new_update_authority.as_ref(),
                new_rent_recipient.as_ref(),
                new_address_space,
                new_compression_delay,
                &crate::ID,
            )
            .map_err(|e| anchor_lang::error::Error::from(e))
    }
}
/// An Anchor generated module containing the program's set of
/// instructions, where each method handler in the `#[program]` mod is
/// associated with a struct defining the input arguments to the
/// method. These should be used directly, when one wants to serialize
/// Anchor instruction data, for example, when speciying
/// instructions on a client.
pub mod instruction {
    use super::*;
    /// Instruction.
    pub struct CreateAmmConfig {
        pub index: u16,
        pub trade_fee_rate: u64,
        pub protocol_fee_rate: u64,
        pub fund_fee_rate: u64,
        pub create_pool_fee: u64,
    }
    impl borsh::ser::BorshSerialize for CreateAmmConfig
    where
        u16: borsh::ser::BorshSerialize,
        u64: borsh::ser::BorshSerialize,
        u64: borsh::ser::BorshSerialize,
        u64: borsh::ser::BorshSerialize,
        u64: borsh::ser::BorshSerialize,
    {
        fn serialize<W: borsh::maybestd::io::Write>(
            &self,
            writer: &mut W,
        ) -> ::core::result::Result<(), borsh::maybestd::io::Error> {
            borsh::BorshSerialize::serialize(&self.index, writer)?;
            borsh::BorshSerialize::serialize(&self.trade_fee_rate, writer)?;
            borsh::BorshSerialize::serialize(&self.protocol_fee_rate, writer)?;
            borsh::BorshSerialize::serialize(&self.fund_fee_rate, writer)?;
            borsh::BorshSerialize::serialize(&self.create_pool_fee, writer)?;
            Ok(())
        }
    }
    impl anchor_lang::idl::build::IdlBuild for CreateAmmConfig {
        fn create_type() -> Option<anchor_lang::idl::types::IdlTypeDef> {
            Some(anchor_lang::idl::types::IdlTypeDef {
                name: Self::get_full_path(),
                docs: <[_]>::into_vec(::alloc::boxed::box_new(["Instruction.".into()])),
                serialization: anchor_lang::idl::types::IdlSerialization::default(),
                repr: None,
                generics: ::alloc::vec::Vec::new(),
                ty: anchor_lang::idl::types::IdlTypeDefTy::Struct {
                    fields: Some(
                        anchor_lang::idl::types::IdlDefinedFields::Named(
                            <[_]>::into_vec(
                                ::alloc::boxed::box_new([
                                    anchor_lang::idl::types::IdlField {
                                        name: "index".into(),
                                        docs: ::alloc::vec::Vec::new(),
                                        ty: anchor_lang::idl::types::IdlType::U16,
                                    },
                                    anchor_lang::idl::types::IdlField {
                                        name: "trade_fee_rate".into(),
                                        docs: ::alloc::vec::Vec::new(),
                                        ty: anchor_lang::idl::types::IdlType::U64,
                                    },
                                    anchor_lang::idl::types::IdlField {
                                        name: "protocol_fee_rate".into(),
                                        docs: ::alloc::vec::Vec::new(),
                                        ty: anchor_lang::idl::types::IdlType::U64,
                                    },
                                    anchor_lang::idl::types::IdlField {
                                        name: "fund_fee_rate".into(),
                                        docs: ::alloc::vec::Vec::new(),
                                        ty: anchor_lang::idl::types::IdlType::U64,
                                    },
                                    anchor_lang::idl::types::IdlField {
                                        name: "create_pool_fee".into(),
                                        docs: ::alloc::vec::Vec::new(),
                                        ty: anchor_lang::idl::types::IdlType::U64,
                                    },
                                ]),
                            ),
                        ),
                    ),
                },
            })
        }
        fn insert_types(
            types: &mut std::collections::BTreeMap<
                String,
                anchor_lang::idl::types::IdlTypeDef,
            >,
        ) {}
        fn get_full_path() -> String {
            ::alloc::__export::must_use({
                ::alloc::fmt::format(
                    format_args!(
                        "{0}::{1}",
                        "raydium_cp_swap::instruction",
                        "CreateAmmConfig",
                    ),
                )
            })
        }
    }
    impl borsh::de::BorshDeserialize for CreateAmmConfig
    where
        u16: borsh::BorshDeserialize,
        u64: borsh::BorshDeserialize,
        u64: borsh::BorshDeserialize,
        u64: borsh::BorshDeserialize,
        u64: borsh::BorshDeserialize,
    {
        fn deserialize_reader<R: borsh::maybestd::io::Read>(
            reader: &mut R,
        ) -> ::core::result::Result<Self, borsh::maybestd::io::Error> {
            Ok(Self {
                index: borsh::BorshDeserialize::deserialize_reader(reader)?,
                trade_fee_rate: borsh::BorshDeserialize::deserialize_reader(reader)?,
                protocol_fee_rate: borsh::BorshDeserialize::deserialize_reader(reader)?,
                fund_fee_rate: borsh::BorshDeserialize::deserialize_reader(reader)?,
                create_pool_fee: borsh::BorshDeserialize::deserialize_reader(reader)?,
            })
        }
    }
    impl anchor_lang::Discriminator for CreateAmmConfig {
        const DISCRIMINATOR: &'static [u8] = &[137, 52, 237, 212, 215, 117, 108, 104];
    }
    impl anchor_lang::InstructionData for CreateAmmConfig {}
    impl anchor_lang::Owner for CreateAmmConfig {
        fn owner() -> Pubkey {
            ID
        }
    }
    /// Instruction.
    pub struct UpdateAmmConfig {
        pub param: u8,
        pub value: u64,
    }
    impl borsh::ser::BorshSerialize for UpdateAmmConfig
    where
        u8: borsh::ser::BorshSerialize,
        u64: borsh::ser::BorshSerialize,
    {
        fn serialize<W: borsh::maybestd::io::Write>(
            &self,
            writer: &mut W,
        ) -> ::core::result::Result<(), borsh::maybestd::io::Error> {
            borsh::BorshSerialize::serialize(&self.param, writer)?;
            borsh::BorshSerialize::serialize(&self.value, writer)?;
            Ok(())
        }
    }
    impl anchor_lang::idl::build::IdlBuild for UpdateAmmConfig {
        fn create_type() -> Option<anchor_lang::idl::types::IdlTypeDef> {
            Some(anchor_lang::idl::types::IdlTypeDef {
                name: Self::get_full_path(),
                docs: <[_]>::into_vec(::alloc::boxed::box_new(["Instruction.".into()])),
                serialization: anchor_lang::idl::types::IdlSerialization::default(),
                repr: None,
                generics: ::alloc::vec::Vec::new(),
                ty: anchor_lang::idl::types::IdlTypeDefTy::Struct {
                    fields: Some(
                        anchor_lang::idl::types::IdlDefinedFields::Named(
                            <[_]>::into_vec(
                                ::alloc::boxed::box_new([
                                    anchor_lang::idl::types::IdlField {
                                        name: "param".into(),
                                        docs: ::alloc::vec::Vec::new(),
                                        ty: anchor_lang::idl::types::IdlType::U8,
                                    },
                                    anchor_lang::idl::types::IdlField {
                                        name: "value".into(),
                                        docs: ::alloc::vec::Vec::new(),
                                        ty: anchor_lang::idl::types::IdlType::U64,
                                    },
                                ]),
                            ),
                        ),
                    ),
                },
            })
        }
        fn insert_types(
            types: &mut std::collections::BTreeMap<
                String,
                anchor_lang::idl::types::IdlTypeDef,
            >,
        ) {}
        fn get_full_path() -> String {
            ::alloc::__export::must_use({
                ::alloc::fmt::format(
                    format_args!(
                        "{0}::{1}",
                        "raydium_cp_swap::instruction",
                        "UpdateAmmConfig",
                    ),
                )
            })
        }
    }
    impl borsh::de::BorshDeserialize for UpdateAmmConfig
    where
        u8: borsh::BorshDeserialize,
        u64: borsh::BorshDeserialize,
    {
        fn deserialize_reader<R: borsh::maybestd::io::Read>(
            reader: &mut R,
        ) -> ::core::result::Result<Self, borsh::maybestd::io::Error> {
            Ok(Self {
                param: borsh::BorshDeserialize::deserialize_reader(reader)?,
                value: borsh::BorshDeserialize::deserialize_reader(reader)?,
            })
        }
    }
    impl anchor_lang::Discriminator for UpdateAmmConfig {
        const DISCRIMINATOR: &'static [u8] = &[49, 60, 174, 136, 154, 28, 116, 200];
    }
    impl anchor_lang::InstructionData for UpdateAmmConfig {}
    impl anchor_lang::Owner for UpdateAmmConfig {
        fn owner() -> Pubkey {
            ID
        }
    }
    /// Instruction.
    pub struct UpdatePoolStatus {
        pub status: u8,
    }
    impl borsh::ser::BorshSerialize for UpdatePoolStatus
    where
        u8: borsh::ser::BorshSerialize,
    {
        fn serialize<W: borsh::maybestd::io::Write>(
            &self,
            writer: &mut W,
        ) -> ::core::result::Result<(), borsh::maybestd::io::Error> {
            borsh::BorshSerialize::serialize(&self.status, writer)?;
            Ok(())
        }
    }
    impl anchor_lang::idl::build::IdlBuild for UpdatePoolStatus {
        fn create_type() -> Option<anchor_lang::idl::types::IdlTypeDef> {
            Some(anchor_lang::idl::types::IdlTypeDef {
                name: Self::get_full_path(),
                docs: <[_]>::into_vec(::alloc::boxed::box_new(["Instruction.".into()])),
                serialization: anchor_lang::idl::types::IdlSerialization::default(),
                repr: None,
                generics: ::alloc::vec::Vec::new(),
                ty: anchor_lang::idl::types::IdlTypeDefTy::Struct {
                    fields: Some(
                        anchor_lang::idl::types::IdlDefinedFields::Named(
                            <[_]>::into_vec(
                                ::alloc::boxed::box_new([
                                    anchor_lang::idl::types::IdlField {
                                        name: "status".into(),
                                        docs: ::alloc::vec::Vec::new(),
                                        ty: anchor_lang::idl::types::IdlType::U8,
                                    },
                                ]),
                            ),
                        ),
                    ),
                },
            })
        }
        fn insert_types(
            types: &mut std::collections::BTreeMap<
                String,
                anchor_lang::idl::types::IdlTypeDef,
            >,
        ) {}
        fn get_full_path() -> String {
            ::alloc::__export::must_use({
                ::alloc::fmt::format(
                    format_args!(
                        "{0}::{1}",
                        "raydium_cp_swap::instruction",
                        "UpdatePoolStatus",
                    ),
                )
            })
        }
    }
    impl borsh::de::BorshDeserialize for UpdatePoolStatus
    where
        u8: borsh::BorshDeserialize,
    {
        fn deserialize_reader<R: borsh::maybestd::io::Read>(
            reader: &mut R,
        ) -> ::core::result::Result<Self, borsh::maybestd::io::Error> {
            Ok(Self {
                status: borsh::BorshDeserialize::deserialize_reader(reader)?,
            })
        }
    }
    impl anchor_lang::Discriminator for UpdatePoolStatus {
        const DISCRIMINATOR: &'static [u8] = &[130, 87, 108, 6, 46, 224, 117, 123];
    }
    impl anchor_lang::InstructionData for UpdatePoolStatus {}
    impl anchor_lang::Owner for UpdatePoolStatus {
        fn owner() -> Pubkey {
            ID
        }
    }
    /// Instruction.
    pub struct CollectProtocolFee {
        pub amount_0_requested: u64,
        pub amount_1_requested: u64,
    }
    impl borsh::ser::BorshSerialize for CollectProtocolFee
    where
        u64: borsh::ser::BorshSerialize,
        u64: borsh::ser::BorshSerialize,
    {
        fn serialize<W: borsh::maybestd::io::Write>(
            &self,
            writer: &mut W,
        ) -> ::core::result::Result<(), borsh::maybestd::io::Error> {
            borsh::BorshSerialize::serialize(&self.amount_0_requested, writer)?;
            borsh::BorshSerialize::serialize(&self.amount_1_requested, writer)?;
            Ok(())
        }
    }
    impl anchor_lang::idl::build::IdlBuild for CollectProtocolFee {
        fn create_type() -> Option<anchor_lang::idl::types::IdlTypeDef> {
            Some(anchor_lang::idl::types::IdlTypeDef {
                name: Self::get_full_path(),
                docs: <[_]>::into_vec(::alloc::boxed::box_new(["Instruction.".into()])),
                serialization: anchor_lang::idl::types::IdlSerialization::default(),
                repr: None,
                generics: ::alloc::vec::Vec::new(),
                ty: anchor_lang::idl::types::IdlTypeDefTy::Struct {
                    fields: Some(
                        anchor_lang::idl::types::IdlDefinedFields::Named(
                            <[_]>::into_vec(
                                ::alloc::boxed::box_new([
                                    anchor_lang::idl::types::IdlField {
                                        name: "amount_0_requested".into(),
                                        docs: ::alloc::vec::Vec::new(),
                                        ty: anchor_lang::idl::types::IdlType::U64,
                                    },
                                    anchor_lang::idl::types::IdlField {
                                        name: "amount_1_requested".into(),
                                        docs: ::alloc::vec::Vec::new(),
                                        ty: anchor_lang::idl::types::IdlType::U64,
                                    },
                                ]),
                            ),
                        ),
                    ),
                },
            })
        }
        fn insert_types(
            types: &mut std::collections::BTreeMap<
                String,
                anchor_lang::idl::types::IdlTypeDef,
            >,
        ) {}
        fn get_full_path() -> String {
            ::alloc::__export::must_use({
                ::alloc::fmt::format(
                    format_args!(
                        "{0}::{1}",
                        "raydium_cp_swap::instruction",
                        "CollectProtocolFee",
                    ),
                )
            })
        }
    }
    impl borsh::de::BorshDeserialize for CollectProtocolFee
    where
        u64: borsh::BorshDeserialize,
        u64: borsh::BorshDeserialize,
    {
        fn deserialize_reader<R: borsh::maybestd::io::Read>(
            reader: &mut R,
        ) -> ::core::result::Result<Self, borsh::maybestd::io::Error> {
            Ok(Self {
                amount_0_requested: borsh::BorshDeserialize::deserialize_reader(reader)?,
                amount_1_requested: borsh::BorshDeserialize::deserialize_reader(reader)?,
            })
        }
    }
    impl anchor_lang::Discriminator for CollectProtocolFee {
        const DISCRIMINATOR: &'static [u8] = &[136, 136, 252, 221, 194, 66, 126, 89];
    }
    impl anchor_lang::InstructionData for CollectProtocolFee {}
    impl anchor_lang::Owner for CollectProtocolFee {
        fn owner() -> Pubkey {
            ID
        }
    }
    /// Instruction.
    pub struct CollectFundFee {
        pub amount_0_requested: u64,
        pub amount_1_requested: u64,
    }
    impl borsh::ser::BorshSerialize for CollectFundFee
    where
        u64: borsh::ser::BorshSerialize,
        u64: borsh::ser::BorshSerialize,
    {
        fn serialize<W: borsh::maybestd::io::Write>(
            &self,
            writer: &mut W,
        ) -> ::core::result::Result<(), borsh::maybestd::io::Error> {
            borsh::BorshSerialize::serialize(&self.amount_0_requested, writer)?;
            borsh::BorshSerialize::serialize(&self.amount_1_requested, writer)?;
            Ok(())
        }
    }
    impl anchor_lang::idl::build::IdlBuild for CollectFundFee {
        fn create_type() -> Option<anchor_lang::idl::types::IdlTypeDef> {
            Some(anchor_lang::idl::types::IdlTypeDef {
                name: Self::get_full_path(),
                docs: <[_]>::into_vec(::alloc::boxed::box_new(["Instruction.".into()])),
                serialization: anchor_lang::idl::types::IdlSerialization::default(),
                repr: None,
                generics: ::alloc::vec::Vec::new(),
                ty: anchor_lang::idl::types::IdlTypeDefTy::Struct {
                    fields: Some(
                        anchor_lang::idl::types::IdlDefinedFields::Named(
                            <[_]>::into_vec(
                                ::alloc::boxed::box_new([
                                    anchor_lang::idl::types::IdlField {
                                        name: "amount_0_requested".into(),
                                        docs: ::alloc::vec::Vec::new(),
                                        ty: anchor_lang::idl::types::IdlType::U64,
                                    },
                                    anchor_lang::idl::types::IdlField {
                                        name: "amount_1_requested".into(),
                                        docs: ::alloc::vec::Vec::new(),
                                        ty: anchor_lang::idl::types::IdlType::U64,
                                    },
                                ]),
                            ),
                        ),
                    ),
                },
            })
        }
        fn insert_types(
            types: &mut std::collections::BTreeMap<
                String,
                anchor_lang::idl::types::IdlTypeDef,
            >,
        ) {}
        fn get_full_path() -> String {
            ::alloc::__export::must_use({
                ::alloc::fmt::format(
                    format_args!(
                        "{0}::{1}",
                        "raydium_cp_swap::instruction",
                        "CollectFundFee",
                    ),
                )
            })
        }
    }
    impl borsh::de::BorshDeserialize for CollectFundFee
    where
        u64: borsh::BorshDeserialize,
        u64: borsh::BorshDeserialize,
    {
        fn deserialize_reader<R: borsh::maybestd::io::Read>(
            reader: &mut R,
        ) -> ::core::result::Result<Self, borsh::maybestd::io::Error> {
            Ok(Self {
                amount_0_requested: borsh::BorshDeserialize::deserialize_reader(reader)?,
                amount_1_requested: borsh::BorshDeserialize::deserialize_reader(reader)?,
            })
        }
    }
    impl anchor_lang::Discriminator for CollectFundFee {
        const DISCRIMINATOR: &'static [u8] = &[167, 138, 78, 149, 223, 194, 6, 126];
    }
    impl anchor_lang::InstructionData for CollectFundFee {}
    impl anchor_lang::Owner for CollectFundFee {
        fn owner() -> Pubkey {
            ID
        }
    }
    /// Instruction.
    pub struct Initialize {
        pub init_amount_0: u64,
        pub init_amount_1: u64,
        pub open_time: u64,
        pub compression_params: InitializeCompressionParams,
    }
    impl borsh::ser::BorshSerialize for Initialize
    where
        u64: borsh::ser::BorshSerialize,
        u64: borsh::ser::BorshSerialize,
        u64: borsh::ser::BorshSerialize,
        InitializeCompressionParams: borsh::ser::BorshSerialize,
    {
        fn serialize<W: borsh::maybestd::io::Write>(
            &self,
            writer: &mut W,
        ) -> ::core::result::Result<(), borsh::maybestd::io::Error> {
            borsh::BorshSerialize::serialize(&self.init_amount_0, writer)?;
            borsh::BorshSerialize::serialize(&self.init_amount_1, writer)?;
            borsh::BorshSerialize::serialize(&self.open_time, writer)?;
            borsh::BorshSerialize::serialize(&self.compression_params, writer)?;
            Ok(())
        }
    }
    impl anchor_lang::idl::build::IdlBuild for Initialize {
        fn create_type() -> Option<anchor_lang::idl::types::IdlTypeDef> {
            Some(anchor_lang::idl::types::IdlTypeDef {
                name: Self::get_full_path(),
                docs: <[_]>::into_vec(::alloc::boxed::box_new(["Instruction.".into()])),
                serialization: anchor_lang::idl::types::IdlSerialization::default(),
                repr: None,
                generics: ::alloc::vec::Vec::new(),
                ty: anchor_lang::idl::types::IdlTypeDefTy::Struct {
                    fields: Some(
                        anchor_lang::idl::types::IdlDefinedFields::Named(
                            <[_]>::into_vec(
                                ::alloc::boxed::box_new([
                                    anchor_lang::idl::types::IdlField {
                                        name: "init_amount_0".into(),
                                        docs: ::alloc::vec::Vec::new(),
                                        ty: anchor_lang::idl::types::IdlType::U64,
                                    },
                                    anchor_lang::idl::types::IdlField {
                                        name: "init_amount_1".into(),
                                        docs: ::alloc::vec::Vec::new(),
                                        ty: anchor_lang::idl::types::IdlType::U64,
                                    },
                                    anchor_lang::idl::types::IdlField {
                                        name: "open_time".into(),
                                        docs: ::alloc::vec::Vec::new(),
                                        ty: anchor_lang::idl::types::IdlType::U64,
                                    },
                                    anchor_lang::idl::types::IdlField {
                                        name: "compression_params".into(),
                                        docs: ::alloc::vec::Vec::new(),
                                        ty: anchor_lang::idl::types::IdlType::Defined {
                                            name: <InitializeCompressionParams>::get_full_path(),
                                            generics: ::alloc::vec::Vec::new(),
                                        },
                                    },
                                ]),
                            ),
                        ),
                    ),
                },
            })
        }
        fn insert_types(
            types: &mut std::collections::BTreeMap<
                String,
                anchor_lang::idl::types::IdlTypeDef,
            >,
        ) {
            if let Some(ty) = <InitializeCompressionParams>::create_type() {
                types.insert(<InitializeCompressionParams>::get_full_path(), ty);
                <InitializeCompressionParams>::insert_types(types);
            }
        }
        fn get_full_path() -> String {
            ::alloc::__export::must_use({
                ::alloc::fmt::format(
                    format_args!(
                        "{0}::{1}",
                        "raydium_cp_swap::instruction",
                        "Initialize",
                    ),
                )
            })
        }
    }
    impl borsh::de::BorshDeserialize for Initialize
    where
        u64: borsh::BorshDeserialize,
        u64: borsh::BorshDeserialize,
        u64: borsh::BorshDeserialize,
        InitializeCompressionParams: borsh::BorshDeserialize,
    {
        fn deserialize_reader<R: borsh::maybestd::io::Read>(
            reader: &mut R,
        ) -> ::core::result::Result<Self, borsh::maybestd::io::Error> {
            Ok(Self {
                init_amount_0: borsh::BorshDeserialize::deserialize_reader(reader)?,
                init_amount_1: borsh::BorshDeserialize::deserialize_reader(reader)?,
                open_time: borsh::BorshDeserialize::deserialize_reader(reader)?,
                compression_params: borsh::BorshDeserialize::deserialize_reader(reader)?,
            })
        }
    }
    impl anchor_lang::Discriminator for Initialize {
        const DISCRIMINATOR: &'static [u8] = &[175, 175, 109, 31, 13, 152, 155, 237];
    }
    impl anchor_lang::InstructionData for Initialize {}
    impl anchor_lang::Owner for Initialize {
        fn owner() -> Pubkey {
            ID
        }
    }
    /// Instruction.
    pub struct Deposit {
        pub lp_token_amount: u64,
        pub maximum_token_0_amount: u64,
        pub maximum_token_1_amount: u64,
    }
    impl borsh::ser::BorshSerialize for Deposit
    where
        u64: borsh::ser::BorshSerialize,
        u64: borsh::ser::BorshSerialize,
        u64: borsh::ser::BorshSerialize,
    {
        fn serialize<W: borsh::maybestd::io::Write>(
            &self,
            writer: &mut W,
        ) -> ::core::result::Result<(), borsh::maybestd::io::Error> {
            borsh::BorshSerialize::serialize(&self.lp_token_amount, writer)?;
            borsh::BorshSerialize::serialize(&self.maximum_token_0_amount, writer)?;
            borsh::BorshSerialize::serialize(&self.maximum_token_1_amount, writer)?;
            Ok(())
        }
    }
    impl anchor_lang::idl::build::IdlBuild for Deposit {
        fn create_type() -> Option<anchor_lang::idl::types::IdlTypeDef> {
            Some(anchor_lang::idl::types::IdlTypeDef {
                name: Self::get_full_path(),
                docs: <[_]>::into_vec(::alloc::boxed::box_new(["Instruction.".into()])),
                serialization: anchor_lang::idl::types::IdlSerialization::default(),
                repr: None,
                generics: ::alloc::vec::Vec::new(),
                ty: anchor_lang::idl::types::IdlTypeDefTy::Struct {
                    fields: Some(
                        anchor_lang::idl::types::IdlDefinedFields::Named(
                            <[_]>::into_vec(
                                ::alloc::boxed::box_new([
                                    anchor_lang::idl::types::IdlField {
                                        name: "lp_token_amount".into(),
                                        docs: ::alloc::vec::Vec::new(),
                                        ty: anchor_lang::idl::types::IdlType::U64,
                                    },
                                    anchor_lang::idl::types::IdlField {
                                        name: "maximum_token_0_amount".into(),
                                        docs: ::alloc::vec::Vec::new(),
                                        ty: anchor_lang::idl::types::IdlType::U64,
                                    },
                                    anchor_lang::idl::types::IdlField {
                                        name: "maximum_token_1_amount".into(),
                                        docs: ::alloc::vec::Vec::new(),
                                        ty: anchor_lang::idl::types::IdlType::U64,
                                    },
                                ]),
                            ),
                        ),
                    ),
                },
            })
        }
        fn insert_types(
            types: &mut std::collections::BTreeMap<
                String,
                anchor_lang::idl::types::IdlTypeDef,
            >,
        ) {}
        fn get_full_path() -> String {
            ::alloc::__export::must_use({
                ::alloc::fmt::format(
                    format_args!("{0}::{1}", "raydium_cp_swap::instruction", "Deposit"),
                )
            })
        }
    }
    impl borsh::de::BorshDeserialize for Deposit
    where
        u64: borsh::BorshDeserialize,
        u64: borsh::BorshDeserialize,
        u64: borsh::BorshDeserialize,
    {
        fn deserialize_reader<R: borsh::maybestd::io::Read>(
            reader: &mut R,
        ) -> ::core::result::Result<Self, borsh::maybestd::io::Error> {
            Ok(Self {
                lp_token_amount: borsh::BorshDeserialize::deserialize_reader(reader)?,
                maximum_token_0_amount: borsh::BorshDeserialize::deserialize_reader(
                    reader,
                )?,
                maximum_token_1_amount: borsh::BorshDeserialize::deserialize_reader(
                    reader,
                )?,
            })
        }
    }
    impl anchor_lang::Discriminator for Deposit {
        const DISCRIMINATOR: &'static [u8] = &[242, 35, 198, 137, 82, 225, 242, 182];
    }
    impl anchor_lang::InstructionData for Deposit {}
    impl anchor_lang::Owner for Deposit {
        fn owner() -> Pubkey {
            ID
        }
    }
    /// Instruction.
    pub struct Withdraw {
        pub lp_token_amount: u64,
        pub minimum_token_0_amount: u64,
        pub minimum_token_1_amount: u64,
    }
    impl borsh::ser::BorshSerialize for Withdraw
    where
        u64: borsh::ser::BorshSerialize,
        u64: borsh::ser::BorshSerialize,
        u64: borsh::ser::BorshSerialize,
    {
        fn serialize<W: borsh::maybestd::io::Write>(
            &self,
            writer: &mut W,
        ) -> ::core::result::Result<(), borsh::maybestd::io::Error> {
            borsh::BorshSerialize::serialize(&self.lp_token_amount, writer)?;
            borsh::BorshSerialize::serialize(&self.minimum_token_0_amount, writer)?;
            borsh::BorshSerialize::serialize(&self.minimum_token_1_amount, writer)?;
            Ok(())
        }
    }
    impl anchor_lang::idl::build::IdlBuild for Withdraw {
        fn create_type() -> Option<anchor_lang::idl::types::IdlTypeDef> {
            Some(anchor_lang::idl::types::IdlTypeDef {
                name: Self::get_full_path(),
                docs: <[_]>::into_vec(::alloc::boxed::box_new(["Instruction.".into()])),
                serialization: anchor_lang::idl::types::IdlSerialization::default(),
                repr: None,
                generics: ::alloc::vec::Vec::new(),
                ty: anchor_lang::idl::types::IdlTypeDefTy::Struct {
                    fields: Some(
                        anchor_lang::idl::types::IdlDefinedFields::Named(
                            <[_]>::into_vec(
                                ::alloc::boxed::box_new([
                                    anchor_lang::idl::types::IdlField {
                                        name: "lp_token_amount".into(),
                                        docs: ::alloc::vec::Vec::new(),
                                        ty: anchor_lang::idl::types::IdlType::U64,
                                    },
                                    anchor_lang::idl::types::IdlField {
                                        name: "minimum_token_0_amount".into(),
                                        docs: ::alloc::vec::Vec::new(),
                                        ty: anchor_lang::idl::types::IdlType::U64,
                                    },
                                    anchor_lang::idl::types::IdlField {
                                        name: "minimum_token_1_amount".into(),
                                        docs: ::alloc::vec::Vec::new(),
                                        ty: anchor_lang::idl::types::IdlType::U64,
                                    },
                                ]),
                            ),
                        ),
                    ),
                },
            })
        }
        fn insert_types(
            types: &mut std::collections::BTreeMap<
                String,
                anchor_lang::idl::types::IdlTypeDef,
            >,
        ) {}
        fn get_full_path() -> String {
            ::alloc::__export::must_use({
                ::alloc::fmt::format(
                    format_args!("{0}::{1}", "raydium_cp_swap::instruction", "Withdraw"),
                )
            })
        }
    }
    impl borsh::de::BorshDeserialize for Withdraw
    where
        u64: borsh::BorshDeserialize,
        u64: borsh::BorshDeserialize,
        u64: borsh::BorshDeserialize,
    {
        fn deserialize_reader<R: borsh::maybestd::io::Read>(
            reader: &mut R,
        ) -> ::core::result::Result<Self, borsh::maybestd::io::Error> {
            Ok(Self {
                lp_token_amount: borsh::BorshDeserialize::deserialize_reader(reader)?,
                minimum_token_0_amount: borsh::BorshDeserialize::deserialize_reader(
                    reader,
                )?,
                minimum_token_1_amount: borsh::BorshDeserialize::deserialize_reader(
                    reader,
                )?,
            })
        }
    }
    impl anchor_lang::Discriminator for Withdraw {
        const DISCRIMINATOR: &'static [u8] = &[183, 18, 70, 156, 148, 109, 161, 34];
    }
    impl anchor_lang::InstructionData for Withdraw {}
    impl anchor_lang::Owner for Withdraw {
        fn owner() -> Pubkey {
            ID
        }
    }
    /// Instruction.
    pub struct SwapBaseInput {
        pub amount_in: u64,
        pub minimum_amount_out: u64,
    }
    impl borsh::ser::BorshSerialize for SwapBaseInput
    where
        u64: borsh::ser::BorshSerialize,
        u64: borsh::ser::BorshSerialize,
    {
        fn serialize<W: borsh::maybestd::io::Write>(
            &self,
            writer: &mut W,
        ) -> ::core::result::Result<(), borsh::maybestd::io::Error> {
            borsh::BorshSerialize::serialize(&self.amount_in, writer)?;
            borsh::BorshSerialize::serialize(&self.minimum_amount_out, writer)?;
            Ok(())
        }
    }
    impl anchor_lang::idl::build::IdlBuild for SwapBaseInput {
        fn create_type() -> Option<anchor_lang::idl::types::IdlTypeDef> {
            Some(anchor_lang::idl::types::IdlTypeDef {
                name: Self::get_full_path(),
                docs: <[_]>::into_vec(::alloc::boxed::box_new(["Instruction.".into()])),
                serialization: anchor_lang::idl::types::IdlSerialization::default(),
                repr: None,
                generics: ::alloc::vec::Vec::new(),
                ty: anchor_lang::idl::types::IdlTypeDefTy::Struct {
                    fields: Some(
                        anchor_lang::idl::types::IdlDefinedFields::Named(
                            <[_]>::into_vec(
                                ::alloc::boxed::box_new([
                                    anchor_lang::idl::types::IdlField {
                                        name: "amount_in".into(),
                                        docs: ::alloc::vec::Vec::new(),
                                        ty: anchor_lang::idl::types::IdlType::U64,
                                    },
                                    anchor_lang::idl::types::IdlField {
                                        name: "minimum_amount_out".into(),
                                        docs: ::alloc::vec::Vec::new(),
                                        ty: anchor_lang::idl::types::IdlType::U64,
                                    },
                                ]),
                            ),
                        ),
                    ),
                },
            })
        }
        fn insert_types(
            types: &mut std::collections::BTreeMap<
                String,
                anchor_lang::idl::types::IdlTypeDef,
            >,
        ) {}
        fn get_full_path() -> String {
            ::alloc::__export::must_use({
                ::alloc::fmt::format(
                    format_args!(
                        "{0}::{1}",
                        "raydium_cp_swap::instruction",
                        "SwapBaseInput",
                    ),
                )
            })
        }
    }
    impl borsh::de::BorshDeserialize for SwapBaseInput
    where
        u64: borsh::BorshDeserialize,
        u64: borsh::BorshDeserialize,
    {
        fn deserialize_reader<R: borsh::maybestd::io::Read>(
            reader: &mut R,
        ) -> ::core::result::Result<Self, borsh::maybestd::io::Error> {
            Ok(Self {
                amount_in: borsh::BorshDeserialize::deserialize_reader(reader)?,
                minimum_amount_out: borsh::BorshDeserialize::deserialize_reader(reader)?,
            })
        }
    }
    impl anchor_lang::Discriminator for SwapBaseInput {
        const DISCRIMINATOR: &'static [u8] = &[143, 190, 90, 218, 196, 30, 51, 222];
    }
    impl anchor_lang::InstructionData for SwapBaseInput {}
    impl anchor_lang::Owner for SwapBaseInput {
        fn owner() -> Pubkey {
            ID
        }
    }
    /// Instruction.
    pub struct SwapBaseOutput {
        pub max_amount_in: u64,
        pub amount_out: u64,
    }
    impl borsh::ser::BorshSerialize for SwapBaseOutput
    where
        u64: borsh::ser::BorshSerialize,
        u64: borsh::ser::BorshSerialize,
    {
        fn serialize<W: borsh::maybestd::io::Write>(
            &self,
            writer: &mut W,
        ) -> ::core::result::Result<(), borsh::maybestd::io::Error> {
            borsh::BorshSerialize::serialize(&self.max_amount_in, writer)?;
            borsh::BorshSerialize::serialize(&self.amount_out, writer)?;
            Ok(())
        }
    }
    impl anchor_lang::idl::build::IdlBuild for SwapBaseOutput {
        fn create_type() -> Option<anchor_lang::idl::types::IdlTypeDef> {
            Some(anchor_lang::idl::types::IdlTypeDef {
                name: Self::get_full_path(),
                docs: <[_]>::into_vec(::alloc::boxed::box_new(["Instruction.".into()])),
                serialization: anchor_lang::idl::types::IdlSerialization::default(),
                repr: None,
                generics: ::alloc::vec::Vec::new(),
                ty: anchor_lang::idl::types::IdlTypeDefTy::Struct {
                    fields: Some(
                        anchor_lang::idl::types::IdlDefinedFields::Named(
                            <[_]>::into_vec(
                                ::alloc::boxed::box_new([
                                    anchor_lang::idl::types::IdlField {
                                        name: "max_amount_in".into(),
                                        docs: ::alloc::vec::Vec::new(),
                                        ty: anchor_lang::idl::types::IdlType::U64,
                                    },
                                    anchor_lang::idl::types::IdlField {
                                        name: "amount_out".into(),
                                        docs: ::alloc::vec::Vec::new(),
                                        ty: anchor_lang::idl::types::IdlType::U64,
                                    },
                                ]),
                            ),
                        ),
                    ),
                },
            })
        }
        fn insert_types(
            types: &mut std::collections::BTreeMap<
                String,
                anchor_lang::idl::types::IdlTypeDef,
            >,
        ) {}
        fn get_full_path() -> String {
            ::alloc::__export::must_use({
                ::alloc::fmt::format(
                    format_args!(
                        "{0}::{1}",
                        "raydium_cp_swap::instruction",
                        "SwapBaseOutput",
                    ),
                )
            })
        }
    }
    impl borsh::de::BorshDeserialize for SwapBaseOutput
    where
        u64: borsh::BorshDeserialize,
        u64: borsh::BorshDeserialize,
    {
        fn deserialize_reader<R: borsh::maybestd::io::Read>(
            reader: &mut R,
        ) -> ::core::result::Result<Self, borsh::maybestd::io::Error> {
            Ok(Self {
                max_amount_in: borsh::BorshDeserialize::deserialize_reader(reader)?,
                amount_out: borsh::BorshDeserialize::deserialize_reader(reader)?,
            })
        }
    }
    impl anchor_lang::Discriminator for SwapBaseOutput {
        const DISCRIMINATOR: &'static [u8] = &[55, 217, 98, 86, 163, 74, 180, 173];
    }
    impl anchor_lang::InstructionData for SwapBaseOutput {}
    impl anchor_lang::Owner for SwapBaseOutput {
        fn owner() -> Pubkey {
            ID
        }
    }
    /// Instruction.
    pub struct DecompressAccountsIdempotent {
        pub proof: light_sdk::instruction::ValidityProof,
        pub compressed_accounts: Vec<CompressedAccountData>,
        pub system_accounts_offset: u8,
    }
    impl borsh::ser::BorshSerialize for DecompressAccountsIdempotent
    where
        light_sdk::instruction::ValidityProof: borsh::ser::BorshSerialize,
        Vec<CompressedAccountData>: borsh::ser::BorshSerialize,
        u8: borsh::ser::BorshSerialize,
    {
        fn serialize<W: borsh::maybestd::io::Write>(
            &self,
            writer: &mut W,
        ) -> ::core::result::Result<(), borsh::maybestd::io::Error> {
            borsh::BorshSerialize::serialize(&self.proof, writer)?;
            borsh::BorshSerialize::serialize(&self.compressed_accounts, writer)?;
            borsh::BorshSerialize::serialize(&self.system_accounts_offset, writer)?;
            Ok(())
        }
    }
    impl anchor_lang::idl::build::IdlBuild for DecompressAccountsIdempotent {
        fn create_type() -> Option<anchor_lang::idl::types::IdlTypeDef> {
            Some(anchor_lang::idl::types::IdlTypeDef {
                name: Self::get_full_path(),
                docs: <[_]>::into_vec(::alloc::boxed::box_new(["Instruction.".into()])),
                serialization: anchor_lang::idl::types::IdlSerialization::default(),
                repr: None,
                generics: ::alloc::vec::Vec::new(),
                ty: anchor_lang::idl::types::IdlTypeDefTy::Struct {
                    fields: Some(
                        anchor_lang::idl::types::IdlDefinedFields::Named(
                            <[_]>::into_vec(
                                ::alloc::boxed::box_new([
                                    anchor_lang::idl::types::IdlField {
                                        name: "proof".into(),
                                        docs: ::alloc::vec::Vec::new(),
                                        ty: anchor_lang::idl::types::IdlType::Defined {
                                            name: <light_sdk::instruction::ValidityProof>::get_full_path(),
                                            generics: ::alloc::vec::Vec::new(),
                                        },
                                    },
                                    anchor_lang::idl::types::IdlField {
                                        name: "compressed_accounts".into(),
                                        docs: ::alloc::vec::Vec::new(),
                                        ty: anchor_lang::idl::types::IdlType::Vec(
                                            Box::new(anchor_lang::idl::types::IdlType::Defined {
                                                name: <CompressedAccountData>::get_full_path(),
                                                generics: ::alloc::vec::Vec::new(),
                                            }),
                                        ),
                                    },
                                    anchor_lang::idl::types::IdlField {
                                        name: "system_accounts_offset".into(),
                                        docs: ::alloc::vec::Vec::new(),
                                        ty: anchor_lang::idl::types::IdlType::U8,
                                    },
                                ]),
                            ),
                        ),
                    ),
                },
            })
        }
        fn insert_types(
            types: &mut std::collections::BTreeMap<
                String,
                anchor_lang::idl::types::IdlTypeDef,
            >,
        ) {
            if let Some(ty) = <light_sdk::instruction::ValidityProof>::create_type() {
                types
                    .insert(
                        <light_sdk::instruction::ValidityProof>::get_full_path(),
                        ty,
                    );
                <light_sdk::instruction::ValidityProof>::insert_types(types);
            }
            if let Some(ty) = <CompressedAccountData>::create_type() {
                types.insert(<CompressedAccountData>::get_full_path(), ty);
                <CompressedAccountData>::insert_types(types);
            }
        }
        fn get_full_path() -> String {
            ::alloc::__export::must_use({
                ::alloc::fmt::format(
                    format_args!(
                        "{0}::{1}",
                        "raydium_cp_swap::instruction",
                        "DecompressAccountsIdempotent",
                    ),
                )
            })
        }
    }
    impl borsh::de::BorshDeserialize for DecompressAccountsIdempotent
    where
        light_sdk::instruction::ValidityProof: borsh::BorshDeserialize,
        Vec<CompressedAccountData>: borsh::BorshDeserialize,
        u8: borsh::BorshDeserialize,
    {
        fn deserialize_reader<R: borsh::maybestd::io::Read>(
            reader: &mut R,
        ) -> ::core::result::Result<Self, borsh::maybestd::io::Error> {
            Ok(Self {
                proof: borsh::BorshDeserialize::deserialize_reader(reader)?,
                compressed_accounts: borsh::BorshDeserialize::deserialize_reader(
                    reader,
                )?,
                system_accounts_offset: borsh::BorshDeserialize::deserialize_reader(
                    reader,
                )?,
            })
        }
    }
    impl anchor_lang::Discriminator for DecompressAccountsIdempotent {
        const DISCRIMINATOR: &'static [u8] = &[114, 67, 61, 123, 234, 31, 1, 112];
    }
    impl anchor_lang::InstructionData for DecompressAccountsIdempotent {}
    impl anchor_lang::Owner for DecompressAccountsIdempotent {
        fn owner() -> Pubkey {
            ID
        }
    }
    /// Instruction.
    pub struct CompressAccountsIdempotent {
        pub proof: light_sdk::instruction::ValidityProof,
        pub compressed_accounts: Vec<
            light_sdk::instruction::account_meta::CompressedAccountMetaNoLamportsNoAddress,
        >,
        pub signer_seeds: Vec<Vec<Vec<u8>>>,
        pub system_accounts_offset: u8,
    }
    impl borsh::ser::BorshSerialize for CompressAccountsIdempotent
    where
        light_sdk::instruction::ValidityProof: borsh::ser::BorshSerialize,
        Vec<
            light_sdk::instruction::account_meta::CompressedAccountMetaNoLamportsNoAddress,
        >: borsh::ser::BorshSerialize,
        Vec<Vec<Vec<u8>>>: borsh::ser::BorshSerialize,
        u8: borsh::ser::BorshSerialize,
    {
        fn serialize<W: borsh::maybestd::io::Write>(
            &self,
            writer: &mut W,
        ) -> ::core::result::Result<(), borsh::maybestd::io::Error> {
            borsh::BorshSerialize::serialize(&self.proof, writer)?;
            borsh::BorshSerialize::serialize(&self.compressed_accounts, writer)?;
            borsh::BorshSerialize::serialize(&self.signer_seeds, writer)?;
            borsh::BorshSerialize::serialize(&self.system_accounts_offset, writer)?;
            Ok(())
        }
    }
    impl anchor_lang::idl::build::IdlBuild for CompressAccountsIdempotent {
        fn create_type() -> Option<anchor_lang::idl::types::IdlTypeDef> {
            Some(anchor_lang::idl::types::IdlTypeDef {
                name: Self::get_full_path(),
                docs: <[_]>::into_vec(::alloc::boxed::box_new(["Instruction.".into()])),
                serialization: anchor_lang::idl::types::IdlSerialization::default(),
                repr: None,
                generics: ::alloc::vec::Vec::new(),
                ty: anchor_lang::idl::types::IdlTypeDefTy::Struct {
                    fields: Some(
                        anchor_lang::idl::types::IdlDefinedFields::Named(
                            <[_]>::into_vec(
                                ::alloc::boxed::box_new([
                                    anchor_lang::idl::types::IdlField {
                                        name: "proof".into(),
                                        docs: ::alloc::vec::Vec::new(),
                                        ty: anchor_lang::idl::types::IdlType::Defined {
                                            name: <light_sdk::instruction::ValidityProof>::get_full_path(),
                                            generics: ::alloc::vec::Vec::new(),
                                        },
                                    },
                                    anchor_lang::idl::types::IdlField {
                                        name: "compressed_accounts".into(),
                                        docs: ::alloc::vec::Vec::new(),
                                        ty: anchor_lang::idl::types::IdlType::Vec(
                                            Box::new(anchor_lang::idl::types::IdlType::Defined {
                                                name: <light_sdk::instruction::account_meta::CompressedAccountMetaNoLamportsNoAddress>::get_full_path(),
                                                generics: ::alloc::vec::Vec::new(),
                                            }),
                                        ),
                                    },
                                    anchor_lang::idl::types::IdlField {
                                        name: "signer_seeds".into(),
                                        docs: ::alloc::vec::Vec::new(),
                                        ty: anchor_lang::idl::types::IdlType::Vec(
                                            Box::new(
                                                anchor_lang::idl::types::IdlType::Vec(
                                                    Box::new(anchor_lang::idl::types::IdlType::Bytes),
                                                ),
                                            ),
                                        ),
                                    },
                                    anchor_lang::idl::types::IdlField {
                                        name: "system_accounts_offset".into(),
                                        docs: ::alloc::vec::Vec::new(),
                                        ty: anchor_lang::idl::types::IdlType::U8,
                                    },
                                ]),
                            ),
                        ),
                    ),
                },
            })
        }
        fn insert_types(
            types: &mut std::collections::BTreeMap<
                String,
                anchor_lang::idl::types::IdlTypeDef,
            >,
        ) {
            if let Some(ty) = <light_sdk::instruction::ValidityProof>::create_type() {
                types
                    .insert(
                        <light_sdk::instruction::ValidityProof>::get_full_path(),
                        ty,
                    );
                <light_sdk::instruction::ValidityProof>::insert_types(types);
            }
            if let Some(ty) = <light_sdk::instruction::account_meta::CompressedAccountMetaNoLamportsNoAddress>::create_type() {
                types
                    .insert(
                        <light_sdk::instruction::account_meta::CompressedAccountMetaNoLamportsNoAddress>::get_full_path(),
                        ty,
                    );
                <light_sdk::instruction::account_meta::CompressedAccountMetaNoLamportsNoAddress>::insert_types(
                    types,
                );
            }
        }
        fn get_full_path() -> String {
            ::alloc::__export::must_use({
                ::alloc::fmt::format(
                    format_args!(
                        "{0}::{1}",
                        "raydium_cp_swap::instruction",
                        "CompressAccountsIdempotent",
                    ),
                )
            })
        }
    }
    impl borsh::de::BorshDeserialize for CompressAccountsIdempotent
    where
        light_sdk::instruction::ValidityProof: borsh::BorshDeserialize,
        Vec<
            light_sdk::instruction::account_meta::CompressedAccountMetaNoLamportsNoAddress,
        >: borsh::BorshDeserialize,
        Vec<Vec<Vec<u8>>>: borsh::BorshDeserialize,
        u8: borsh::BorshDeserialize,
    {
        fn deserialize_reader<R: borsh::maybestd::io::Read>(
            reader: &mut R,
        ) -> ::core::result::Result<Self, borsh::maybestd::io::Error> {
            Ok(Self {
                proof: borsh::BorshDeserialize::deserialize_reader(reader)?,
                compressed_accounts: borsh::BorshDeserialize::deserialize_reader(
                    reader,
                )?,
                signer_seeds: borsh::BorshDeserialize::deserialize_reader(reader)?,
                system_accounts_offset: borsh::BorshDeserialize::deserialize_reader(
                    reader,
                )?,
            })
        }
    }
    impl anchor_lang::Discriminator for CompressAccountsIdempotent {
        const DISCRIMINATOR: &'static [u8] = &[70, 236, 171, 120, 164, 93, 113, 181];
    }
    impl anchor_lang::InstructionData for CompressAccountsIdempotent {}
    impl anchor_lang::Owner for CompressAccountsIdempotent {
        fn owner() -> Pubkey {
            ID
        }
    }
    /// Instruction.
    pub struct InitializeCompressionConfig {
        pub compression_delay: u32,
        pub rent_recipient: Pubkey,
        pub address_space: Vec<Pubkey>,
    }
    impl borsh::ser::BorshSerialize for InitializeCompressionConfig
    where
        u32: borsh::ser::BorshSerialize,
        Pubkey: borsh::ser::BorshSerialize,
        Vec<Pubkey>: borsh::ser::BorshSerialize,
    {
        fn serialize<W: borsh::maybestd::io::Write>(
            &self,
            writer: &mut W,
        ) -> ::core::result::Result<(), borsh::maybestd::io::Error> {
            borsh::BorshSerialize::serialize(&self.compression_delay, writer)?;
            borsh::BorshSerialize::serialize(&self.rent_recipient, writer)?;
            borsh::BorshSerialize::serialize(&self.address_space, writer)?;
            Ok(())
        }
    }
    impl anchor_lang::idl::build::IdlBuild for InitializeCompressionConfig {
        fn create_type() -> Option<anchor_lang::idl::types::IdlTypeDef> {
            Some(anchor_lang::idl::types::IdlTypeDef {
                name: Self::get_full_path(),
                docs: <[_]>::into_vec(::alloc::boxed::box_new(["Instruction.".into()])),
                serialization: anchor_lang::idl::types::IdlSerialization::default(),
                repr: None,
                generics: ::alloc::vec::Vec::new(),
                ty: anchor_lang::idl::types::IdlTypeDefTy::Struct {
                    fields: Some(
                        anchor_lang::idl::types::IdlDefinedFields::Named(
                            <[_]>::into_vec(
                                ::alloc::boxed::box_new([
                                    anchor_lang::idl::types::IdlField {
                                        name: "compression_delay".into(),
                                        docs: ::alloc::vec::Vec::new(),
                                        ty: anchor_lang::idl::types::IdlType::U32,
                                    },
                                    anchor_lang::idl::types::IdlField {
                                        name: "rent_recipient".into(),
                                        docs: ::alloc::vec::Vec::new(),
                                        ty: anchor_lang::idl::types::IdlType::Pubkey,
                                    },
                                    anchor_lang::idl::types::IdlField {
                                        name: "address_space".into(),
                                        docs: ::alloc::vec::Vec::new(),
                                        ty: anchor_lang::idl::types::IdlType::Vec(
                                            Box::new(anchor_lang::idl::types::IdlType::Pubkey),
                                        ),
                                    },
                                ]),
                            ),
                        ),
                    ),
                },
            })
        }
        fn insert_types(
            types: &mut std::collections::BTreeMap<
                String,
                anchor_lang::idl::types::IdlTypeDef,
            >,
        ) {}
        fn get_full_path() -> String {
            ::alloc::__export::must_use({
                ::alloc::fmt::format(
                    format_args!(
                        "{0}::{1}",
                        "raydium_cp_swap::instruction",
                        "InitializeCompressionConfig",
                    ),
                )
            })
        }
    }
    impl borsh::de::BorshDeserialize for InitializeCompressionConfig
    where
        u32: borsh::BorshDeserialize,
        Pubkey: borsh::BorshDeserialize,
        Vec<Pubkey>: borsh::BorshDeserialize,
    {
        fn deserialize_reader<R: borsh::maybestd::io::Read>(
            reader: &mut R,
        ) -> ::core::result::Result<Self, borsh::maybestd::io::Error> {
            Ok(Self {
                compression_delay: borsh::BorshDeserialize::deserialize_reader(reader)?,
                rent_recipient: borsh::BorshDeserialize::deserialize_reader(reader)?,
                address_space: borsh::BorshDeserialize::deserialize_reader(reader)?,
            })
        }
    }
    impl anchor_lang::Discriminator for InitializeCompressionConfig {
        const DISCRIMINATOR: &'static [u8] = &[133, 228, 12, 169, 56, 76, 222, 61];
    }
    impl anchor_lang::InstructionData for InitializeCompressionConfig {}
    impl anchor_lang::Owner for InitializeCompressionConfig {
        fn owner() -> Pubkey {
            ID
        }
    }
    /// Instruction.
    pub struct UpdateCompressionConfig {
        pub new_compression_delay: Option<u32>,
        pub new_rent_recipient: Option<Pubkey>,
        pub new_address_space: Option<Vec<Pubkey>>,
        pub new_update_authority: Option<Pubkey>,
    }
    impl borsh::ser::BorshSerialize for UpdateCompressionConfig
    where
        Option<u32>: borsh::ser::BorshSerialize,
        Option<Pubkey>: borsh::ser::BorshSerialize,
        Option<Vec<Pubkey>>: borsh::ser::BorshSerialize,
        Option<Pubkey>: borsh::ser::BorshSerialize,
    {
        fn serialize<W: borsh::maybestd::io::Write>(
            &self,
            writer: &mut W,
        ) -> ::core::result::Result<(), borsh::maybestd::io::Error> {
            borsh::BorshSerialize::serialize(&self.new_compression_delay, writer)?;
            borsh::BorshSerialize::serialize(&self.new_rent_recipient, writer)?;
            borsh::BorshSerialize::serialize(&self.new_address_space, writer)?;
            borsh::BorshSerialize::serialize(&self.new_update_authority, writer)?;
            Ok(())
        }
    }
    impl anchor_lang::idl::build::IdlBuild for UpdateCompressionConfig {
        fn create_type() -> Option<anchor_lang::idl::types::IdlTypeDef> {
            Some(anchor_lang::idl::types::IdlTypeDef {
                name: Self::get_full_path(),
                docs: <[_]>::into_vec(::alloc::boxed::box_new(["Instruction.".into()])),
                serialization: anchor_lang::idl::types::IdlSerialization::default(),
                repr: None,
                generics: ::alloc::vec::Vec::new(),
                ty: anchor_lang::idl::types::IdlTypeDefTy::Struct {
                    fields: Some(
                        anchor_lang::idl::types::IdlDefinedFields::Named(
                            <[_]>::into_vec(
                                ::alloc::boxed::box_new([
                                    anchor_lang::idl::types::IdlField {
                                        name: "new_compression_delay".into(),
                                        docs: ::alloc::vec::Vec::new(),
                                        ty: anchor_lang::idl::types::IdlType::Option(
                                            Box::new(anchor_lang::idl::types::IdlType::U32),
                                        ),
                                    },
                                    anchor_lang::idl::types::IdlField {
                                        name: "new_rent_recipient".into(),
                                        docs: ::alloc::vec::Vec::new(),
                                        ty: anchor_lang::idl::types::IdlType::Option(
                                            Box::new(anchor_lang::idl::types::IdlType::Pubkey),
                                        ),
                                    },
                                    anchor_lang::idl::types::IdlField {
                                        name: "new_address_space".into(),
                                        docs: ::alloc::vec::Vec::new(),
                                        ty: anchor_lang::idl::types::IdlType::Option(
                                            Box::new(
                                                anchor_lang::idl::types::IdlType::Vec(
                                                    Box::new(anchor_lang::idl::types::IdlType::Pubkey),
                                                ),
                                            ),
                                        ),
                                    },
                                    anchor_lang::idl::types::IdlField {
                                        name: "new_update_authority".into(),
                                        docs: ::alloc::vec::Vec::new(),
                                        ty: anchor_lang::idl::types::IdlType::Option(
                                            Box::new(anchor_lang::idl::types::IdlType::Pubkey),
                                        ),
                                    },
                                ]),
                            ),
                        ),
                    ),
                },
            })
        }
        fn insert_types(
            types: &mut std::collections::BTreeMap<
                String,
                anchor_lang::idl::types::IdlTypeDef,
            >,
        ) {}
        fn get_full_path() -> String {
            ::alloc::__export::must_use({
                ::alloc::fmt::format(
                    format_args!(
                        "{0}::{1}",
                        "raydium_cp_swap::instruction",
                        "UpdateCompressionConfig",
                    ),
                )
            })
        }
    }
    impl borsh::de::BorshDeserialize for UpdateCompressionConfig
    where
        Option<u32>: borsh::BorshDeserialize,
        Option<Pubkey>: borsh::BorshDeserialize,
        Option<Vec<Pubkey>>: borsh::BorshDeserialize,
        Option<Pubkey>: borsh::BorshDeserialize,
    {
        fn deserialize_reader<R: borsh::maybestd::io::Read>(
            reader: &mut R,
        ) -> ::core::result::Result<Self, borsh::maybestd::io::Error> {
            Ok(Self {
                new_compression_delay: borsh::BorshDeserialize::deserialize_reader(
                    reader,
                )?,
                new_rent_recipient: borsh::BorshDeserialize::deserialize_reader(reader)?,
                new_address_space: borsh::BorshDeserialize::deserialize_reader(reader)?,
                new_update_authority: borsh::BorshDeserialize::deserialize_reader(
                    reader,
                )?,
            })
        }
    }
    impl anchor_lang::Discriminator for UpdateCompressionConfig {
        const DISCRIMINATOR: &'static [u8] = &[135, 215, 243, 81, 163, 146, 33, 70];
    }
    impl anchor_lang::InstructionData for UpdateCompressionConfig {}
    impl anchor_lang::Owner for UpdateCompressionConfig {
        fn owner() -> Pubkey {
            ID
        }
    }
}
/// An Anchor generated module, providing a set of structs
/// mirroring the structs deriving `Accounts`, where each field is
/// a `Pubkey`. This is useful for specifying accounts for a client.
pub mod accounts {
    pub use crate::__client_accounts_update_pool_status::*;
    pub use crate::__client_accounts_update_amm_config::*;
    pub use crate::__client_accounts_collect_protocol_fee::*;
    pub use crate::__client_accounts_initialize::*;
    pub use crate::__client_accounts_deposit::*;
    pub use crate::__client_accounts_withdraw::*;
    pub use crate::__client_accounts_create_amm_config::*;
    pub use crate::__client_accounts_decompress_accounts_idempotent::*;
    pub use crate::__client_accounts_swap::*;
    pub use crate::__client_accounts_compress_accounts_idempotent::*;
    pub use crate::__client_accounts_initialize_compression_config::*;
    pub use crate::__client_accounts_update_compression_config::*;
    pub use crate::__client_accounts_collect_fund_fee::*;
}
